package OnAttack

import DamageDetection
import initlater HeroType
import PlayerControl
import ClosureTimers
import TimerUtils
import UnitTypeConfig
import initlater SeaDruid
import initlater TrollBerserker
import StandardTextTags
import HashMap
import GameTimer

import ItemIdGeneration
import initlater ItemShopSystem

public constant ADVANCED_ONHIT =  'A00I'
public constant DEFAULT_ONHIT = 'A008'
/*
    ADVANCED_ONHIT can temporarily replace the default on hit abiltiy to get a temporary special attack, that depends
    on the time when the attack is fired and not when it is hit (so only relevant for ranged attacks)
    ADVANCED_ONHIT will trigger all effects DEFAULT_ONHIT triggers, but can be used to trigger additional effects
    Every hero should only have one ability utilizing ADVANCED_ONHIT (more abilities would be repetitive anyways)
*/


function unit.dealDamageNoEvent(unit target, real amount, ReductionType reductionType)
    disableDamageDetect()
    this.dealDamage(target, amount, reductionType)
    enableDamageDetect()

/*function unitSetAfterLife()
    if prevenDeathUnit != null
        prevenDeathUnit.removeAbility(PREVENT_DEATH)
        prevenDeathUnit.setHP(prevenDeathAfterLife)
        print("now set hp of "+prevenDeathUnit.getName()+" to "+prevenDeathAfterLife.toString())
        prevenDeathUnit = null*/

/*
**
**  This function handles ALL damage event funtions, where the damage amount matters.
**  By having all in this function, the order the functions run can be set the easiest.
**
*/
function handleDamageAmount(unit source, unit target, boolean isAttack, boolean _isActive, boolean advanced)
    let originalDamage = GetEventDamage()
    real currentDamage = originalDamage

    if originalDamage.abs() < 0.000001 //damage very small, just ignore
        return






    /*
        untargetable -> damage = 0 and no further damage handling
        only for attacks, because every other damage will be dealt in code and there I can decide individually, if I want to deal damage
    */

    if (target.isType(UNIT_TYPE_ANCIENT) and isAttack) or gameOver
        currentDamage = 0
    else

        //example:
        //currentDamage = currentDamage/2

        //===============================================================================


        // critical strike - TROLL BERSERKER
        if advanced and source.isType(UNIT_TYPE_HERO) and BuffList.hasBuffType(source, buffCriticalStrike) and not target.isType(UNIT_TYPE_STRUCTURE)
            let critical = BuffList.getBuffOfType(source, buffCriticalStrike)
            currentDamage = currentDamage * (100 + CRITICAL_DAMAGE_MULT[critical.getLevel()-1])/100
            createCriticalStrikeTextTag(target, currentDamage.toInt())
            critical.dispel()


        // shield - ITEM
        if isAttack and target.isType(UNIT_TYPE_HERO)
            currentDamage = currentDamage - 18 * target.countItemsOfType(convertItemId(ITEM_ID_SHIELD))

        // mana shield - SEA DRUID
        if target.isType(UNIT_TYPE_HERO) and BuffList.hasBuffType(target, buffManaShield)
            
            let manaShield = BuffList.getBuffOfType(target, buffManaShield)
            let level = manaShield.getLevel()

            
            manaShield.getTarget().damageMana(manaShield.getTarget(), MANA_SHIELD_REDUCTION[level-1] * MANA_PER_DAMAGE[level-1] * currentDamage, ReductionType.NONE)
            currentDamage = currentDamage * (1.-MANA_SHIELD_REDUCTION[level-1])
    
        // vampiric goblet - ITEM
        if source.isType(UNIT_TYPE_HERO) and source.hasItemById(convertItemId(ITEM_ID_VAMPIRIC_GOBLET)) and target.isType(UNIT_TYPE_HERO)
            source.healHP(source, currentDamage * 0.2)
            source.healMana(source, currentDamage * 0.15)

        // wand of blood - ITEM
        if source.isType(UNIT_TYPE_HERO) and source.hasItemById(convertItemId(ITEM_ID_WAND_OF_BLOOD)) and not target.isType(UNIT_TYPE_STRUCTURE)
            source.healHP(source, currentDamage * 0.08)

        // sacrifical dagger - ITEM
        if isAttack and source.isType(UNIT_TYPE_HERO) and source.hasItemById(convertItemId(ITEM_ID_SACRIFICIAL_DAGGER)) and not target.isType(UNIT_TYPE_STRUCTURE)
            source.healHP(source, currentDamage * 0.12)

        // void armor - ITEM
        if target.isType(UNIT_TYPE_HERO) and target.hasItemById(convertItemId(ITEM_ID_VOID_ARMOR))
            target.healMana(target, currentDamage * 0.05)
            currentDamage *= 0.95

        // wand of death - ITEM
        if source.isType(UNIT_TYPE_HERO) and source.hasItemById(convertItemId(ITEM_ID_WAND_OF_DEATH)) and target.isType(UNIT_TYPE_HERO)
            let wp = currentDamage * 0.02
            let wrapper = target.wrapper()
            wrapper.addStatAbsoluteBonusReal(Stat.AGI, (-wp*1000).toInt())
            doAfter(10, () -> wrapper.addStatAbsoluteBonusReal(Stat.AGI, (wp*1000).toInt() ) )


        //===============================================================================

    target.getOwner().getCPlayer().statDamageTaken += min(currentDamage, target.getHP())
    source.getOwner().getCPlayer().statDamageDealt += min(currentDamage, target.getHP())

    if target.isType(UNIT_TYPE_HERO) and source.getOwner().getId() < MAX_HERO_COUNT
        /*let factor = currentDamage.pow(0.3)*4
        CreateTextTag()..setText(currentDamage.round().toString(), factor/2+4)
                             ..setColor(200, 50, 25, 255)
                             ..setPos(target.getX(), target.getY(), 0)
                             ..setFadepoint(0)
                             ..setLifespan(factor/20+0.4)
                             ..setPermanent(false)
                             ..setVisibility(true)
                             ..setVelocity(GetRandomReal(-0.02, 0.02), 0.04)*/

        //DamageTag.addDamage(target, currentDamage)

    BlzSetEventDamage(currentDamage)



class DamageTag

    private real timeout
    private timer periodicTimer
    private unit target
    private texttag tag
    private real damage
    

    private static constant unitMap = new HashMap<unit, DamageTag>()
    private static constant objectList = new LinkedList<DamageTag>()



    static function addDamage(unit target, real damage)
        DamageTag damageTag = unitMap.get(target)
        if damageTag == null
            new DamageTag(target, damage)
        else
            if damageTag.timeout < getElapsedGameTime()
                destroy damageTag
                new DamageTag(target, damage)
            else
                damageTag.timeout = getElapsedGameTime() + 1
                damageTag.damage += damage
                damageTag.tag.setAge(0)
                damageTag.tag.setText(damageTag.damage.round().toString(), 0.024 / 0.0023)

    static function updateStatic()
        let t = GetExpiredTimer()
        (t.getData() castTo DamageTag).update()

    function update()
        this.tag.setPos(target.getX(), target.getY(), 40)
        if this.timeout < getElapsedGameTime()
            destroy this

    construct(unit target, real damage)
        this.target = target
        this.damage = damage
        this.timeout = getElapsedGameTime() + 1
        this.periodicTimer = getTimer()
            ..startPeriodic(0.02, function updateStatic)
            ..setData(this castTo int)
        this.tag = CreateTextTag()..setText(damage.round().toString(), 0.024 / 0.0023)
                             ..setColor(200, 50, 25, 255)
                             ..setPos(target.getX(), target.getY(), 40)
                             ..setFadepoint(1.)
                             ..setLifespan(1.5)
                             ..setPermanent(false)
                             ..setVisibility(true)
        
        
        unitMap.put(target, this)
        objectList.add(this)

    ondestroy
        this.periodicTimer.release()
        objectList.remove(this)
        unitMap.remove(this.target)
    
    

public interface OnAttackFunction
    function onAttack(unit attacker, unit target, boolean isActive)

public interface OnAttackFunctionAdvanced
    function onAttack(unit attacker, unit target, boolean isActive, boolean advanced)


public class OnAttack

    private static unit target
    private static unit attacker
    private static boolean active
    private static trigger onAttackTrigger = CreateTrigger()
    private static constant onAttackFunctionList = new LinkedList<OnAttackFunction>()
    private static constant onAttackFunctionListAdvanced = new LinkedList<OnAttackFunctionAdvanced>()

    protected static int countEvents = 0

    protected static function onDamage()
        //use local variables to avoid overwriting
        //set global variables right before calling other functions
        let localTarget = GetTriggerUnit()
        let localAttacker = GetEventDamageSource()
        var localActive = false
        var localAttacked = false
        var advanced = false

        countEvents++
        if countEvents > 1000
            print("Warning. Very high number of damage events per second: "+countEvents.toString())

        if(localTarget.hasAbility('B005')) or localAttacker.getTypeId() == MORTAR_TEAM //passive
            localTarget.removeAbility('B005')
            localAttacked = true
        if(localTarget.hasAbility('B00G')) //advanced
            localTarget.removeAbility('B00G')
            localAttacked = true
            advanced = true

        else if(localTarget.hasAbility('B006')) //arrow
            localTarget.removeAbility('B006')
            localActive = true
            localAttacked = true


        target = localTarget
        attacker = localAttacker
        active = localActive
        handleDamageAmount(localAttacker, localTarget, localAttacked, localActive, advanced)

        //use a list with arguments, as a onAttack function could trigger an onAttack event and overwrite the variables
        if localAttacked and not localTarget.isType(UNIT_TYPE_ANCIENT) //untargetable
            for OnAttackFunction onAttack in onAttackFunctionList
                onAttack.onAttack(localAttacker, localTarget, localActive)

            for OnAttackFunctionAdvanced onAttack in onAttackFunctionListAdvanced
                onAttack.onAttack(localAttacker, localTarget, localActive, advanced)

        


    /*static function getAttacker() returns unit
        return attacker

    static function getTarget() returns unit
        return target   

    static function isActive() returns boolean
        return active*/

    static function addOnAttackFunc(OnAttackFunction onAttack)
        onAttackFunctionList.add(onAttack)

    static function addOnAttackFuncAdvanced(OnAttackFunctionAdvanced onAttack)
        onAttackFunctionListAdvanced.add(onAttack)

    protected static function onAttackAbilities(unit attacker, unit target, boolean isActive, boolean advanced)
        HeroType heroType = HeroType.getHeroType(attacker.getTypeId())
        if(heroType!=null)
            heroType.onAttack(attacker, target, isActive, advanced)

    static function useAdvanced(unit whichUnit, boolean advanced)
        if advanced
            whichUnit
                ..removeAbility(DEFAULT_ONHIT)
                ..addAbility(ADVANCED_ONHIT)
        else
            whichUnit
                ..removeAbility(ADVANCED_ONHIT)
                ..addAbility(DEFAULT_ONHIT)


init
    addOnDamageFunc(Condition(function OnAttack.onDamage))

    //use hashmap, so onAttack is more efficient
    //if there are a lot of heroes, if-then-else to find the correct
    //actions to execute is inefficient
    OnAttack.addOnAttackFuncAdvanced((unit attacker, unit target, boolean isActive, boolean advanced) -> OnAttack.onAttackAbilities(attacker, target, isActive, advanced))

    doPeriodically(0.1, (CallbackPeriodic _cb) -> (begin
        OnAttack.countEvents = 0
    end))