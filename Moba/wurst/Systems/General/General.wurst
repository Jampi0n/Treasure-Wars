package General

import Buff
import BuffTypeConfig
import Missile
import UnitWrapper
import initlater PlayerControl
import ClosureTimers
import UnitType
import initlater ItemIds
import public Constants
import Assets
import DamageDetection
import HashMap
import ErrorHandling
import Execute

public boolean gameOver = false

/*
    Cannot be targeted by negative spells or attacks.
*/
public constant INVULERNABLE = new BuffType(true, DispelLevel.NONE)
/*
    Cannot be targeted by any spells or attacks.
*/
public constant UNTARGETABLE = new BuffType(true, DispelLevel.NONE)

public enum ReductionType
    PHYSICAL
    MAGIC
    NONE


/*
    Every update to any hero button unhides all buttons.
    Possible updates:
        main hero dies
        main hero revives
        main hero levels up
        main hero learns skill
        secondary hero levels up
*/
framehandle array heroButtons

function initHeroButtonArray()
    for j = 0 to 6
        heroButtons[4*j] = getOriginFrame(ORIGIN_FRAME_HERO_BUTTON, j)
        heroButtons[4*j+1] = getOriginFrame(ORIGIN_FRAME_HERO_HP_BAR, j)
        heroButtons[4*j+2] = getOriginFrame(ORIGIN_FRAME_HERO_MANA_BAR, j)
        heroButtons[4*j+3] = getOriginFrame(ORIGIN_FRAME_HERO_BUTTON_INDICATOR, j)


public function unit.isTargetable(player source, boolean allowFriends, boolean allowEnemies) returns boolean
    boolean ret = true
    if this == null
        ret = false
    else if not this.isAlive()
        ret = false
    else if IsUnitEnemy(this, source) 
        ret = allowEnemies and not IsUnitType(this, UNIT_TYPE_ANCIENT) and not IsUnitType(this, UNIT_TYPE_MAGIC_IMMUNE)
    else if IsUnitAlly(this, source) 
        ret = allowFriends and not IsUnitType(this, UNIT_TYPE_MAGIC_IMMUNE)

    return ret

public function unit.isVisible(player source) returns boolean
    return IsUnitVisible(this, source)

public function unit.isMovable() returns boolean
    if GetUnitPropWindow(this) < 0.00001
        return false
    if BuffList.hasBuffType(this, ENSNARED)
        return false
    if BuffList.hasBuffType(this, ENTANGLED)
        return false
    if this.getDefaultMovespeed() == 0
        return false
    return true

public function unit.getStr() returns int
    int ret
    if this.isType(UNIT_TYPE_HERO)
        ret = GetHeroStr(this, true)
    else
        ret = this.wrapper().getStatTotalValue(Stat.STR)
    return ret

public function unit.getWp() returns int
    int ret
    if this.isType(UNIT_TYPE_HERO)
        ret = GetHeroAgi(this, true)
    else
        ret = this.wrapper().getStatTotalValue(Stat.AGI)
    return ret

public function unit.getInt() returns int
    int ret
    if this.isType(UNIT_TYPE_HERO)
        ret = GetHeroInt(this, true)
    else
        ret = this.wrapper().getStatTotalValue(Stat.INT)
    return ret

public function real.factor(int statValue, real atHundred) returns real
    return this * (atHundred*statValue/100 + 1)

public function int.factor(int statValue, real atHundred) returns real
    return this.toReal().factor(statValue, atHundred)

public function real.bonus(int statValue, real atHundred) returns real
    return this + atHundred*statValue/100

public function int.bonus(int statValue, int atHundred) returns real
    return this.toReal().bonus(statValue, atHundred.toReal())

public function real.reduceMagic(int stat) returns real
    return this.reduce(stat, MAGIC_REDUCTION)

public function real.reduceArmor(int stat) returns real
    return this.reduce(stat, ARMOR_REDUCTION)

public function real.reduce(int stat, real reduction) returns real
    return this / ( 1 + max(stat, -20) * reduction )

public function unit.addBuff(unit caster, real duration, BuffType buffType, int level) returns Buff
    Buff ret = null
    if (duration <= 0 and duration > -0.5) or duration > 600
        Log.warn("addBuff add buff with unusual duration: " + duration.toString())
    if this.isAlive()
        execute() () ->
            new Buff(this, caster, duration, buffType, level)
        ret = BuffList.getBuffOfType(this, buffType)
    return ret

public function unit.addBuffReduced(unit caster, real duration, BuffType buffType, int level) returns Buff
    //buff reduction only uses 1/4 of the wp, so it reduces duration not as much as it reduces damage
    real realDuration =  duration.reduce( (this.getWp()/4).toInt() , 0.01 )
    if this.hasItemById(ITEM_ID_ARCANE_SHIELD)
        realDuration = realDuration * 0.85
    Buff ret = null
    if (realDuration <= 0 and realDuration > -0.5) or realDuration > 600
        Log.warn("addBuffReduced add buff with unusual duration: " + realDuration.toString())
    if this.isAlive()
        execute() () ->
            new Buff(this, caster, realDuration, buffType, level)
        ret = BuffList.getBuffOfType(this, buffType)
    return ret


public function unit.dealDamageAlways(unit target, real amount, ReductionType reductionType)
    let damageType = reductionType == ReductionType.PHYSICAL ? DAMAGE_TYPE_NORMAL : DAMAGE_TYPE_UNIVERSAL
    real newAmount
    if reductionType == ReductionType.MAGIC
        let wp = target.getWp()
        newAmount = amount.reduceMagic(wp)
    else
        newAmount = amount

    UnitDamageTarget(this, target, newAmount, false, true, ATTACK_TYPE_NORMAL, damageType, WEAPON_TYPE_WHOKNOWS)

public function unit.dealDamage(unit target, real amount, ReductionType reductionType)
    if not target.isType(UNIT_TYPE_ANCIENT)
        this.dealDamageAlways(target, amount, reductionType)
        if not IsUnitEnemy(target, this.getOwner()) and this != target
            Log.warn(this.getName()+" damages ally: "+target.getName())

public function unit.damageMana(unit target, real amount, ReductionType reductionType)
    real newAmount
    if reductionType == ReductionType.MAGIC
        let wp = target.getWp()
        newAmount = amount.reduceMagic(wp)
    else if reductionType == ReductionType.PHYSICAL
        let ar = target.getArmor().round()
        newAmount = amount.reduceMagic(ar)
    else
        newAmount = amount
    target.addMana(-newAmount)

public function unit.healHP(unit target, real amount)
    real realAmount = amount
    if this.hasItemById(ITEM_ID_BRACER_OF_POWER)
        realAmount *= 1.15

    realAmount = min(realAmount, target.getMaxHP()-target.getHP())
    target.setHP(target.getHP() + realAmount)

    PlayerWrapper.statHealingReceived[target.getOwner().getId()] += realAmount
    PlayerWrapper.statHealingDone[this.getOwner().getId()] += realAmount

public function unit.healMana(unit target, real amount)
    real realAmount = amount
    if this.hasItemById(ITEM_ID_BRACER_OF_POWER)
        realAmount *= 1.15

    realAmount = min(realAmount, target.getMaxMana()-target.getMana())
    target.setMana(target.getMana() + realAmount)

    PlayerWrapper.statManaHealed[target.getOwner().getId()] += realAmount

public function unit.dispelPositiveBuffs(DispelLevel dispelLevel)
    let buffList = this.getBuffList()
    if buffList != null
        for Buff currentBuff in buffList.getLinkedList()
            let buffType =currentBuff.getBuffType()
            if buffType.isPositive() and currentBuff.getDispelLevel() castTo int <= dispelLevel castTo int
                currentBuff.dispel()

public function unit.dispelNegativeBuffs(DispelLevel dispelLevel)
    let buffList = this.getBuffList()
    if buffList != null
        for Buff currentBuff in buffList.getLinkedList()
            let buffType =currentBuff.getBuffType()
            if not buffType.isPositive() and currentBuff.getDispelLevel() castTo int <= dispelLevel castTo int
                currentBuff.dispel()


public function unit.dispelBuffs(DispelLevel dispelLevel)
    let buffList = this.getBuffList()
    if buffList != null
        for Buff currentBuff in buffList.getLinkedList()
            if currentBuff.getDispelLevel() castTo int <= dispelLevel castTo int
                currentBuff.dispel()


@deprecated("use PlayerWrapper.getFullColoredName(int id)")
public function player.getFullColoredName() returns string
    return PlayerWrapper.getFullColoredName(this.getId())


public function unit.hitBoxDistanceTo(vec2 pos) returns real
    return max(0, this.getPos().distanceTo(pos) - this.getHitBox())

public function enumUnitsInHitBoxRange(vec2 pos, real range) returns group
    let g = CreateGroup()
    g.enumUnitsInRange(pos, range + MAX_HIT_BOX)
    let returnGroup = CreateGroup()
    while(true)
        let u = FirstOfGroup(g)
        if u == null
            break
        g.removeUnit(u)
        if u.hitBoxDistanceTo(pos) <= range
            returnGroup.addUnit(u)
    
    g.destr()
    return returnGroup

public function unit.countItemsOfType(int itemTypeId) returns int
    item indexItem
    int count = 0

    for i = 0 to bj_MAX_INVENTORY-1
        indexItem = UnitItemInSlot(this, i)
        if (indexItem != null) and (indexItem.getTypeId() == itemTypeId)
            count++

    return count



public class ChannelTeleport

    private unit caster
    private vec2 targetPos = vec2(0,0)
    private effect channelEffectCaster
    private effect channelEffectTarget
    private static constant unitMap = new HashMap<unit, ChannelTeleport>
    private boolean alive = true
    private real maxDamage
    private real damage = 0


    construct(unit caster, vec2 targetPos, real dur, real maxDamage)
        this.caster = caster
        this.targetPos = targetPos
        this.maxDamage = maxDamage
        create(dur)

    private function create(real dur)
        this.caster.pause()
        this.channelEffectCaster = addEffect(Abilities.massTeleportTo, this.caster.getPos())
        this.channelEffectTarget = addEffect(Abilities.massTeleportTo, this.targetPos)
        addOnDamageFunc(Condition(function onDamage))
        unitMap.put(this.caster, this)
        doAfter(dur, () ->(begin
            if this.alive
                this.onTeleport()
            else
                destroy this
        end))

    private static function onDamage()
        let teleport = unitMap.get(GetTriggerUnit())
        if teleport != null
            teleport.damage += GetEventDamage()
            if teleport.maxDamage > -0.5 and teleport.damage > teleport.maxDamage
                teleport.remove()
            else
                let u = GetTriggerUnit()
                if BuffList.hasBuffType(u, STUNNED) or BuffList.hasBuffType(u, SILENCED) or not u.isMovable()
                    teleport.remove()
        
    private function onTeleport()
        addEffect(Abilities.massTeleportCaster, this.caster.getPos()).destr()
        addEffect(Abilities.massTeleportTarget, this.targetPos).destr()
        this.caster.setPos(targetPos)
        this.remove()
        destroy this

    private function remove()
        this.alive = false
        this.channelEffectCaster.destr()
        this.channelEffectTarget.destr()
        unitMap.remove(this.caster)
        doAfter(0.5) -> 
            this.caster.unpause()



init
    initHeroButtonArray()
    setHitBoxFunction( (unit u) -> (begin
        real ret = 32
        if u.isType(UNIT_TYPE_HERO)
            ret = 64
        else
            let unitType = UnitType.getUnitType(u.getTypeId())
            if unitType!=null
                ret = unitType.getHitBox().toReal()
        return ret
    end))

    setGetBuffListFunction( (unit u) -> (begin
        return u.getBuffList()
    end))

    setCreateBuffListFunction( (unit u) -> (begin
        if u.wrapper() != null
            u.wrapper().createBuffList()
        else
            error("The unit "+u.getName()+" had no wrapper.")
            UnitWrapper.create(u)
            u.wrapper().createBuffList()
    end))
    
    dispelBuffsOnDeath()

    if DEBUG_MODE
        doAfter(1, () -> print("DEBUG_MODE is enabled."))
        CreateTrigger()
        ..registerPlayerChatEvent(players[0], "buff", false)
        ..addAction(() -> (begin
            debugBuff()
        end))

    //prevent teamkill
    let trg = CreateTrigger()
    for i = 0 to MAX_HERO_COUNT-1
        trg.registerPlayerUnitEvent(Player(i), EVENT_PLAYER_UNIT_ISSUED_UNIT_ORDER, null)

    trg.addAction(() ->(begin
        if GetIssuedOrderId() == OrderId("attack")
            let attacker = GetTriggerUnit()
            let target = GetOrderTargetUnit()
            if target != null and attacker.getOwner().isAllyOf(target.getOwner())
                doAfter(0, () -> (begin
                    if not attacker.issuePointOrder("attack", target.getPos())
                        attacker.issueImmediateOrder("stop")
                end))
    end))

    Player(PLAYER_NEUTRAL_AGGRESSIVE).setName("Creeps")

    INVULERNABLE.addFirstFunction() (Buff whichBuff) ->
        let target = whichBuff.getTarget()
        target.dispelNegativeBuffs(DispelLevel.BREAK)
        UnitAddType(target, UNIT_TYPE_ANCIENT)
    INVULERNABLE.addEndFunction() (Buff whichBuff) ->
        UnitRemoveType(whichBuff.getTarget(), UNIT_TYPE_ANCIENT)
        
    UNTARGETABLE.addFirstFunction() (Buff whichBuff) ->
        let target = whichBuff.getTarget()
        target.dispelBuffs(DispelLevel.BREAK)
        UnitAddType(target, UNIT_TYPE_SAPPER)
    UNTARGETABLE.addEndFunction() (Buff whichBuff) ->
        UnitRemoveType(whichBuff.getTarget(), UNIT_TYPE_SAPPER)