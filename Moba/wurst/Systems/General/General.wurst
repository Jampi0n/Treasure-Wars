package General

import Buff
import UnitWrapper

constant MAGIC_REDUCTION = 0.01

public enum ReductionType
    PHYSICAL
    MAGIC
    NONE


public function unit.isTargetable(player source, boolean allowFriends, boolean allowEnemies) returns boolean
    if not this.isAlive()
        return false
    if this.isType(UNIT_TYPE_ANCIENT)
        return false
    if not allowEnemies and IsUnitEnemy(this, source) 
        return false
    if not allowFriends and IsUnitAlly(this, source) 
        return false
    
    return true

public function unit.isVisible(player source) returns boolean
    return IsUnitVisible(this, source)


public function unit.getStr() returns int
    return GetHeroStr(this, true)

public function unit.getWp() returns int
    return GetHeroAgi(this, true)

public function unit.getInt() returns int
    return GetHeroInt(this, true)

public function real.factor(int statValue, real atHundred) returns real
    return this * (atHundred*statValue/100 + 1)

public function int.factor(int statValue, real atHundred) returns real
    return this.toReal().factor(statValue, atHundred)

public function real.bonus(int statValue, real atHundred) returns real
    return this + atHundred*statValue/100

public function int.bonus(int statValue, real atHundred) returns real
    return this.toReal().bonus(statValue, atHundred)

public function unit.dealDamage(unit target, real amount, ReductionType reductionType)
    let damageType = reductionType == ReductionType.PHYSICAL ? DAMAGE_TYPE_NORMAL : DAMAGE_TYPE_UNIVERSAL
    real newAmount
    if(reductionType == ReductionType.MAGIC and target.isType(UNIT_TYPE_HERO))
        let wp = GetHeroAgi(target, true)
        newAmount = amount * (1-( wp*MAGIC_REDUCTION )/( 1 + wp*MAGIC_REDUCTION ))
    else
        newAmount = amount
    //print(this.getName()+" damages "+target.getName()+" for "+amount.toString()+" damage.")
    UnitDamageTarget(this, target, newAmount, false, true, ATTACK_TYPE_NORMAL, damageType, WEAPON_TYPE_WHOKNOWS)

public function unit.healHP(real amount)
    this.setHP(this.getHP() + amount)

public function unit.healMana(real amount)
    this.setMana(this.getMana() + amount)

public function unit.addMovementSpeedAbsolute(int value)
    this.addMovementSpeedAbsolute(value.toReal())

/*
Do not use getMoveSpeed ( current movement speed)
It is limited by the minimum and maximum movement speed and so it should not be used in calculations here.
Example trying to slow a unit at minimum movement speed will have not effect, but by reverting the slow, it will actually get a move speed bonus.
*/

public function unit.addMovementSpeedAbsolute(real value)
    print("before: "+this.getMoveSpeed().toString()+" "+this.getCurrentMovementSpeed().toString())
    let newMoveSpeed = this.getCurrentMovementSpeed() + value
    this.setMovementSpeed(newMoveSpeed)
    print("after: "+this.getMoveSpeed().toString()+" "+this.getCurrentMovementSpeed().toString())

/**
Changes a units movement speed relative to its default speed.
**/
public function unit.addMovementSpeedRelative(real value) 
    this.addMovementSpeedAbsolute(value * GetUnitDefaultMoveSpeed(this) )

public function unit.dispelMagicalBuffs(boolean positive, boolean negative)
    let buffList = this.getBuffList().getLinkedList()
    for Buff currentBuff in buffList
        let buffType =currentBuff.getBuffType()
        if(buffType.isMagical())
            if(positive and buffType.isPositive()) or (negative and not buffType.isPositive())
                currentBuff.dispel()

public function unit.dispelPhysicallBuffs(boolean positive, boolean negative)
    let buffList = this.getBuffList().getLinkedList()
    for Buff currentBuff in buffList
        let buffType =currentBuff.getBuffType()
        if(not buffType.isMagical())
            if(positive and buffType.isPositive()) or (negative and not buffType.isPositive())
                currentBuff.dispel()


public function unit.dispelBuffs(boolean positive, boolean negative)
    this.dispelMagicalBuffs(positive, negative)
    this.dispelPhysicallBuffs(positive, negative)
