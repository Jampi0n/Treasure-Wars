package OnAttack

import DamageDetection
import HeroType
import General
import AbilityObjEditing
import ObjectIdGenerator
import TimerUtils
import UnitTypeConfig

import ItemIdGeneration
import ItemShopSystem

constant PREVENT_DEATH = compiletime(ABIL_ID_GEN.next())

unit prevenDeathUnit
real prevenDeathAfterLife
timer preventDeathTimer = getTimer()

@compiletime
function setupPreventDeath()
    new AbilityDefinitionMaxLifeBonusGreater(PREVENT_DEATH)
        ..setMaxLifeGained(1, 100000)


function unit.dealDamageNoEvent(unit target, real amount, ReductionType reductionType)
    disableDamageDetect()
    this.dealDamage(target, amount, reductionType)
    enableDamageDetect()

function unitSetAfterLife()
    if prevenDeathUnit == null
        return

    prevenDeathUnit
        ..removeAbility(PREVENT_DEATH)
        ..setHP(prevenDeathAfterLife)

    prevenDeathUnit = null

/*
**
**  This function handles ALL damage event funtions, where the damage amount matters.
**  By having all in this function, the order the functions run can be set the easiest.
**
*/
function handleDamageAmount(boolean isAttack)
    unit source = OnAttack.getAttacker()
    unit target = OnAttack.getTarget()
    let originalDamage = GetEventDamage()
    real currentDamage = originalDamage
    real afterLife

    //===============================================================================


    //example:
    //currentDamage = currentDamage/2


    if isAttack and target.isType(UNIT_TYPE_HERO)
        if target.countItemsOfType(convertItemId(ITEM_ID_SHIELD)) != 0
            currentDamage = currentDamage-6
            print("block")



    //===============================================================================
    if prevenDeathUnit != null
        prevenDeathUnit.removeAbility(PREVENT_DEATH)
        prevenDeathUnit.setHP(prevenDeathAfterLife)
        prevenDeathUnit = null

    if currentDamage < 0
        currentDamage = 0

    if currentDamage > originalDamage
        source.dealDamageNoEvent(target, currentDamage-originalDamage, ReductionType.NONE)
    if currentDamage < originalDamage
        //how much life the target is supposed to have after dealing damage
        let life = target.getHP()
        afterLife = life - currentDamage
        
        //only do stuff, if the unit is supposed to survive
        if life - currentDamage > 0.41
            //if the target would die, even though it is supposed to survive:
            if life - originalDamage < 0.41
                target.setHP(target.getMaxHP())
                target.addAbility(PREVENT_DEATH)

            prevenDeathUnit = target
            prevenDeathAfterLife = afterLife
            preventDeathTimer.start(0, function unitSetAfterLife)




public class OnAttack

    private static unit target
    private static unit attacker
    private static boolean active
    private static trigger onAttackTrigger = CreateTrigger()

    protected static function onDamage()
        //use local variables to avoid overwriting
        //set global variables right before calling other functions
        let localTarget = GetTriggerUnit()
        let localAttacker = GetEventDamageSource()
        var localActive = false
        var localAttacked = false


        if(localTarget.hasAbility('B005')) or localAttacker.getTypeId() == MORTAR_TEAM //passive
            localTarget.removeAbility('B005')
            localAttacked = true
        else if(localTarget.hasAbility('B006')) //arrow
            localTarget.removeAbility('B006')
            localActive = true
            localAttacked = true


        target = localTarget
        attacker = localAttacker
        active = localActive
        handleDamageAmount(localAttacked)
        if(localAttacked)
            target = localTarget
            attacker = localAttacker
            active = localActive
            onAttackTrigger.execute()


    static function getAttacker() returns unit
        return attacker

    static function getTarget() returns unit
        return target   

    static function isActive() returns boolean
        return active

    static function addOnAttackFunc(code onAttack)
        onAttackTrigger.addAction(onAttack)    

    protected static function onAttackAbilities()
        HeroType heroType = HeroType.getHeroType(getAttacker().getTypeId())
        if(heroType!=null)
            heroType.onAttack()


init
    addOnDamageFunc(Condition(function OnAttack.onDamage))

    //use hashmap, so onAttack is more efficient
    //if there are a lot of heroes, if-then-else to find the correct
    //actions to execute is inefficient
    OnAttack.addOnAttackFunc(function OnAttack.onAttackAbilities)