package OnAttack

import DamageDetection
import initlater HeroType
import ClosureTimers
import TimerUtils
import UnitTypeConfig
import LinkedList

import ItemIdGeneration
import initlater ItemShopSystem

constant PREVENT_DEATH = compiletime(ABIL_ID_GEN.next())

unit prevenDeathUnit
real prevenDeathAfterLife
timer preventDeathTimer = getTimer()

@compiletime
function setupPreventDeath()
    new AbilityDefinitionMaxLifeBonusGreater(PREVENT_DEATH)
        ..setMaxLifeGained(1, 100000)


function unit.dealDamageNoEvent(unit target, real amount, ReductionType reductionType)
    disableDamageDetect()
    this.dealDamage(target, amount, reductionType)
    enableDamageDetect()

function unitSetAfterLife()
    if prevenDeathUnit == null
        return

    prevenDeathUnit
        ..removeAbility(PREVENT_DEATH)
        ..setHP(prevenDeathAfterLife)

    prevenDeathUnit = null

/*
**
**  This function handles ALL damage event funtions, where the damage amount matters.
**  By having all in this function, the order the functions run can be set the easiest.
**
*/
function handleDamageAmount(unit source, unit target, boolean isAttack, boolean _isActive)
    let originalDamage = GetEventDamage()
    real currentDamage = originalDamage
    real afterLife

    

    //example:
    //currentDamage = currentDamage/2

    /*
        untargetable -> damage = 0 and no further damage handling
        only for attacks, because every other damage will be dealt in code and there I can decide individually, if I want to deal damage
    */

    if target.isType(UNIT_TYPE_ANCIENT) and isAttack 
        currentDamage = 0
    else

        //===============================================================================

        if isAttack and target.isType(UNIT_TYPE_HERO)
            currentDamage = currentDamage - 8 * target.countItemsOfType(convertItemId(ITEM_ID_SHIELD))


    
        if not isAttack and source.isType(UNIT_TYPE_HERO) and source.hasItemById(convertItemId(ITEM_ID_VAMPIRIC_GOBLET))
            source.addHP(currentDamage * 0.1)
            source.addMana(currentDamage * 0.05)
            source.addEffect(Abilities.spiritTouchTarget, "origin").destr()
            source.addEffect(Abilities.vampiricAuraTarget, "origin").destr()
    
        if source.isType(UNIT_TYPE_HERO) and target.hasItemById(convertItemId(ITEM_ID_VOID_ARMOR))
            target.addMana(currentDamage * 0.05)
            currentDamage *= 0.95

        //===============================================================================



    
    if prevenDeathUnit != null
        prevenDeathUnit.removeAbility(PREVENT_DEATH)
        prevenDeathUnit.setHP(prevenDeathAfterLife)
        prevenDeathUnit = null

    if currentDamage < 0
        currentDamage = 0

    if currentDamage > originalDamage
        source.dealDamageNoEvent(target, currentDamage-originalDamage, ReductionType.NONE)
    if currentDamage < originalDamage
        //how much life the target is supposed to have after dealing damage
        let life = target.getHP()
        afterLife = life - currentDamage
        
        //only do stuff, if the unit is supposed to survive
        if life - currentDamage > 0.41
            //if the target would die, even though it is supposed to survive:
            if life - originalDamage < 0.41
                target.setHP(target.getMaxHP())
                target.addAbility(PREVENT_DEATH)

            prevenDeathUnit = target
            prevenDeathAfterLife = afterLife
            preventDeathTimer.start(0, function unitSetAfterLife)


public interface OnAttackFunction
    function onAttack(unit attacker, unit target, boolean isActive)

public class OnAttack

    private static unit target
    private static unit attacker
    private static boolean active
    private static trigger onAttackTrigger = CreateTrigger()
    private static constant onAttackFunctionList = new LinkedList<OnAttackFunction>()

    protected static int countEvents = 0

    protected static function onDamage()
        //use local variables to avoid overwriting
        //set global variables right before calling other functions
        let localTarget = GetTriggerUnit()
        let localAttacker = GetEventDamageSource()
        var localActive = false
        var localAttacked = false


        countEvents++
        if countEvents > 100
            print("Warning. Very high number of damage events: "+countEvents.toString())

        if(localTarget.hasAbility('B005')) or localAttacker.getTypeId() == MORTAR_TEAM //passive
            localTarget.removeAbility('B005')
            localAttacked = true
        else if(localTarget.hasAbility('B006')) //arrow
            localTarget.removeAbility('B006')
            localActive = true
            localAttacked = true


        target = localTarget
        attacker = localAttacker
        active = localActive
        handleDamageAmount(localAttacker, localTarget, localAttacked, localActive)

        //use a list with arguments, as a onAttack function could trigger an onAttack event and overwrite the variables
        if localAttacked and not localTarget.isType(UNIT_TYPE_ANCIENT) //untargetable
            for OnAttackFunction onAttack in onAttackFunctionList
                onAttack.onAttack(localAttacker, localTarget, localActive)


    /*static function getAttacker() returns unit
        return attacker

    static function getTarget() returns unit
        return target   

    static function isActive() returns boolean
        return active*/

    static function addOnAttackFunc(OnAttackFunction onAttack)
        onAttackFunctionList.add(onAttack)

    protected static function onAttackAbilities(unit attacker, unit target, boolean isActive)
        HeroType heroType = HeroType.getHeroType(attacker.getTypeId())
        if(heroType!=null)
            heroType.onAttack(attacker, target, isActive)


init
    addOnDamageFunc(Condition(function OnAttack.onDamage))

    //use hashmap, so onAttack is more efficient
    //if there are a lot of heroes, if-then-else to find the correct
    //actions to execute is inefficient
    OnAttack.addOnAttackFunc((unit attacker, unit target, boolean isActive) -> OnAttack.onAttackAbilities(attacker, target, isActive))

    doPeriodically(0.1, (CallbackPeriodic _cb) -> (begin
        OnAttack.countEvents = 0
    end))