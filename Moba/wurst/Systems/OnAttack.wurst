package OnAttack

import DamageDetection
import initlater HeroType
import ClosureTimers
//import TimerUtils
import UnitTypeConfig
import initlater SeaDruid
import initlater TrollBerserker
import StandardTextTags

import ItemIdGeneration
import initlater ItemShopSystem

public constant ADVANCED_ONHIT =  'A00I'
public constant DEFAULT_ONHIT = 'A008'
/*
    ADVANCED_ONHIT can temporarily replace the default on hit abiltiy to get a temporary special attack, that depends
    on the time when the attack is fired and not when it is hit (so only relevant for ranged attacks)
    ADVANCED_ONHIT will trigger all effects DEFAULT_ONHIT triggers, but can be used to trigger additional effects
    Every hero should only have one ability utilizing ADVANCED_ONHIT (more abilities would be repetitive anyways)
*/


constant PREVENT_DEATH = compiletime(ABIL_ID_GEN.next())

/*unit prevenDeathUnit
real prevenDeathAfterLife
timer preventDeathTimer = getTimer()*/

@compiletime
function setupPreventDeath()
    new AbilityDefinitionMaxLifeBonusGreater(PREVENT_DEATH)
        ..setMaxLifeGained(1, 100000)


function unit.dealDamageNoEvent(unit target, real amount, ReductionType reductionType)
    disableDamageDetect()
    this.dealDamage(target, amount, reductionType)
    enableDamageDetect()

/*function unitSetAfterLife()
    if prevenDeathUnit != null
        prevenDeathUnit.removeAbility(PREVENT_DEATH)
        prevenDeathUnit.setHP(prevenDeathAfterLife)
        print("now set hp of "+prevenDeathUnit.getName()+" to "+prevenDeathAfterLife.toString())
        prevenDeathUnit = null*/

/*
**
**  This function handles ALL damage event funtions, where the damage amount matters.
**  By having all in this function, the order the functions run can be set the easiest.
**
*/
function handleDamageAmount(unit source, unit target, boolean isAttack, boolean _isActive, boolean advanced)
    let originalDamage = GetEventDamage()
    real currentDamage = originalDamage
    real afterLife

    if originalDamage.abs() < 0.000001 //damage very small, just ignore
        return

    //if source.isType(UNIT_TYPE_HERO) or target.isType(UNIT_TYPE_HERO)
        //print(source.getName()+" damages "+target.getName()+": "+currentDamage.toString()+" "+isAttack.toString())

    // if damage events are at the same time e.g spikes, this will cause problems
    // always use delayed unitSetAfterLife()
    /*if prevenDeathUnit != null
        print("- - -")
        unitSetAfterLife()
        print("+ + +")*/

    //example:
    //currentDamage = currentDamage/2

    /*
        untargetable -> damage = 0 and no further damage handling
        only for attacks, because every other damage will be dealt in code and there I can decide individually, if I want to deal damage
    */

    if target.isType(UNIT_TYPE_ANCIENT) and isAttack 
        currentDamage = 0
    else

        //===============================================================================


        // critical strike - TROLL BERSERKER
        if advanced and source.isType(UNIT_TYPE_HERO) and BuffList.hasBuffType(source, buffCriticalStrike) and not target.isType(UNIT_TYPE_STRUCTURE)
            let critical = BuffList.getBuffOfType(source, buffCriticalStrike)
            currentDamage = currentDamage * (100 + CRITICAL_DAMAGE_MULT[critical.getLevel()-1])/100
            createCriticalStrikeTextTag(target, currentDamage.toInt())
            critical.dispel()


        // shield - ITEM
        if isAttack and target.isType(UNIT_TYPE_HERO)
            currentDamage = currentDamage - 8 * target.countItemsOfType(convertItemId(ITEM_ID_SHIELD))

        // mana shield - SEA DRUID
        if target.isType(UNIT_TYPE_HERO) and BuffList.hasBuffType(target, buffManaShield)
            
            let manaShield = BuffList.getBuffOfType(target, buffManaShield)
            let level = manaShield.getLevel()

            
            manaShield.getTarget().addMana( - MANA_SHIELD_REDUCTION[level-1] * MANA_PER_DAMAGE[level-1] * currentDamage)
            currentDamage = currentDamage * (1.-MANA_SHIELD_REDUCTION[level-1])
    
        // vampiric goblet - ITEM
        if not isAttack and source.isType(UNIT_TYPE_HERO) and source.hasItemById(convertItemId(ITEM_ID_VAMPIRIC_GOBLET)) and target.isType(UNIT_TYPE_HERO)
            source.addHP(currentDamage * 0.3)
            source.addMana(currentDamage * 0.15)

        // wand of blood - ITEM
        if source.isType(UNIT_TYPE_HERO) and source.hasItemById(convertItemId(ITEM_ID_WAND_OF_BLOOD)) and not target.isType(UNIT_TYPE_STRUCTURE)
            source.addHP(currentDamage * 0.1)

        // sacrifical dagger - ITEM
        if isAttack and source.isType(UNIT_TYPE_HERO) and source.hasItemById(convertItemId(ITEM_ID_SACRIFICIAL_DAGGER)) and not target.isType(UNIT_TYPE_STRUCTURE)
            source.addHP(currentDamage * 0.15)

        // void armor - ITEM
        if target.isType(UNIT_TYPE_HERO) and target.hasItemById(convertItemId(ITEM_ID_VOID_ARMOR))
            target.addMana(currentDamage * 0.05)
            currentDamage *= 0.95

        // wand of death - ITEM
        if source.isType(UNIT_TYPE_HERO) and source.hasItemById(convertItemId(ITEM_ID_WAND_OF_DEATH)) and target.isType(UNIT_TYPE_HERO)
            let wp = currentDamage * 0.02
            let wrapper = target.wrapper()
            wrapper.addStatAbsoluteBonusReal(Stat.AGI, (-wp*1000).toInt())
            doAfter(10, () -> wrapper.addStatAbsoluteBonusReal(Stat.AGI, (wp*1000).toInt() ) )


        //===============================================================================



    if currentDamage > originalDamage
        source.dealDamageNoEvent(target, currentDamage-originalDamage, ReductionType.NONE)
    else if currentDamage < originalDamage
        if currentDamage < 0
            currentDamage = 0
        //how much life the target is supposed to have after dealing damage


        let life = target.getHP()


        afterLife = life - currentDamage
        
        //only do stuff, if the unit is supposed to survive
        if life - currentDamage > 0.41
            //if the target would die, even though it is supposed to survive:
            if life - originalDamage < 0.41
                target.setHP(target.getMaxHP())
                target.addAbility(PREVENT_DEATH)

            
            doAfter(0, () -> (begin
                target
                    ..removeAbility(PREVENT_DEATH)
                    ..setHP(afterLife)
            end))


public interface OnAttackFunction
    function onAttack(unit attacker, unit target, boolean isActive)

public interface OnAttackFunctionAdvanced
    function onAttack(unit attacker, unit target, boolean isActive, boolean advanced)


public class OnAttack

    private static unit target
    private static unit attacker
    private static boolean active
    private static trigger onAttackTrigger = CreateTrigger()
    private static constant onAttackFunctionList = new LinkedList<OnAttackFunction>()
    private static constant onAttackFunctionListAdvanced = new LinkedList<OnAttackFunctionAdvanced>()

    protected static int countEvents = 0

    protected static function onDamage()
        //use local variables to avoid overwriting
        //set global variables right before calling other functions
        let localTarget = GetTriggerUnit()
        let localAttacker = GetEventDamageSource()
        var localActive = false
        var localAttacked = false
        var advanced = false

        countEvents++
        if countEvents > 100
            print("Warning. Very high number of damage events: "+countEvents.toString())

        if(localTarget.hasAbility('B005')) or localAttacker.getTypeId() == MORTAR_TEAM //passive
            localTarget.removeAbility('B005')
            localAttacked = true
        if(localTarget.hasAbility('B00G')) //advanced
            localTarget.removeAbility('B00G')
            localAttacked = true
            advanced = true

        else if(localTarget.hasAbility('B006')) //arrow
            localTarget.removeAbility('B006')
            localActive = true
            localAttacked = true


        target = localTarget
        attacker = localAttacker
        active = localActive
        handleDamageAmount(localAttacker, localTarget, localAttacked, localActive, advanced)

        //use a list with arguments, as a onAttack function could trigger an onAttack event and overwrite the variables
        if localAttacked and not localTarget.isType(UNIT_TYPE_ANCIENT) //untargetable
            for OnAttackFunction onAttack in onAttackFunctionList
                onAttack.onAttack(localAttacker, localTarget, localActive)

            for OnAttackFunctionAdvanced onAttack in onAttackFunctionListAdvanced
                onAttack.onAttack(localAttacker, localTarget, localActive, advanced)

        


    /*static function getAttacker() returns unit
        return attacker

    static function getTarget() returns unit
        return target   

    static function isActive() returns boolean
        return active*/

    static function addOnAttackFunc(OnAttackFunction onAttack)
        onAttackFunctionList.add(onAttack)

    static function addOnAttackFuncAdvanced(OnAttackFunctionAdvanced onAttack)
        onAttackFunctionListAdvanced.add(onAttack)

    protected static function onAttackAbilities(unit attacker, unit target, boolean isActive, boolean advanced)
        HeroType heroType = HeroType.getHeroType(attacker.getTypeId())
        if(heroType!=null)
            heroType.onAttack(attacker, target, isActive, advanced)

    static function useAdvanced(unit whichUnit, boolean advanced)
        if advanced
            whichUnit
                ..removeAbility(DEFAULT_ONHIT)
                ..addAbility(ADVANCED_ONHIT)
        else
            whichUnit
                ..removeAbility(ADVANCED_ONHIT)
                ..addAbility(DEFAULT_ONHIT)


init
    addOnDamageFunc(Condition(function OnAttack.onDamage))

    //use hashmap, so onAttack is more efficient
    //if there are a lot of heroes, if-then-else to find the correct
    //actions to execute is inefficient
    OnAttack.addOnAttackFuncAdvanced((unit attacker, unit target, boolean isActive, boolean advanced) -> OnAttack.onAttackAbilities(attacker, target, isActive, advanced))

    doPeriodically(0.1, (CallbackPeriodic _cb) -> (begin
        OnAttack.countEvents = 0
    end))