package UnitWrapper

import UnitIndexer
import HashMap
import initlater Buff
import initlater General
import UnitType
import Upgrades
import initlater HeroControl
import LinkedList

import BonusMod

public interface CalculateTotalBonus
    function calculate(UnitWrapper whichWrapper, Stat whichStat)

/**
    Every unit gets a unit wrapper

    Contains functionality every unit needs in one place, so only one HashMap is needed.
**/
public class UnitWrapper

    constant static CalculateTotalBonus defaultCalcualtion = (UnitWrapper whichWrapper, Stat whichStat) -> (begin
        int stat = whichStat.toInt()
        whichWrapper.statsTotalBonus[stat] = ((whichWrapper.getStatAbsoluteBonus(whichStat)) * (1. + whichWrapper.getStatRelativeBonus(whichStat)/1000 ) + (whichWrapper.getStatBaseValue(whichStat) * whichWrapper.getStatRelativeBonus(whichStat)/1000) ).round()
    end)

    private CalculateTotalBonus bonusCalculation = defaultCalcualtion

    protected static unit array allUnits
    protected static int unitWrapperCount = 0

    protected int index

    private static constant unitMap = new HashMap<unit, UnitWrapper>()
    private unit assocUnit

    protected real currentMovementSpeed
    protected real defaultMovementSpeed

    private int array[11] statBaseValue
    //has no effect, is just needed to determine the actual bonus for relative bonus

    private int array[11] statsAbsoluteBonus //default = 0
    private int array[11] statsRelativeBonus //default = 0.00
    /*
        Use integer to avoid rounding errors. 1000 means 100% or 1
    */
    int array[11] statsTotalBonus //default = 0

    private static constant unnkownUnitTypes = new LinkedList<int>()

    protected BuffList buffList

    construct(unit assocUnit)

        this.assocUnit = assocUnit

        allUnits[unitWrapperCount] = this.assocUnit
        this.index = unitWrapperCount
        unitWrapperCount++


        unitMap.put(assocUnit, this)

        this.currentMovementSpeed = assocUnit.getMoveSpeed()
        this.defaultMovementSpeed = GetUnitDefaultMoveSpeed(this.assocUnit)

        this.buffList = new BuffList

        for int i = 0 to 10
            statsAbsoluteBonus[i] = 0
            statsRelativeBonus[i] = 0
            statsTotalBonus[i] = 0

        //Base values should never change for units and only change for heroes on level up.

        statBaseValue[Stat.STR.toInt()] = this.assocUnit.getStr(false)
        statBaseValue[Stat.AGI.toInt()] = this.assocUnit.getAgi(false)
        statBaseValue[Stat.INT.toInt()] = this.assocUnit.getInt(false)

        let uType = UnitType.getUnitType(this.assocUnit.getTypeId())

        if uType != null
            statBaseValue[Stat.AD.toInt()] = uType.getBaseAttack()
            statBaseValue[Stat.AR.toInt()] = uType.getBaseArmor()
        else if this.assocUnit.isType(UNIT_TYPE_HERO)
            statBaseValue[Stat.AD.toInt()] = 17 + statBaseValue[Stat.STR.toInt()]
            statBaseValue[Stat.AR.toInt()] = 0
        else
            if not this.assocUnit.isType(UNIT_TYPE_STRUCTURE)
                if this.assocUnit.getAbilityLevel('Aloc') == 0
                    if not unnkownUnitTypes.contains(this.assocUnit.getTypeId())
                        unnkownUnitTypes.add(this.assocUnit.getTypeId())
                        print("Warning unnkown unit type: "+GetUnitName(this.assocUnit))
            statBaseValue[Stat.AD.toInt()] = 0
            statBaseValue[Stat.AR.toInt()] = 0

        statBaseValue[Stat.AS.toInt()] = 0 //not needed as this is always a relative bonus
        
        statBaseValue[Stat.HP.toInt()] = this.assocUnit.getMaxHP().toInt()
        statBaseValue[Stat.HR.toInt()] = 0
        
        statBaseValue[Stat.MP.toInt()] = this.assocUnit.getMaxMana().toInt()
        statBaseValue[Stat.MR.toInt()] = 0
        statBaseValue[Stat.MS.toInt()] = this.defaultMovementSpeed.toInt()
    
    function updateBaseStats()
        if not this.assocUnit.isType(UNIT_TYPE_HERO)
            print("Base stats for non-hero units are constant and must not be updated.")
        statBaseValue[Stat.STR.toInt()] = this.assocUnit.getStr(false)
        statBaseValue[Stat.AGI.toInt()] = this.assocUnit.getAgi(false)
        statBaseValue[Stat.INT.toInt()] = this.assocUnit.getInt(false)

        statBaseValue[Stat.AD.toInt()] = 17 + statBaseValue[Stat.STR.toInt()] + GetPlayerTechCount(this.assocUnit.getOwner(), UPG_AD, true)
        statBaseValue[Stat.AR.toInt()] = GetPlayerTechCount(this.assocUnit.getOwner(), UPG_AR, true)
        statBaseValue[Stat.AS.toInt()] = 0
        
        statBaseValue[Stat.HP.toInt()] = 400 + GetPlayerTechCount(this.assocUnit.getOwner(), UPG_HP, true) * 25
        statBaseValue[Stat.HR.toInt()] = 0
        
        statBaseValue[Stat.MP.toInt()] = 100 + GetPlayerTechCount(this.assocUnit.getOwner(), UPG_MP, true) * 10
        statBaseValue[Stat.MR.toInt()] = 0
        statBaseValue[Stat.MS.toInt()] = this.defaultMovementSpeed.toInt()

    protected static function getWrapper(unit whichUnit) returns UnitWrapper
        return unitMap.get(whichUnit)

    //custom destroy function, so unit wrapper is destroyed last and can be used in the clean up routines
    protected function destr()

        

        //the dispel function must be executed before the unit wrapper is destroyed
        for Buff b in this.buffList.getLinkedList()
            b.dispel()

        destroy this.buffList

        //remove unit wrapper
        unitWrapperCount--
        allUnits[this.index] = allUnits[unitWrapperCount]
        unitMap.remove(this.assocUnit)
        destroy this




    function setBonusCalculation(CalculateTotalBonus bonusCalculation)
        this.bonusCalculation = bonusCalculation

    /**
    Updates the total stat bonus based on base stat, absolute stat bonus and relative stat bonus
    **/
    function updateTotalStatBonus(Stat whichStat)
        this.bonusCalculation.calculate(this, whichStat)
        this.applyTotalStatBonus(whichStat)
        

    function applyTotalStatBonus(Stat whichStat)
        if whichStat != Stat.MS and whichStat != Stat.HR and whichStat!= Stat.MR
            this.toUnit().setBonus(whichStat, this.statsTotalBonus[whichStat.toInt()])
        else
            if whichStat == Stat.MS
                this.toUnit().setMovementSpeed( this.getStatBaseValue(whichStat) + this.statsTotalBonus[whichStat.toInt()].toReal() )

    /**
    Sets the absolute stat bonus and updates the total bonus.
    **/
    function setStatAbsoluteBonus(Stat whichStat, int newValue)
        int stat = whichStat.toInt()
        this.statsAbsoluteBonus[stat] = newValue
        updateTotalStatBonus(whichStat)


    /**
    Sets the relative stat bonus and updates the total bonus.
    **/
    function setStatRelativeBonus(Stat whichStat, int newValue)
        int stat = whichStat.toInt()
        this.statsRelativeBonus[stat] = newValue
        updateTotalStatBonus(whichStat)

    function addStatAbsoluteBonus(Stat whichStat, int plusValue)
        this.setStatAbsoluteBonus(whichStat, this.statsAbsoluteBonus[whichStat.toInt()] + plusValue)

    function addStatRelativeBonus(Stat whichStat, int plusValue)
        this.setStatRelativeBonus(whichStat, this.statsRelativeBonus[whichStat.toInt()] + plusValue)

    function printStats()
        for i = 0 to 10
            printStat(i castTo Stat)

    function printStat(Stat whichStat)
        int stat = whichStat.toInt()
        print(whichStat.toString()+" ( "+statBaseValue[stat].toString()+" + "+statsAbsoluteBonus[stat].toString()+" ) * "+statsRelativeBonus[stat].toString() + "->" +statsTotalBonus[stat].toString() )

    function toUnit() returns unit
        return this.assocUnit

    function getStatAbsoluteBonus(Stat whichStat) returns int
        return this.statsAbsoluteBonus[whichStat.toInt()]

    function getStatRelativeBonus(Stat whichStat) returns int
        return this.statsRelativeBonus[whichStat.toInt()]
    
    function getStatBaseValue(Stat whichStat) returns int
        return this.statBaseValue[whichStat.toInt()]

public function unit.wrapper() returns UnitWrapper
    return UnitWrapper.getWrapper(this)

public function unit.getCurrentMovementSpeed() returns real
    return this.wrapper().currentMovementSpeed

public function unit.getDefaultMovementSpeed() returns real
    return this.wrapper().defaultMovementSpeed

public function unit.updateDefaultMovementSpeed()
    if this.isType(UNIT_TYPE_HERO)
        this.wrapper().defaultMovementSpeed = GetUnitDefaultMoveSpeed(this) + GetPlayerTechCount(this.getOwner(), UPG_MS, true) 
        //print(GetUnitDefaultMoveSpeed(this) + GetPlayerTechCount(this.getOwner(), UPG_MS, true))

public function unit.setMovementSpeed(real newSpeed)
    this.wrapper().currentMovementSpeed = newSpeed
    //print("set ms to "+newSpeed.toString())
    this.setMoveSpeed(newSpeed)



public function unit.getBuffList() returns BuffList
    return this.wrapper().buffList

function regenerate()
    for i = 0 to UnitWrapper.unitWrapperCount-1
        unit u = UnitWrapper.allUnits[i]
        
        if u.isAlive()
            u.healHP(u.wrapper().statsTotalBonus[Stat.HR.toInt()]/100)
            
            u.healMana(u.wrapper().statsTotalBonus[Stat.MR.toInt()]/100)

            if(u.isType(UNIT_TYPE_HERO)) and false
                print(u.wrapper().statsTotalBonus[Stat.HR.toInt()]/100)
                print(u.wrapper().statsTotalBonus[Stat.MR.toInt()]/100)

init
    onUnitIndex(() -> new UnitWrapper(getIndexedUnit()))
    onUnitDeindex(() -> getDeindexedUnit().wrapper().destr() )

    CreateTrigger()
        ..addAction(function regenerate)
        ..registerTimerEvent(0.1, true)

    CreateTrigger()
        ..registerPlayerChatEvent(players[0], "-s", true)
        ..addAction(() -> (begin
            Hero.getHero(players[0]).toUnit().wrapper().printStats()
        end))