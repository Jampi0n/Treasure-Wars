package ItemShopSystem

import ClosureTimers
import ItemShopFinalize
import HashMap
import LinkedList
import ItemShopRequirements
import Stats
import UnitWrapper
import Constants

//This package is imported ny other item packages, but they use initlater to avoid cyclic requirements. So the initialization of this
//package is manually called by other packages and not by using init, because init is after all other item packages.
//Init only contains functions that can be executed later.


/*  ==========================================================================================================================
**
**  runtime
**
**  ==========================================================================================================================*/

/*  ==========================================================================================================================
**
**  globals
**
**  ==========================================================================================================================*/

Item array itemType 

/*  ==========================================================================================================================
**
**  Creates the runtime item objects based on the compiletime values.
**
**  ==========================================================================================================================*/


public function setupItems()
    for i = 0 to MAX_ITEM_ID
        if itemIsRecipe[i]
            itemType[i] = new Recipe(itemIdArray[i], itemGoldCost[i], itemRequiredItems[i], itemType[i-1])
        else
            itemType[i] = new Item(itemIdArray[i], itemGoldCost[i])

interface ItemPickUp
    function onItemPickUp()

interface ItemDrop
    function onItemDrop()

item triggerItem
unit triggerHero
        
public function getTriggerItem() returns item
    return triggerItem

public function getTriggerHero() returns unit
    return triggerHero

public function unit.countItemsOfType(int itemTypeId) returns int
    item indexItem
    int count = 0

    for i = 0 to bj_MAX_INVENTORY-1
        indexItem = UnitItemInSlot(this, i)
        if (indexItem != null) and (indexItem.getTypeId() == itemTypeId)
            count++

    return count

//returns if the picked up item is the first of its type and if the dropped item is the last of its type
public function isUnique() returns boolean
    return getTriggerHero().countItemsOfType(getTriggerItem().getTypeId()) == 1

//returns if the the hero has not this item
public function hasNot(int itemTypeId) returns boolean
    return getTriggerHero().countItemsOfType(itemTypeId) == 0

/*combined usage:
pick up boots 1
isUnique() and hasNot(boots 2)
onPickup: the hero has not boots 2 and picked up his first boots 1 => add unique boots bonus
onDrop: the hero has not boots 2 and dropped his last boots 1 => remove unique boots bonus

*/

public function convertItemId(int itemId) returns int
    return itemIdArray[itemId]

public function int.getItem() returns Item
    return Item.itemMap.get(itemIdArray[this])

public class Item
    protected constant int itemTypeId
    protected constant int gold

    protected static HashMap<int, Item> itemMap
    private static trigger onItemPickUp = CreateTrigger()
    private static trigger onItemDrop = CreateTrigger()
    private constant onPickUp = new LinkedList<ItemPickUp>
    private constant onDrop = new LinkedList<ItemDrop>

    construct(int itemTypeId, int gold)
        objectCount++
        this.itemTypeId = itemTypeId
        this.gold = gold
        if itemMap == null
            print("still null")
        else
            itemMap.put(itemTypeId, this)

    static function classInit() //class must be initialized, before the package (before items are set up in Finalize)
        itemMap = new HashMap<int, Item>()
        onItemPickUp = CreateTrigger()
            ..addAction(function onItemPickUp)
            ..registerAnyUnitEvent(EVENT_PLAYER_UNIT_PICKUP_ITEM)
        onItemDrop = CreateTrigger()
            ..addAction(function onItemDrop)
            ..registerAnyUnitEvent(EVENT_PLAYER_UNIT_DROP_ITEM)

    static function onItemPickUp()
        triggerItem = GetManipulatedItem()
        triggerHero = GetTriggerUnit()
        let itemType = itemMap.get(triggerItem.getTypeId())
        if itemType != null
            for c in itemType.onPickUp
                c.onItemPickUp()

    static function onItemDrop()
        triggerItem = GetManipulatedItem()
        triggerHero = GetTriggerUnit()
        let itemType = itemMap.get(triggerItem.getTypeId())
        if itemType != null
            for c in itemType.onDrop
                c.onItemDrop()

    function addPickupFunction(ItemPickUp onPickUp)
        this.onPickUp.add(onPickUp)

    function addDropFunction(ItemDrop onDrop)
        this.onDrop.add(onDrop)

    function addStatBonusAbsolute(Stat whichStat, int bonus)
        addPickupFunction( ()-> (begin
            getTriggerHero().wrapper().addStatAbsoluteBonus(whichStat, bonus)
        end))

        addDropFunction( ()-> (begin
            getTriggerHero().wrapper().addStatAbsoluteBonus(whichStat, -bonus)
        end))

    function addStatBonusRelative(Stat whichStat, int bonus)
        addPickupFunction( ()-> (begin
            getTriggerHero().wrapper().addStatRelativeBonus(whichStat, bonus)
        end))

        addDropFunction( ()-> (begin
            getTriggerHero().wrapper().addStatRelativeBonus(whichStat, -bonus)
        end))

    function getTypeId() returns int
        return this.itemTypeId


    


public class Recipe extends Item

    protected LinkedList<int> requiredItems
    
    protected constant Item resultItem

    construct(int itemTypeId, int gold, string requiredItems, Item resultItem)
        super(itemTypeId, gold)
        this.requiredItems = stringToList(requiredItems, ",")
        this.resultItem = resultItem

    private static function onItemGet(unit hero, item whichItem)
        let itemTypeId = whichItem.getTypeId()
        let itm = itemMap.get(itemTypeId)
      

        if not (itm instanceof Recipe)
            return


        let recipe = itm castTo Recipe

        let owner = hero.getOwner()
        var missingItems = ""
        var hasAll = true
        if recipe != null
            for int req in recipe.requiredItems
                if not UnitHasItemOfTypeBJ(hero, itemType[req].itemTypeId)
                    hasAll = false
                    if(missingItems!="")
                        missingItems += ", "
                    missingItems += GetObjectName(itemType[req].itemTypeId)
                  

        hero.removeItem(whichItem)
        whichItem.remove()
        if hasAll
            
            for int req in recipe.requiredItems
                GetItemOfTypeFromUnitBJ(hero, itemType[req].itemTypeId).remove()
            hero.addItem(recipe.resultItem.itemTypeId)
        else
            owner.addGold(recipe.gold)
            printTimedToPlayer("You are missing: "+missingItems, 5, owner)
            printTimedToPlayer("Item price refunded.", 5, owner)

    
    protected static function onItemGetTrigger()
        let hero = GetTriggerUnit()
        let whichItem = GetManipulatedItem()
        doAfter(0, () -> onItemGet(hero, whichItem))


init
    CreateTrigger()
        ..registerAnyUnitEvent(EVENT_PLAYER_UNIT_PICKUP_ITEM)
        ..addAction(function Recipe.onItemGetTrigger)

    /*doAfter(1, () -> print("gold cost = "+itemGoldCost[ITEM_ID_HELMET].toString()))
    doAfter(1, () -> print("id = "+itemId[ITEM_ID_HELMET].toString()))
    doAfter(1, () -> print("recipe = "+itemIsRecipe[ITEM_ID_HELMET].toString()))
    doAfter(1, () -> print("required = "+itemRequiredItems[ITEM_ID_HELMET]))

    doAfter(1, () -> print("gold cost = "+itemGoldCost[ITEM_ID_HELMET+1].toString()))
    doAfter(1, () -> print("id = "+itemId[ITEM_ID_HELMET+1].toString()))
    doAfter(1, () -> print("recipe = "+itemIsRecipe[ITEM_ID_HELMET+1].toString()))
    doAfter(1, () -> print("required = "+itemRequiredItems[ITEM_ID_HELMET+1]))*/
/*
    doAfter(1, () -> print("gold cost = "+itemGoldCost[ITEM_ID_SPIKED_MAIL].toString()))
    doAfter(1, () -> print("id = "+itemIdArray[ITEM_ID_SPIKED_MAIL].toString()))
    doAfter(1, () -> print("recipe = "+itemIsRecipe[ITEM_ID_SPIKED_MAIL].toString()))
    doAfter(1, () -> print("required = "+itemRequiredItems[ITEM_ID_SPIKED_MAIL]))

    doAfter(1, () -> print("gold cost = "+itemGoldCost[ITEM_ID_SPIKED_MAIL+1].toString()))
    doAfter(1, () -> print("id = "+itemIdArray[ITEM_ID_SPIKED_MAIL+1].toString()))
    doAfter(1, () -> print("recipe = "+itemIsRecipe[ITEM_ID_SPIKED_MAIL+1].toString()))
    doAfter(1, () -> print("required = "+itemRequiredItems[ITEM_ID_SPIKED_MAIL+1]))*/