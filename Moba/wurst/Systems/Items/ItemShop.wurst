package ItemShop

import LinkedList
import HashMap
import ClosureTimers
import ObjectIdGenerator
import ItemObjEditing
import ObjectIds
import AbilityObjEditing

/*  ==========================================================================================================================
**
**  compiletime & runtime globals
**
**  ==========================================================================================================================*/

string array itemRequiredItems //needed at runtime needs two seperators
int array itemGoldCost //needed at runtime 3-4 + 1 seperator
int array itemId //needed at runtime: 4 (no seperator needed)
boolean array itemIsRecipe //needed at runtime 1

/*  ==========================================================================================================================
**
**  compiletime
**
**  ==========================================================================================================================*/

/*  ==========================================================================================================================
**
**  globals
**
**  ==========================================================================================================================*/

int currentItemId = -1
ItemDefinition array itemDefinition
string array itemName
string array itemShopDescription
int array itemPosX
int array itemPosY

string array itemDesc

/*  ==========================================================================================================================
**
**  Item Object Generation
**
**  public function newItem(string name, int goldCost, BuildingDefinition shop, int x, int y, string requiredItems, string icon, string desc) returns int
**
**  the return value is a custom id that ranges from 0 to n
**
**  requiredItems is a string of this format: id,id,id
**  the ids need to be casted to strings
**
**  ==========================================================================================================================*/

constant shopList = new LinkedList<Shop>()

public constant SHOP_ID_PHYSICAL_1= UNIT_ID_GEN.next()
public constant SHOP_PHYSICAL_1 = compiletime(new Shop(SHOP_ID_PHYSICAL_1, "SHOP 1", 1.2,  "units\\human\\HeroPaladin\\HeroPaladin") castTo int)

public constant ITEM_ID_PLATED_GAUNTLETS = compiletime(newItem("Plated Gauntlets", 500, SHOP_PHYSICAL_1, "", "BTNPlatedGauntlet2"))
@compiletime
function itemPlatedGauntlets()
    let armor = 10
    itemDesc[ITEM_ID_PLATED_GAUNTLETS] = "+{0} armor".format(armor.toString())

public constant SHOP_ID_PHYSICAL_2= UNIT_ID_GEN.next()
public constant SHOP_PHYSICAL_2 = compiletime(new Shop(SHOP_ID_PHYSICAL_2, "SHOP 2", 1.4,  "units\\human\\HeroMountainKing\\HeroMountainKing") castTo int)

public constant ITEM_ID_HAMMER_OF_STRENGTH = compiletime(newItem("Hammer of Strength", 300, SHOP_PHYSICAL_2, "", "BTNINV_Hammer_15"))
@compiletime
function itemHammerOfStrength()
    let str = 10
    itemDesc[ITEM_ID_HAMMER_OF_STRENGTH] = "+{0} strength".format(str.toString())


public constant ITEM_ID_GLOVES_OF_HASTE = compiletime(newItem("Gloves of Haste", 450, SHOP_PHYSICAL_2, "", "BTNLeatherGloves"))
@compiletime
function itemGlovesOfHaste()
    let as = 20
    itemDesc[ITEM_ID_GLOVES_OF_HASTE] = "+{0}% attack speed".format(as.toString())

public constant SHOP_ID_PHYSICAL_3= UNIT_ID_GEN.next()
public constant SHOP_PHYSICAL_3 = compiletime(new Shop(SHOP_ID_PHYSICAL_3, "SHOP 3", 1.2, "units\\human\\ArthaswithSword\\ArthaswithSword") castTo int)

public constant ITEM_ID_BLOOD_SWORD = compiletime(newItem("Blood Sword", 4200, SHOP_PHYSICAL_3, ITEM_ID_HAMMER_OF_STRENGTH.toString()+","+ITEM_ID_GLOVES_OF_HASTE.toString(), "BTNBarbarianBrutalSlasher"))
@compiletime
function itemBloodSword()
    let str = 50
    let as = 40
    itemDesc[ITEM_ID_BLOOD_SWORD] = "+{0} strength|n+{1}% attack speed".format(str.toString(), as.toString())

public constant ITEM_ID_FIREHAND_GAUNTLETS = compiletime(newItem("Firehand Gauntlets", 3000, SHOP_PHYSICAL_3, "", "BTNPlateGauntlet"))
@compiletime
function itemFirehandGauntlets()
    let str = 20
    let armor = 40
    let hp = 300
    itemDesc[ITEM_ID_FIREHAND_GAUNTLETS] = "+{0} strength|n+{1} armor|n+{2} hit points".format(str.toString(), armor.toString(), hp.toString())

public constant ITEM_ID_SPIKED_ARMOR = compiletime(newItem("Spiked Armor", 2700, SHOP_PHYSICAL_3, "", "BTNSpikedArmor"))
@compiletime
function itemSpikedArmor()
    let armor = 90
    itemDesc[ITEM_ID_SPIKED_ARMOR] = "+{0} armor".format(armor.toString())

public constant SHOP_ID_MAGICAL_1= UNIT_ID_GEN.next()
public constant SHOP_MAGICAL_1 = compiletime(new Shop(SHOP_ID_MAGICAL_1, "SHOP 4", 1.1, "units\\human\\HeroArchMage\\HeroArchMage") castTo int)

public constant ITEM_ID_MAGE_AMULET = compiletime(newItem("Mage Amulet", 400, SHOP_MAGICAL_1, "", "BTNEmptyAmulet"))
@compiletime
function itemMageAmulet()
    let hp = 100
    let mp = 100
    itemDesc[ITEM_ID_MAGE_AMULET] = "+{0} hit points|n+{1} mana points".format(hp.toString(), mp.toString())

public constant ITEM_ID_MAGE_GLOVES = compiletime(newItem("Mage Gloves", 500, SHOP_MAGICAL_1, "", "BTNManaGloves"))
@compiletime
function itemMageGloves()
    let intelligence = 10
    let armor = 5
    itemDesc[ITEM_ID_MAGE_GLOVES] = "+{0} intelligence|n+{1} armor".format(intelligence.toString(), armor.toString())


public constant SHOP_ID_MAGICAL_2= UNIT_ID_GEN.next()
public constant SHOP_MAGICAL_2 = compiletime(new Shop(SHOP_ID_MAGICAL_2, "SHOP 5", 1.3, "units\\human\\HeroBloodElf\\HeroBloodElf") castTo int)

public constant ITEM_ID_WIZARDS_HAT = compiletime(newItem("Wizard's Hat", 800, SHOP_MAGICAL_2, "", "BTNWizardsHat"))
@compiletime
function itemWizardsHat()
    let intelligence = 15
    let mp = 100
    itemDesc[ITEM_ID_WIZARDS_HAT] = "+{0} intelligence|n+{1} mana".format(intelligence.toString(), mp.toString())

public constant SHOP_ID_MAGICAL_3= UNIT_ID_GEN.next()
public constant SHOP_MAGICAL_3 = compiletime(new Shop(SHOP_ID_MAGICAL_3, "SHOP 6", 1.6, "units\\human\\Jaina\\Jaina") castTo int)

public constant ITEM_ID_ENCHANTED_ARMOR = compiletime(newItem("Enchanted Armor", 2800, SHOP_MAGICAL_3, "", "BTNSuperiorMageRobe"))
@compiletime
function itemEnchantedArmor()
    let hp = 400
    let armor = 25
    let wp = 25
    let intelligence = 40
    itemDesc[ITEM_ID_ENCHANTED_ARMOR] = "+{0} hit points|n+{1} armor|n+{2} willpower|n+{3} intelligence".format(hp.toString(), armor.toString(), wp.toString(), intelligence.toString())


    


/*  ==========================================================================================================================
**
**  function to easily create shops
**
**  ==========================================================================================================================*/

class ItemInShop
    int goldCost
    int itemId

    construct(int itemId)
        this.itemId = itemId

    function setupGoldCost()
        this.goldCost = itemGoldCost[itemId]

class Shop
    string itemsMade
    string name
    LinkedList<ItemInShop> soldItems
    BuildingDefinition bDef
    construct(int unitId, string name, real size, string model)
        this.bDef = createShop(unitId, name, size, model)
        this.itemsMade = ""
        this.name = name
        this.soldItems = new LinkedList<ItemInShop>()
        shopList.add(this)

function createShop(int newId, string name, real size, string model) returns BuildingDefinition
    let bDef = new BuildingDefinition(newId, 'hvlt')
        ..setPathingMap("PathTextures\\4x4SimpleSolid.tga")
        ..setNormalAbilities("Avul,Aall,Apit")
        ..setItemsMade("")
        ..setModelFile(model)
        ..setShadowImageCenterX(60)..setShadowImageCenterY(60)
        ..setShadowImageWidth(150)..setShadowImageHeight(150)
        ..setShadowTextureBuilding("")
        ..setGroundTexture("")
        ..setName(name)
        ..setSelectionScale(2)
        ..setScalingValue(size)
    return bDef

/*  ==========================================================================================================================
**
**  conversion functions from formatted strings to a list
**  you cannot pass arrays as arguments, so array conversion is hardcoded
**
**  ==========================================================================================================================*/

function stringToList(string sList, string splitChar) returns LinkedList<int>
    let returnList = new LinkedList<int>()
    string currentString
    var currentIndex = 0
    while currentIndex < sList.length()
        currentString = ""
        while sList.charAt(currentIndex) != splitChar and currentIndex < sList.length()
            currentString += sList.charAt(currentIndex)
            currentIndex ++

            returnList.add(currentString.toInt())
        currentIndex++
    return returnList

/*  ==========================================================================================================================
**
**  Main function to create items.
**  
**  public function newItem(string name, int goldCost, int shop, int x, int y, string requiredItems, string icon, string desc) returns int
**
**  Must be used within the compiletime() magic function
**
**  For items that have recipes (requiredItems!="") another item object is created, that is the recipe
**  Values are automatically created for the recipe based on the original item.
**
**  ==========================================================================================================================*/

public function newItem(string name, int goldCost, int whichShop, string requiredItems, string icon) returns int
    /*

    There should not be any references to other item variables, as they might not have been initialized.

    */
    let shop = whichShop castTo Shop
    currentItemId++
    itemId[currentItemId] = ITEM_ID_GEN.next()
    itemName[currentItemId] = name
    itemShopDescription[currentItemId] = shop.name
    itemIsRecipe[currentItemId] = false
    itemRequiredItems[currentItemId] = ""

    itemGoldCost[currentItemId] = goldCost
    itemDesc[currentItemId] = ""

    itemDefinition[currentItemId] = newItemDefintion(itemId[currentItemId])
        ..presetIcon(icon)
        ..setName(name)
        ..setTooltipBasic(name)
    

    if requiredItems!="" //create additional recipe item directly after the main item
        currentItemId++
        itemId[currentItemId] = ITEM_ID_GEN.next()
        itemName[currentItemId] = name
        itemIsRecipe[currentItemId] = true

        itemRequiredItems[currentItemId] = requiredItems

        itemGoldCost[currentItemId] = goldCost
        itemDesc[currentItemId] = ""

        itemDefinition[currentItemId] = newItemDefintion(itemId[currentItemId])
            ..presetIcon(icon)
            ..setName(name+" - Recipe")
            ..setTooltipBasic(name+" - Recipe")

        if(shop.itemsMade!="")
            shop.itemsMade += ","
        shop.itemsMade += int2fourchar(itemId[currentItemId])
        shop.bDef.setItemsMade(shop.itemsMade)

        shop.soldItems.add(new ItemInShop(currentItemId))

        return currentItemId - 1
    else
        if(shop.itemsMade!="")
            shop.itemsMade += ","
        shop.itemsMade += int2fourchar(itemId[currentItemId])
        shop.bDef.setItemsMade(shop.itemsMade)

        shop.soldItems.add(new ItemInShop(currentItemId))

        return currentItemId

public function newItemDefintion(int itemId) returns ItemDefinition
    let iDef = new ItemDefinition(itemId, 'ratc')
        ..setAbilities("")
        ..setCooldownGroup("")
        ..setStockReplenishInterval(1)
        ..setStockStartDelay(0)
        ..setStockMaximum(1)
        ..setLevel(1)
    return iDef

function ItemDefinition.presetIcon(string name)
    string s = name
    if name.length() < 20 or not name.startsWith("ReplaceableTextures")
            s = "ReplaceableTextures\\CommandButtons\\" + s
    if not name.endsWith(".blp")
        s += ".blp"

    this.setInterfaceIcon(s)


/*  ==========================================================================================================================
**
**  Finalize item creation. After all item objects have been created during compile time, the combined information about all items is
**  used to resolve all values, that reference other items.
**  By doing so the order in which items are defined does not matter and you can reference items that have not even been created.
**
**  gold cost for recipes, description of required items for recipes, button position in shop based on gold cost.
**
**  ==========================================================================================================================*/

@compiletime
function createItemGoldCosts()
    for i = 0 to currentItemId
        if itemIsRecipe[i]
            int recipeGoldCost = itemGoldCost[i]
            string requiredItems = itemRequiredItems[i]
            let requiredItemList = stringToList(requiredItems, ",")
    
            for int j in requiredItemList
                recipeGoldCost -= itemGoldCost[j]
    
            destroy requiredItemList

            itemGoldCost[i] = recipeGoldCost
        itemDefinition[i].setGoldCost(itemGoldCost[i])


    //the object of class ItemInShop are created, while gold cost is not yet known
    //now every object is told to retrieve its gold cost from the array
    for Shop shop in shopList
        for ItemInShop soldItem in shop.soldItems
            soldItem.setupGoldCost()

@compiletime
function sortShops()
    for Shop shop in shopList
        shop.soldItems.sortWith( (ItemInShop i1, ItemInShop i2) -> (i1.goldCost - i2.goldCost) )

        int x = 0
        int y = 0
        for ItemInShop soldItem in shop.soldItems
            itemPosX[soldItem.itemId] = x
            itemPosY[soldItem.itemId] = y
            itemDefinition[soldItem.itemId]
                ..setButtonPositionX(x)
                ..setButtonPositionY(y)
            x++
            if(x>3)
                x = 0
                y++

@compiletime
function createItemDescritptions()
    for i = 0 to currentItemId
        if itemIsRecipe[i]
            string recipeDesc = "|n|n|cffffcc00Requires:|r"
            string requiredItems = itemRequiredItems[i]
            let requiredItemList = stringToList(requiredItems, ",")

            for int j in requiredItemList

                let buttonPos = " ["+(itemPosX[j]+1).toString()+","+(itemPosY[j]+1).toString()+"]"

                recipeDesc += "|n - "+itemName[j]+"       ( "+itemShopDescription[j] + buttonPos+" )"

            destroy requiredItemList



            itemDefinition[i].setDescription(itemDesc[i-1] + recipeDesc)
            itemDefinition[i].setTooltipExtended(itemDesc[i-1] + recipeDesc)
        else
            itemDefinition[i].setDescription(itemDesc[i])
            itemDefinition[i].setTooltipExtended(itemDesc[i])

/*  ==========================================================================================================================
**
**  During compiletime certain arrays are used.
**  To preserve their data for runtime they are converted into a string containing all array members seperated by "|".
**  This conversion happens here.
**
**  ==========================================================================================================================*/

function setupStringArrayGoldCost() returns string
    string s = ""
    for int i = 0 to currentItemId
        s += itemGoldCost[i].toString()+"|"
    return s

function setupStringArrayRequiredItems() returns string
    string s = ""
    for int i = 0 to currentItemId
        s += itemRequiredItems[i]+"|"
    return s

function setupStringArrayItemId() returns string
    string s = ""
    for int i = 0 to currentItemId
        s += int2fourchar(itemId[i])
    return s

function setupStringArrayItemIsRecipe() returns string
    string s = ""
    for int i = 0 to currentItemId
        if itemIsRecipe[i]
            s += "1"
        else
            s += "0"
    return s

public string stringItemGoldCost = compiletime(setupStringArrayGoldCost())
public string stringItemRequiredItems = compiletime(setupStringArrayRequiredItems())
public string stringItemId = compiletime(setupStringArrayItemId())
public string stringItemIsRecipe = compiletime(setupStringArrayItemIsRecipe())

/*  ==========================================================================================================================
**
**  runtime
**
**  ==========================================================================================================================*/

/*  ==========================================================================================================================
**
**  globals
**
**  ==========================================================================================================================*/

Item array itemType 

/*  ==========================================================================================================================
**
**  During compiletime certain arrays are used.
**  To preserve their data for runtime they are converted into a string containing all array members seperated by "|".
**  To use them during runtime, the strings are now converted back to arrays.
**
**  ==========================================================================================================================*/

function setupArrays()
    setupArrayGoldCost(stringItemGoldCost, "|")
    setupArrayRequiredItems(stringItemRequiredItems,"|")
    setupArrayItemId(stringItemId)
    setupArrayItemIsRecipe(stringItemIsRecipe)

    stringItemGoldCost=""
    stringItemRequiredItems=""
    stringItemId=""
    stringItemIsRecipe=""

function setupArrayGoldCost(string stringArray, string splitChar)
    
    string currentString
    var currentIndex = 0
    var stringPos = 0
    while stringPos < stringArray.length()
        currentString = ""
        while stringArray.charAt(stringPos) != splitChar and stringPos < stringArray.length()
            currentString += stringArray.charAt(stringPos)
            stringPos ++

        itemGoldCost[currentIndex] = currentString.toInt()
        stringPos++
        currentIndex++

function setupArrayRequiredItems(string stringArray, string splitChar)
    string currentString
    var currentIndex = 0
    var stringPos = 0
    while stringPos < stringArray.length()
        currentString = ""
        while stringArray.charAt(stringPos) != splitChar and stringPos < stringArray.length()
            currentString += stringArray.charAt(stringPos)
            stringPos ++

        itemRequiredItems[currentIndex] = currentString
        stringPos++
        currentIndex++

function setupArrayItemId(string stringArray)
    string currentString
    var currentIndex = 0
    var stringPos = 0
    while stringPos < stringArray.length()
        currentString = stringArray.charAt(stringPos)+stringArray.charAt(stringPos+1)+stringArray.charAt(stringPos+2)+stringArray.charAt(stringPos+3)
        itemId[currentIndex] = fourchar2int(currentString)

        stringPos += 4
        currentIndex++
        

function setupArrayItemIsRecipe(string stringArray)
    var currentIndex = 0
    while currentIndex < stringArray.length()
        itemIsRecipe[currentIndex] = (stringArray.charAt(currentIndex)=="1") ? true : false
        currentIndex++

    currentItemId = stringArray.length()-1

/*  ==========================================================================================================================
**
**  Creates the runtime item objects based on the compiletime values.
**
**  ==========================================================================================================================*/

function setupItems()
    for i = 0 to currentItemId
        if itemIsRecipe[i]
            itemType[i] = new Recipe(itemId[i], itemGoldCost[i], itemRequiredItems[i], itemType[i-1])
        else
            itemType[i] = new Item(itemId[i], itemGoldCost[i])


class Item
    static constant itemIdToItem = new HashMap<int,Item>()
    constant int itemId
    constant int gold

    construct(int itemId, int gold)
        this.itemId = itemId
        this.gold = gold
        itemIdToItem.put(itemId, this)


class Recipe extends Item

    constant requiredItems = new LinkedList<int>()
    
    constant Item resultItem

    construct(int itemId, int gold, string requiredItems, Item resultItem)
        super(itemId, gold)
        this.requiredItems = stringToList(requiredItems, ",")
        this.resultItem = resultItem

    private static function onItemGet(unit hero, item whichItem)
        let itemId = whichItem.getTypeId()
        let itm = itemIdToItem.get(itemId)
      

        if not (itm instanceof Recipe)
            return


        let recipe = itm castTo Recipe

        let owner = hero.getOwner()
        var missingItems = ""
        var hasAll = true
        if recipe != null
            for int req in recipe.requiredItems
                if not UnitHasItemOfTypeBJ(hero, itemType[req].itemId)
                    hasAll = false
                    if(missingItems!="")
                        missingItems += ", "
                    missingItems += GetObjectName(itemType[req].itemId)
                  

        hero.removeItem(whichItem)
        whichItem.remove()
        if hasAll
            
            for int req in recipe.requiredItems
                GetItemOfTypeFromUnitBJ(hero, itemType[req].itemId).remove()
            hero.addItem(recipe.resultItem.itemId)
        else
            owner.addGold(recipe.gold)
            printTimedToPlayer("You are missing: "+missingItems, 5, owner)
            printTimedToPlayer("Item price refunded.", 5, owner)

    
    protected static function onItemGetTrigger()
        let hero = GetTriggerUnit()
        let whichItem = GetManipulatedItem()
        doAfter(0, () -> onItemGet(hero, whichItem))


function createShopBuilding(int unitId, boolean first, int position)
    rect rectGreen = first ? gg_rct_GreenShops1 : gg_rct_GreenShops2
    rect rectBrown = first ? gg_rct_BrownShops1 : gg_rct_BrownShops2

    vec2 posGreen = rectGreen.getLeftBot().add(64, 64)
    vec2 posBrown = rectBrown.getRightTop().add(-64, -64)

    if(first)
        posGreen=posGreen.add(0, position*128.)
        posBrown=posBrown.add(0, -position*128.)
    else
        posGreen=posGreen.add(position*128., 0)
        posBrown=posBrown.add(-position*128., 0)

    real facing = 0
    if(not first)
        facing = 90

    createUnit(players[10], unitId, posGreen, facing.asAngleDegrees())
        ..addAbility('A00X')

        
    if(not first)
        facing = 270
    else
        facing = 180

    createUnit(players[11], unitId, posBrown, facing.asAngleDegrees())
        ..addAbility('A00X')

init
    CreateTrigger()
        ..registerAnyUnitEvent(EVENT_PLAYER_UNIT_PICKUP_ITEM)
        ..addAction(function Recipe.onItemGetTrigger)

    setupArrays()
    setupItems()

    createShopBuilding(SHOP_ID_PHYSICAL_1, true, 1)
    createShopBuilding(SHOP_ID_PHYSICAL_2, true, 3)
    createShopBuilding(SHOP_ID_PHYSICAL_3, true, 5)
    createShopBuilding(SHOP_ID_MAGICAL_1, false, 1)
    createShopBuilding(SHOP_ID_MAGICAL_2, false, 3)
    createShopBuilding(SHOP_ID_MAGICAL_3, false, 5)

    /*doAfter(1, () -> print("gold cost = "+itemGoldCost[ITEM_ID_HELMET].toString()))
    doAfter(1, () -> print("id = "+itemId[ITEM_ID_HELMET].toString()))
    doAfter(1, () -> print("recipe = "+itemIsRecipe[ITEM_ID_HELMET].toString()))
    doAfter(1, () -> print("required = "+itemRequiredItems[ITEM_ID_HELMET]))

    doAfter(1, () -> print("gold cost = "+itemGoldCost[ITEM_ID_HELMET+1].toString()))
    doAfter(1, () -> print("id = "+itemId[ITEM_ID_HELMET+1].toString()))
    doAfter(1, () -> print("recipe = "+itemIsRecipe[ITEM_ID_HELMET+1].toString()))
    doAfter(1, () -> print("required = "+itemRequiredItems[ITEM_ID_HELMET+1]))*/

/*
constant string array orderIdStrings = [
    "summonfactory","summonwareagle","summonquilbeast","summongrizzly",
    "summonphoenix","waterelemental","spiritwolf", "evileye",
    "inferno", "raisedead", "stasistrap"
    ]

integer currentItemId = 0

public abstract class Item

    LinkedList<Item> requirements
    int itemId
    string name
    int gold
    int x
    int y

    construct(string name, int gold, int itemId, int x, int y)
        this.itemId = itemId
        this.name = name
        this.gold = gold
        this.x = x
        this.y = y


public class BasicItem extends Item

    construct(string name, int gold, int itemId, int x, int y)
        super(name, gold, itemId, x, y)
        this.requirements = new LinkedList<Item>
        let aDef = new AbilityDefinitionNeutralSpell('AI00'+currentItemId)
            ..setGoldCost(1, gold)
            ..setButtonPositionNormalX(x)
            ..setButtonPositionNormalY(y)
            ..setTooltipNormal(1, name)
            ..setTooltipNormalExtended(1, name+"|n"+gold.toString())
        currentItemId++


public class RequiredItem extends Item

    construct(Item baseItem, int y)
        super(baseItem.name, baseItem.gold, baseItem.itemId, 0, y)
        let aDef = new AbilityDefinitionNeutralSpell('AI00'+currentItemId)
            ..setGoldCost(1, gold)
            ..setButtonPositionNormalX(x)
            ..setButtonPositionNormalY(y)
            ..setTooltipNormal(1, name)
            ..setTooltipNormalExtended(1, name+"|n"+gold.toString())
        currentItemId++

public class RecipeItem extends Item

    construct(string name, int gold, int itemId, LinkedList<Item> requirements, int x, int y, int tier)
        super(name, gold, itemId, x, y)
        this.requirements = requirements
        let aDef = new AbilityDefinitionIllidanChannel('AI00'+currentItemId)
            ..setButtonPositionNormalX(x)
            ..setButtonPositionNormalY(y)
            ..setTooltipNormal(1, name)
            ..setTooltipNormalExtended(1, name+"|n"+gold.toString())
        currentItemId++
        if tier == 2
            new RequiredItem(this, 1)
            for Item req in requirements
                new RequiredItem(req, 0)
        
        if tier == 3
            new RequiredItem(this, 2)
            for Item req in requirements
                if req instanceof RecipeItem
                    for Item req2 in req.requirements
                        new RequiredItem(req2, 1)
                new RequiredItem(req, 0)
*/