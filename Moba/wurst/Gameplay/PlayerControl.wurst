package PlayerControl

import UtilityFunctions
import LinkedList
import ErrorHandling
import ClosureTimers
import Assets
import Constants
import initlater HeroControl
import initlater HeroAI
/*
* This package handles players
*
*
*/

public int adminPlayer

public enum PlayerType
    HERO
    NONE
    ARMY
    NEUTRAL

public constant TEAM_1 = 1
public constant TEAM_2 = 2
public constant TEAM_NEUTRAL = 3

@inline
public function invertTeam(int team) returns int
    int ret
    if team == TEAM_1
        ret = TEAM_2
    else if team == TEAM_2
        ret = TEAM_1
    else
        ret = team
        error("cannot invert team: " + team.toString())
    return ret

constant EMPTY_INT_LIST = new LinkedList<int>

public class StatTable

    static protected multiboard mBoard

    static int array columnToPlayer
    static int array playerToColumn

    static int rowCount = 0

    static constant playerList = new LinkedList<int>

    static function setStatTitle(int row, string title)
        mBoard.getItem(row, 0)
            ..setValue(title)
            ..release()

        rowCount++

    static function setStatTitles()
        setStatTitle(rowCount, "Players >")
        setStatTitle(rowCount, "Stats v")
        setStatTitle(rowCount, "Heroes killed:")
        setStatTitle(rowCount, "Deaths:")
        setStatTitle(rowCount, "Assists:")
        setStatTitle(rowCount, "Units killed:")
        setStatTitle(rowCount, "Damage dealt:")
        setStatTitle(rowCount, "Damage taken:")
        setStatTitle(rowCount, "Healing done:")
        setStatTitle(rowCount, "Healing received:")
        setStatTitle(rowCount, "Gold earned:")
        setStatTitle(rowCount, "Hydra's slain:")
        setStatTitle(rowCount, "Buildings razed:")

    static function setRowStat(int row, int column, string value)
        mBoard.getItem(row, column)
            ..setValue(value)
            ..release()

        rowCount++

    static function setRowStats(int column)
        let id = columnToPlayer[column]
        let tmp = rowCount
        rowCount = 2
        setRowStat(rowCount, column, PlayerWrapper.heroKills[id].toString())
        setRowStat(rowCount, column, PlayerWrapper.deaths[id].toString())
        setRowStat(rowCount, column, PlayerWrapper.assists[id].toString())
        setRowStat(rowCount, column, PlayerWrapper.unitKills[id].toString())
        setRowStat(rowCount, column, PlayerWrapper.statDamageDealt[id].toStatString())
        setRowStat(rowCount, column, PlayerWrapper.statDamageTaken[id].toStatString())
        setRowStat(rowCount, column, PlayerWrapper.statHealingDone[id].toStatString())
        setRowStat(rowCount, column, PlayerWrapper.statHealingReceived[id].toStatString())
        setRowStat(rowCount, column, PlayerWrapper.statGoldGained[id].toString())
        setRowStat(rowCount, column, PlayerWrapper.statHydrasKilled[id].toString())
        setRowStat(rowCount, column, PlayerWrapper.statBuildingsRazed[id].toString())

        rowCount = tmp

    static function create()
        int count = 2
        columnToPlayer[1] = TEAM_PLAYER_TEAM_1
        playerToColumn[TEAM_PLAYER_TEAM_1] = 1
        for i = 0 to MAX_HERO_COUNT-1
            if PlayerWrapper.getPlayerHeroes(i).size() != 0
                columnToPlayer[count] = i
                playerToColumn[i] = count
                count++

            if i == HERO_PLAYER_TEAM_1_LAST
                columnToPlayer[count] = TEAM_PLAYER_TEAM_2
                playerToColumn[TEAM_PLAYER_TEAM_2] = count
                count++

        mBoard = CreateMultiboard()
            ..setColumnCount(count)
            ..setRowCount(13)
            ..setItemsStyle(true, false)
            ..setTitle("Stats: "+
                players[TEAM_PLAYER_TEAM_1].getColor().toColor().toColorString()+ScoreTable.team1Kills.toString()+"|r / "+
                players[TEAM_PLAYER_TEAM_2].getColor().toColor().toColorString()+ScoreTable.team2Kills.toString()+"|r"  )
            ..display(true)
            ..minimalize(true)

        for j = 0 to mBoard.getRowCount() - 1
            for i = 1 to mBoard.getColumnCount() - 1 
                mBoard.getItem(j, i)
                    ..setWidth(0.05)
                    ..release()
            mBoard.getItem(j, 0)
                ..setWidth(0.14)
                ..release()

        for i = 1 to mBoard.getColumnCount() - 1 
            let id = columnToPlayer[i]
            let p = players[id]
            let color = p.getColor().toColor()
            string icon = PlayerWrapper.getIcon(id)


            string name = p.getName().substring(0, 5)

            mBoard.getItem(0, i)
                ..setValueColor(color.red, color.green, color.blue, 255)
                ..setStyle(true, true)
                ..setValue(name)
                ..setIcon(icon)
                ..release()

            mBoard.getItem(1, i)
                ..setValueColor(color.red, color.green, color.blue, 255)
                ..setValue("xxxxxx")
                ..release()

            setRowStats(i)

        setStatTitles()

public class ScoreTable

    static protected multiboard mBoard

    protected static int team1Kills = 0
    protected static int team2Kills = 0

    static int array rowToPlayer
    static int array playerToRow

    private static real array width

    static constant playerList = new LinkedList<int>

    static function isMinimized() returns bool
        return mBoard.isMinimized()

    static function minimalize(bool flag)
        mBoard.minimalize(flag)

    static function updateHeader(boolean firstTeam)
        let row = (firstTeam ? 0 : PlayerWrapper.team1HeroCount + 1)
        string teamName = firstTeam ?
        players[TEAM_PLAYER_TEAM_1].getColor().toColor().toColorString() + TEAM_NAME_TEAM_1 + "|r" :
        players[TEAM_PLAYER_TEAM_2].getColor().toColor().toColorString() + TEAM_NAME_TEAM_2 + "|r"
        
        mBoard.getItem(row, 0)
            ..setStyle(true, false)
            ..setValue(teamName)
            ..setWidth(width[0])
            ..release() 
        mBoard.getItem(row, 1)
            ..setStyle(false, true)
            ..setValue("H")
            ..setIcon(Icons.bTNHelmutPurple)
            ..setWidth(width[1])
            ..release() 
        mBoard.getItem(row, 2)
            ..setStyle(false, true)
            ..setValue("D")
            ..setIcon(Icons.bTNSkeletonWarrior)
            ..setWidth(width[2])
            ..release() 
        mBoard.getItem(row, 3)
            ..setStyle(false, true)
            ..setValue("A")
            ..setIcon(Icons.bTNStatUp)
            ..setWidth(width[3])
            ..release() 
        mBoard.getItem(row, 4)
            ..setStyle(false, true)
            ..setValue("U")
            ..setIcon(Icons.bTNFootman)
            ..setWidth(width[4])
            ..release() 

    static function addIcon(int id)
        mBoard.getItem(playerToRow[id], 0)
            ..setIcon(PlayerWrapper.getIcon(id))
            ..release() 

    static function update()
        int index = 0
        mBoard.display(true)

        updateHeader(true)
        updateHeader(false)

        for int i in playerList
            let p = players[i]
            var row = 1 + index

            if PlayerWrapper.team[i] == 2
                row++

            rowToPlayer[row] = i
            playerToRow[i] = row

            let icon = PlayerWrapper.icon[i]

            mBoard.getItem(row, 0)
                ..setStyle(true, true)
                ..setValue(p.getNameColored())
                ..setIcon(icon)
                ..setWidth(width[0])
                ..release() 
            mBoard.getItem(row, 1)
                ..setStyle(true, false)
                ..setValue(PlayerWrapper.heroKills[i].toString()) 
                ..setWidth(width[1])
                ..release() 
            mBoard.getItem(row, 2)
                ..setStyle(true, false)
                ..setValue(PlayerWrapper.deaths[i].toString()) 
                ..setWidth(width[2])
                ..release() 
            mBoard.getItem(row, 3)
                ..setStyle(true, false)
                ..setValue(PlayerWrapper.assists[i].toString()) 
                ..setWidth(width[3])
                ..release() 
            mBoard.getItem(row, 4)
                ..setStyle(true, false)
                ..setValue(PlayerWrapper.unitKills[i].toString())
                ..setWidth(width[4])
                ..release() 
            index++

    static function updatePlayerHeroKills(int i)
        let row = playerToRow[i]
        mBoard.getItem(row, 1)
            ..setValue(PlayerWrapper.heroKills[i].toString()) 
            ..release() 

        mBoard.setTitle("Score: "+
        players[TEAM_PLAYER_TEAM_1].getColor().toColor().toColorString()+team1Kills.toString()+"|r / "+
        players[TEAM_PLAYER_TEAM_2].getColor().toColor().toColorString()+team2Kills.toString()+"|r"  )

    static function updatePlayerDeaths(int i)
        let row = playerToRow[i]
        mBoard.getItem(row, 2)
            ..setValue(PlayerWrapper.deaths[i].toString()) 
            ..release() 

    static function updatePlayerAssists(int i)
        let row = playerToRow[i]
        mBoard.getItem(row, 3)
            ..setValue(PlayerWrapper.assists[i].toString()) 
            ..release() 
            
    static function updatePlayerUnitKills(int i)
        let row = playerToRow[i]
        mBoard.getItem(row, 4)
            ..setValue(PlayerWrapper.unitKills[i].toString())
            ..release() 

    static function display()
    
        Log.trace("displaying score")
        mBoard.display(true)

    static function create()
        width[0] = 0.1
        width[1] = 0.03
        width[2] = 0.03
        width[3] = 0.03
        width[4] = 0.03

        width[5] = 0.09
        width[6] = 0.09
        width[7] = 0.06
        width[8] = 0.07
        width[9] = 0.09
        width[10] = 0.09

        mBoard = CreateMultiboard()
            ..setColumnCount(5)
            ..setRowCount(2)
            ..setItemsStyle(true, false)
            ..setTitle("Score: "+players[TEAM_PLAYER_TEAM_1].getColor().toColor().toColorString()+"0|r / "+players[TEAM_PLAYER_TEAM_2].getColor().toColor().toColorString()+"0|r"  )
            ..display(true)
            ..minimalize(true)
        doAfter(0.02, () -> mBoard.minimalize(false))
        

    static function addPlayer(int i)
        doAfter(0.01) ->
            playerList.add(i)
            playerList.sortWith( (int p1, int p2) -> (p1 - p2) )
            mBoard.setRowCount(mBoard.getRowCount()+1)
            update()


public abstract class PlayerWrapper  
    static constant team1HeroPlayers = new LinkedList<int>
    static constant team2HeroPlayers = new LinkedList<int>

    static int team1HeroCount = 0
    static int team2HeroCount = 0

    static int array unitKills
    static int array heroKills
    static int array deaths
    static int array assists

    static LinkedList<Hero> array playerHeroes

    static real array realGold
    static real array realXp

    static int array statGoldGained
    static real array statDamageDealt
    static real array statDamageTaken
    static real array statHealingReceived
    static real array statHealingDone
    static real array statManaHealed
    static int array statHydrasKilled
    static int array statDragonTurtlesKilled
    static int array statBuildingsRazed

    static string array fullColoredName

    static int array team
    static PlayerType array playerType
    static string array icon

    static function createPlayerWrapper(int id, PlayerType pType)
        unitKills[id] = 0
        heroKills[id] = 0
        deaths[id] = 0
        assists[id] = 0
        fullColoredName[id] = players[id].getColor().toColor().toColorString()+players[id].getName()+"|r"

        playerHeroes[id] = new LinkedList<Hero>

        realGold[id] = 0.0
        realXp[id] = 0.0

        statGoldGained[id] = 0
        statDamageDealt[id] = 0.0
        statDamageTaken[id] = 0.0
        statHealingReceived[id] = 0.0
        statHealingDone[id] = 0.0
        statManaHealed[id] = 0.0
        statHydrasKilled[id] = 0
        statDragonTurtlesKilled[id] = 0
        statBuildingsRazed[id] = 0

        icon[id] = "ReplaceableTextures\\CommandButtons\\BTNSelectHeroOn.blp"

        PlayerWrapper.team[id] = 0
        if id >= 0 and id <= HERO_PLAYER_TEAM_1_LAST
            PlayerWrapper.team[id] = 1
        else if id >= HERO_PLAYER_TEAM_2_FIRST and id <= HERO_PLAYER_TEAM_2_LAST
            PlayerWrapper.team[id] = 2
        else if id == TEAM_PLAYER_TEAM_1
            PlayerWrapper.team[id] = 1
        else if id == TEAM_PLAYER_TEAM_2
            PlayerWrapper.team[id] = 2
        else if id >= PLAYER_NEUTRAL_PASSIVE and id <= PLAYER_NEUTRAL_AGGRESSIVE
            PlayerWrapper.team[id] = 3



        playerType[id] = pType
        if pType == PlayerType.HERO
            ScoreTable.addPlayer(id)
            if PlayerWrapper.team[id] == 1
                team1HeroPlayers.add(id)
                team1HeroCount++
            else if PlayerWrapper.team[id] == 2
                team2HeroPlayers.add(id)
                team2HeroCount++

    static function addUnitKill(int id)
        unitKills[id]++
        ScoreTable.updatePlayerUnitKills(id)

    static function addHeroKill(int id, boolean byHero)
        heroKills[id]++

        if byHero
            if team[id] == TEAM_1
                ScoreTable.team1Kills++
            else
                ScoreTable.team2Kills++

            ScoreTable.updatePlayerHeroKills(id)

    static function addDeath(int id)
        deaths[id]++
        ScoreTable.updatePlayerDeaths(id)

    static function addAssist(int id)
        assists[id]++
        ScoreTable.updatePlayerAssists(id)

    static function getUnitKills(int id) returns int
        return unitKills[id]

    static function getHeroKills(int id) returns int
        return heroKills[id]

    static function getDeaths(int id) returns int
        return deaths[id]

    static function getAssists(int id) returns int
        return assists[id]

    static function getFullColoredName(int id) returns string
        return fullColoredName[id]

    static function toString(int id) returns string
        return "Player = " + players[id].getName()

    static function getTeam(int id) returns int
        return team[id]

    static function getPlayerType(int id) returns PlayerType
        return playerType[id]

    static function getIcon(int id) returns string
        return icon[id]

    static function addHero(int id, Hero whichHero)
        playerHeroes[id].add(whichHero)

    static function getPlayerHeroes(int id) returns LinkedList<Hero>
        return playerHeroes[id]

    static function getPlayerHero(int id, int heroIndex) returns Hero
        return getPlayerHeroes(id).get(heroIndex)

    static function getHeroTeam(int team) returns LinkedList<int>
        if team == TEAM_1
            return team1HeroPlayers
        else if team == TEAM_2
            return team2HeroPlayers
        return EMPTY_INT_LIST

    static function getHeroTeam(bool firstTeam) returns LinkedList<int>
        if firstTeam
            return team1HeroPlayers
        else
            return team2HeroPlayers

    static function getTeamHeroCount(int team) returns int
        if team == TEAM_1
            return team1HeroCount
        else if team == TEAM_2
            return team2HeroCount
        else
            return 0

    static function getTeamHeroCount(bool firstTeam) returns int
        if firstTeam
            return team1HeroCount
        else
            return team2HeroCount

    static function addGoldEx(int id, real gold)
        realGold[id] += gold
        let intGold = realGold[id].toInt()
        addGoldEx(id, intGold)
        realGold[id] -= intGold

    static function addGoldEx(int id, int gold)
        players[id].addGold(gold)
        statGoldGained[id] += gold
        let ai = getAI(id)
        if ai != null
            ai.addGold(gold)

    static function addXp(int id, real xp)
        realXp[id] += xp
        let intXp = realXp[id].toInt()
        let heroes = getPlayerHeroes(id)
        for Hero hero in heroes
            hero.toUnit().addXp(intXp, true)
        realXp[id] -= intXp


function initPlayers()
    var admin = false
    for i = 0 to MAX_HERO_COUNT-1
        player p = players[i]
        SetPlayerState(p, PLAYER_STATE_RESOURCE_FOOD_USED, 1)
        SetPlayerState(p, PLAYER_STATE_RESOURCE_FOOD_USED, 0)
        if p.getSlotState()==PLAYER_SLOT_STATE_PLAYING
            PlayerWrapper.createPlayerWrapper(i, PlayerType.HERO)
            if p.getController() == MAP_CONTROL_COMPUTER
                PauseCompAI(players[i], true)
            if not admin and p.getController() == MAP_CONTROL_USER
                admin = true
                adminPlayer = i
        else
            PlayerWrapper.createPlayerWrapper(i, PlayerType.NONE)


    PlayerWrapper.createPlayerWrapper(TEAM_PLAYER_TEAM_1, PlayerType.ARMY)
    PlayerWrapper.createPlayerWrapper(TEAM_PLAYER_TEAM_2, PlayerType.ARMY)

    PlayerWrapper.createPlayerWrapper(PLAYER_NEUTRAL_AGGRESSIVE, PlayerType.NEUTRAL)
    PlayerWrapper.createPlayerWrapper(CREEP_SPECIAL_OWNER, PlayerType.NEUTRAL)


    for i=PLAYER_NEUTRAL_AGGRESSIVE+1 to PLAYER_NEUTRAL_PASSIVE
        PlayerWrapper.createPlayerWrapper(i, PlayerType.NEUTRAL)

    for i=0 to TEAM_PLAYER_TEAM_2
        for j=0 to TEAM_PLAYER_TEAM_2

            if i < MAX_HERO_COUNT or i == TEAM_PLAYER_TEAM_1 or i == TEAM_PLAYER_TEAM_2
                if j < MAX_HERO_COUNT or j == TEAM_PLAYER_TEAM_1 or j == TEAM_PLAYER_TEAM_2

                    if i!=j and PlayerWrapper.getTeam(i) == PlayerWrapper.getTeam(j)
                        SetPlayerAllianceStateBJ(players[i],players[j], bj_ALLIANCE_ALLIED_VISION)
                
    //armies do not fight vs creeps
    SetPlayerAlliance(players[TEAM_PLAYER_TEAM_1], players[PLAYER_NEUTRAL_AGGRESSIVE], ALLIANCE_PASSIVE, true)
    SetPlayerAlliance(players[TEAM_PLAYER_TEAM_2], players[PLAYER_NEUTRAL_AGGRESSIVE], ALLIANCE_PASSIVE, true)
    SetPlayerAlliance(players[PLAYER_NEUTRAL_AGGRESSIVE], players[TEAM_PLAYER_TEAM_1], ALLIANCE_PASSIVE, true)
    SetPlayerAlliance(players[PLAYER_NEUTRAL_AGGRESSIVE], players[TEAM_PLAYER_TEAM_2], ALLIANCE_PASSIVE, true)

    SetPlayerAlliance(players[TEAM_PLAYER_TEAM_1], players[CREEP_SPECIAL_OWNER], ALLIANCE_PASSIVE, true)
    SetPlayerAlliance(players[TEAM_PLAYER_TEAM_2], players[CREEP_SPECIAL_OWNER], ALLIANCE_PASSIVE, true)
    SetPlayerAlliance(players[CREEP_SPECIAL_OWNER], players[TEAM_PLAYER_TEAM_1], ALLIANCE_PASSIVE, true)
    SetPlayerAlliance(players[CREEP_SPECIAL_OWNER], players[TEAM_PLAYER_TEAM_2], ALLIANCE_PASSIVE, true)

init
    initPlayers()
    doAfter(0, () -> ScoreTable.create())