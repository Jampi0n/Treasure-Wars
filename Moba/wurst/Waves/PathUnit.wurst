package PathUnit

import Path
import TimerUtils
import HashMap
import GameTimer
import ClosureTimers
import UnitIndexer

public class PathUnit 

    static int operations = 0
    static int moveOrders = 0
    static int instances = 0
    static HashMap<unit,PathUnit> unitToPathUnit = new HashMap<unit,PathUnit>
    static group pathUnits = CreateGroup()
    static real gameTime
    static trigger onAttackTrigger = CreateTrigger()
    unit assocUnit
    Path currentPath
    int currentSubPath
    static timer periodicTimer = getTimer()
    private real nextUpdate
    private real lastAttack

    static function classInit()
        periodicTimer.startPeriodic(0.05, function updateMovementStatic)
        doPeriodically(1, (CallbackPeriodic cb) -> (begin
            print("["+instances.toString()+"]orders: "+moveOrders.toString())
            operations = 0
            moveOrders = 0
        end))
        onUnitDeindex(function onRemove)
        onAttackTrigger.registerAnyUnitEvent(EVENT_PLAYER_UNIT_ATTACKED)
        onAttackTrigger.addAction(function onAttackStatic)

        region brownBase = CreateRegion()
            ..addRect(gg_rct_BrownBase)
        region greenBase = CreateRegion()
            ..addRect(gg_rct_GreenBase) 

        CreateTrigger()
            ..registerEnterRegion(brownBase, null)
            ..addAction(function onBaseEnterBrown)
        CreateTrigger()
            ..registerLeaveRegion(brownBase, null)
            ..addAction(function onBaseLeaveBrown)

        CreateTrigger()
            ..registerEnterRegion(greenBase, null)
            ..addAction(function onBaseEnterGreen)
        CreateTrigger()
            ..registerLeaveRegion(greenBase, null)
            ..addAction(function onBaseLeaveGreen)


    //prepares a unit to be able to use paths
    construct(unit u)
        if(unitToPathUnit.has(u))
            print("Warning! - "+u.getName()+" is already a PathUnit.")
            destroy(this)
        else
            this.assocUnit = u
            this.currentPath = null
            this.currentSubPath = 0
            unitToPathUnit.put(this.assocUnit, this)
            pathUnits.addUnit(this.assocUnit)
            this.nextUpdate = getElapsedGameTime() + GetRandomReal(0, 0.1)
            this.lastAttack = 0
            instances++

    static function onRemove()
        let removedPathUnit = unitToPathUnit.get(getDeindexedUnit())
        if(removedPathUnit!=null)
            destroy removedPathUnit

    ondestroy
        unitToPathUnit.remove(this.assocUnit)
        pathUnits.removeUnit(this.assocUnit)
        instances--

    function setPath(Path p)
        this.currentPath = p

    function setPathFirst(Path p)
        this.currentPath = p
        this.assocUnit.issuePointOrder("attack", p.getStartTargetPos())
        this.nextUpdate = gameTime + 15
        
    function getNextUpdate() returns real
        return GetRandomReal(1.1, 1.6)

    static function onAttackStatic()
        PathUnit pathUnit = unitToPathUnit.get(GetAttacker())
        if( pathUnit!=null)
            pathUnit.lastAttack = getElapsedGameTime()
        else
            pathUnit = unitToPathUnit.get(GetTriggerUnit())
            if( pathUnit!=null and GetAttacker().isType(UNIT_TYPE_STRUCTURE))
                pathUnit.nextUpdate = getElapsedGameTime()+4
                if(pathUnit.assocUnit.getCurrentOrder()!=OrderId("attack"))
                    pathUnit.assocUnit.issuePointOrder("attack", pathUnit.assocUnit.getPos())
                    moveOrders++

        

    function updateMovement()
        //print("updateMovement "+this.assocUnit.getName() + " " +this.assocUnit.getHandleId().toString() )
        if(assocUnit==null)
            destroy(this)
            return
        
        this.nextUpdate = gameTime + this.getNextUpdate()

        if(currentPath==null)
            return
       
        //print("continue")

        vec2 v0 = vec2(assocUnit.getX(), assocUnit.getY())
        vec2 v1
        vec2 v2
        real minDistance = -1
        int newSubPath = -1
        int moveSubPath


        //print(this.currentPath.getSubPathCount()-2)
        for i=this.currentSubPath to this.currentPath.getSubPathCount()-2

            v1 = vec2(this.currentPath.getSubPathX(i), this.currentPath.getSubPathY(i))
            //print("v1="+v1.toString())
            v2 = vec2(this.currentPath.getSubPathX(i+1), this.currentPath.getSubPathY(i+1))
            //print("v2="+v2.toString())
            real distance = v0.distanceToSegmentSq(v1, v2).pow(0.5)
            //print("["+i.toString()+"] distance="+distance.toString())
            //print("minDistance="+minDistance.toString())
            if(distance <= minDistance+200 or minDistance==-1)
                minDistance = distance
                newSubPath = i
            //if a subpath is far away, there won't come any close subpathes anymore
            if distance>3000 or minDistance<100
                break
        int newOrder
        //string currentOrder =  OrderId2String(this.assocUnit.getCurrentOrder())
    
        //print(minDistance)
        
        //print(currentOrder)

        //move two subpathes forward
        if(newSubPath+2<=this.currentPath.getSubPathCount()-1)
            moveSubPath = newSubPath+2
        else
            moveSubPath = newSubPath+1

        v2 = vec2(this.currentPath.getSubPathX(moveSubPath), this.currentPath.getSubPathY(moveSubPath))

        //addEffect("Abilities\\Weapons\\FarseerMissile\\FarseerMissile.mdl", v2)

        //print("path: "+this.currentSubPath.toString()+" -> "+newSubPath.toString()+" -> "+moveSubPath.toString())

        if(minDistance>600)
            newOrder = 1
        else
            newOrder = 2

        this.currentSubPath = newSubPath

        //order:
            //0 = do nothing
            //1 = move back
            //2 = continue move


        group nearby = CreateGroup()
        nearby.enumUnitsInRange(v0, 500)
        
        

        while(true)
            unit n = nearby.next()
            if(n==null)
                break
            nearby.removeUnit(n)
            if(unitToPathUnit.has(n))
                PathUnit nearbyPathUnit = unitToPathUnit.get(n)

                if(nearbyPathUnit.currentPath == this.currentPath and (nearbyPathUnit.nextUpdate<gameTime or nearbyPathUnit == this) )
                    

                    if newOrder==1
                        n.issuePointOrder("move", v2)
                        //print("move back?")
                        moveOrders++
                        nearbyPathUnit.nextUpdate = gameTime + this.getNextUpdate()
                    else
                        if(gameTime-nearbyPathUnit.lastAttack > 2)
                            n.issuePointOrder("attack", v2)
                            moveOrders++
                            nearbyPathUnit.nextUpdate = gameTime + this.getNextUpdate()
                        else
                            nearbyPathUnit.nextUpdate = gameTime + this.getNextUpdate()

                    
            
        nearby.destr()

        /*
        if(currentOrder == "move")
            if(minDistance<200)
                newOrder = 2
        if(minDistance>600)
            newOrder = 1
            print("move back after attacking: "+minDistance.toString())
            PingMinimap(this.assocUnit.getX(), this.assocUnit.getY(), 5)
        if(currentOrder!="attack")
            if(minDistance>400)
                if(currentOrder!="move")
                    newOrder = 1
                    print("move back after doing something else")
                    PingMinimap(this.assocUnit.getX(), this.assocUnit.getY(), 5)
            else
                newOrder = 2
        
        //print("newOrder ="+newOrder.toString())
        v2 = vec2(this.currentPath.getSubPathX(newSubPath+1), this.currentPath.getSubPathY(newSubPath+1))
        if(newOrder==1 or this.currentSubPath>newSubPath)
            newOrder = 1
            //this.currentSubPath = newSubPath
            this.assocUnit.issuePointOrder("move",v2)
        else
            if(this.currentSubPath!=newSubPath)
                newOrder = 0
                this.assocUnit.issuePointOrder("attack",v2)
                this.currentSubPath = newSubPath
        
        if(newOrder!=0)
            group nearby = CreateGroup()
            nearby.enumUnitsInRange(v0, 500)
            
            while(true)
                unit n = nearby.next()
                if(n==null)
                    break
                nearby.removeUnit(n)
                if(unitToPathUnit.has(n))
                    PathUnit nearbyPathUnit = unitToPathUnit.get(n)
                    if(nearbyPathUnit.currentPath == this.currentPath and nearbyPathUnit.nextUpdate<gameTime)
                        if(newOrder==1)
                            n.issuePointOrder("move", v2)
                            nearbyPathUnit.nextUpdate = getElapsedGameTime() + this.getNextUpdate()
                        else
                            n.issuePointOrder("attack", v2)
                            nearbyPathUnit.nextUpdate = getElapsedGameTime() + this.getNextUpdate()
                        
                
            nearby.destr()
        */
                                
    static function updateMovementGroup()
        var pU = PathUnit.unitToPathUnit.get(GetEnumUnit())
        if(pU.nextUpdate<gameTime)
            operations++
            pU.updateMovement()

    static function updateMovementStatic()
        gameTime = getElapsedGameTime()
        ForGroup(pathUnits, function updateMovementGroup)

    
    
    function onBaseLeave()
        this.nextUpdate = 0

    function onBaseEnter()
        this.nextUpdate = gameTime + 1000
        if this.assocUnit.getOwner() == players[10]
            this.assocUnit.issuePointOrder("attack", gg_rct_BrownCastle.getRightTop())
        else
            this.assocUnit.issuePointOrder("attack", gg_rct_GreenCastle.getLeftBot())

    //A path unit enters the enemy base
    static function onBaseEnterGreen()
        let u = GetTriggerUnit()
        if u.getOwner() == players[11]
            let pathUnit = unitToPathUnit.get(u)
            if pathUnit != null
                pathUnit.onBaseEnter()
                //print("onBaseEnterGreen")

    static function onBaseEnterBrown()
        let u = GetTriggerUnit()
        if u.getOwner() == players[10]
            let pathUnit = unitToPathUnit.get(u)
            if pathUnit != null
                pathUnit.onBaseEnter()
                //print("onBaseEnterBrown")

    //A path unit leaves its own base

    static function onBaseLeaveGreen()
        let u = GetTriggerUnit()
        if u.getOwner() == players[10]
            let pathUnit = unitToPathUnit.get(u)
            if pathUnit != null
                pathUnit.onBaseLeave()
                //print("onBaseLeaveGreen")


    static function onBaseLeaveBrown()
        let u = GetTriggerUnit()
        if u.getOwner() == players[11]
            let pathUnit = unitToPathUnit.get(u)
            if pathUnit != null
                pathUnit.onBaseLeave()
                //print("onBaseLeaveBrown")




        
init
    PathUnit.classInit()