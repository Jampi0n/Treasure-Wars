package HeroControl

import PlayerControl
import HashMap
import GameTimer
import HeroType
import Upgrades
import TimerUtils
import ClosureTimers
import Execute

constant HP_PER_LEVEL = 15
constant STRENGTH_BONUS = 45

constant int array ASSIST_BOUNTY = [0, 60, 40, 30, 24]
constant int array KILL_BOUNTY = [240, 180, 160, 150, 144]

public function delayInit(real maxDelay, CallbackSingle cb)
    doAfter(GetRandomReal(1, maxDelay), cb)

public class Hero

    static constant assistDuration = 10.

    private CPlayer owner
    private HeroType heroType
    private unit hero
    private integer level
    private static constant onDamageTrigger = CreateTrigger()
    private static constant onDeathTrigger = CreateTrigger()
    private static constant onLevelUpTrigger = CreateTrigger()
    protected static Hero array heroes
    private static constant unitToHero = new HashMap<unit,Hero>
    private constant assistMap = new HashMap<CPlayer,real>
    private trigger onSpellCastTrigger
    private timer reviveTimer
    private timerdialog reviveWindow

    //when gold or xp is shared, their values are mostly non integer. To avoid rounding errors, the remainder will be stored here.
    private real sharedGold = 0
    private real sharedXp = 0

    private unit heroGlow = null

    protected static function classInit()
        onDamageTrigger.addAction(function onDamageStatic)
        onDeathTrigger.addAction(function onDeathStatic)
        onLevelUpTrigger.addAction(function onLevelUpStatic)

        CreateTrigger()
            ..addAction(() -> (begin
                let hero = unitToHero.get(GetTriggerUnit())
                if hero != null
                    hero.upgrade()
            end))
            ..registerAnyUnitEvent(EVENT_PLAYER_HERO_SKILL)


    function setup()
        this.heroType = HeroType.getHeroType(this.hero.getTypeId())
        let upgradePlayer = owner.getPlayer()

        execute( -> this.heroType.initialize())
        
        unitToHero.put(this.hero, this)
        heroes[this.owner.getId()] = this
        delayInit(5) ->
            onDamageTrigger.registerUnitEvent(this.hero, EVENT_UNIT_DAMAGED)
            onDeathTrigger.registerUnitEvent(this.hero, EVENT_UNIT_DEATH)
            onLevelUpTrigger.registerUnitEvent(this.hero, EVENT_UNIT_HERO_LEVEL)
        onSpellCastTrigger = this.heroType.getOnSpellCastTrigger()
        onSpellCastTrigger.registerUnitEvent(this.hero, EVENT_UNIT_SPELL_EFFECT)

        let wrapper = this.hero.wrapper()

        delayInit(10) ->
            this.reviveTimer = getTimer()
            ..setData(this castTo int)
            this.reviveWindow = CreateTimerDialog(this.reviveTimer)
            TimerDialogDisplay(this.reviveWindow, false)
            TimerDialogSetTitle(this.reviveWindow, this.owner.getPlayer().getFullColoredName())

        if this.heroType.getBonusCalculation() != null
            wrapper.setBonusCalculation(this.heroType.getBonusCalculation())
        //print("setup completed: "+this.hero.getName())

        if this.heroType.getUsesHeroGlow()
            this.heroGlow = createUnit(this.hero.getOwner(), 'n00H', this.hero.getPos(), angle(0))

            

            doPeriodically(0.03, (CallbackPeriodic _) ->(begin
                if this.hero.isAlive()
                    this.heroGlow.setXY(this.hero.getPos())
            end))

        wrapper.addStatAbsoluteBonus(Stat.MR, this.heroType.getBase(Stat.MR) * 1 )
        wrapper.addStatAbsoluteBonus(Stat.HR, this.heroType.getBase(Stat.HR) * 3 )

        wrapper.addStatAbsoluteBonus(Stat.HP, this.heroType.getBase(Stat.HP) * 15 + HP_PER_LEVEL )
        wrapper.addStatAbsoluteBonus(Stat.MP, this.heroType.getBase(Stat.MP) * 10 )

        //upgrade level 1
        SetPlayerTechResearched(upgradePlayer, UPG_AD , this.heroType.getBase(Stat.AD))
        SetPlayerTechResearched(upgradePlayer, UPG_AR , this.heroType.getBase(Stat.AR))
        SetPlayerTechResearched(upgradePlayer, UPG_AS , this.heroType.getBase(Stat.AS))

        SetPlayerTechResearched(upgradePlayer, UPG_MS , this.heroType.getBase(Stat.MS))
        this.hero.updateDefaultMovementSpeed()

        SetHeroStr(this.hero, this.heroType.getBase(Stat.STR) + STRENGTH_BONUS , true)
        SetHeroAgi(this.hero, this.heroType.getBase(Stat.AGI), true)
        SetHeroInt(this.hero, this.heroType.getBase(Stat.INT), true)

        wrapper.updateBaseStatsHero()

        for int i = 0 to 10
            wrapper.updateTotalStatBonus(i castTo Stat)

        if this.heroType.getOnCreateFunction() != null
            this.heroType.getOnCreateFunction().onCreate(this)

    construct(CPlayer p, int unitId, vec2 pos, angle facing )
        objectCount++
        this.hero = createUnit(p.getPlayer(), unitId, pos, facing)
        this.owner = p
        this.level = 1
        this.setup()
    
    construct(unit u)
        objectCount++
        this.hero = u
        this.level = GetHeroLevel(this.hero)
        this.owner = u.getOwner().getCPlayer()
        this.setup()

    function toUnit() returns unit
        return this.hero

    function upgrade()
        int newLvl = GetHeroLevel(this.hero)
        player upgradePlayer = this.owner.getPlayer()
        let wrapper = this.hero.wrapper()
        SetPlayerTechResearched(upgradePlayer, UPG_AD , this.heroType.calculateStat(Stat.AD, newLvl))
        SetPlayerTechResearched(upgradePlayer, UPG_AR , this.heroType.calculateStat(Stat.AR, newLvl))
        SetPlayerTechResearched(upgradePlayer, UPG_AS , this.heroType.calculateStat(Stat.AS, newLvl))
        

        wrapper.addStatAbsoluteBonus(Stat.HP, (this.heroType.calculateStat(Stat.HP, newLvl) - this.heroType.calculateStat(Stat.HP, this.level)) * 15 )
        //upgrade bug
        //SetPlayerTechResearched(upgradePlayer, UPG_HP , this.heroType.calculateStat(Stat.HP, newLvl))
        //SetPlayerTechResearched(upgradePlayer, UPG_HR , this.heroType.calculateStat(Stat.HR, lvl))
        
        wrapper.addStatAbsoluteBonus(Stat.MP, (this.heroType.calculateStat(Stat.MP, newLvl) - this.heroType.calculateStat(Stat.MP, this.level)) * 10 )
        //upgrade bug
        //SetPlayerTechResearched(upgradePlayer, UPG_MP , this.heroType.calculateStat(Stat.MP, newLvl))
        //SetPlayerTechResearched(upgradePlayer, UPG_MR , this.heroType.calculateStat(Stat.MR, lvl))
        
        wrapper.addStatAbsoluteBonus(Stat.MR, (this.heroType.calculateStat(Stat.MR, newLvl) - this.heroType.calculateStat(Stat.MR, this.level)) * 1 )
        wrapper.addStatAbsoluteBonus(Stat.HR, (this.heroType.calculateStat(Stat.HR, newLvl) - this.heroType.calculateStat(Stat.HR, this.level)) * 3 )

        wrapper.addStatAbsoluteBonus(Stat.HP, (newLvl - this.level) * HP_PER_LEVEL )

        SetPlayerTechResearched(upgradePlayer, UPG_MS , this.heroType.calculateStat(Stat.MS, newLvl))
        this.hero.updateDefaultMovementSpeed()

        //this.hero.wrapper().addStatAbsoluteBonus(Stat.MS, this.heroType.calculateStat(Stat.MS, lvl) - this.heroType.calculateStat(Stat.MS, lvl-1))

        SetHeroStr(this.hero, this.heroType.calculateStat(Stat.STR, newLvl) + STRENGTH_BONUS , true)
        SetHeroAgi(this.hero, this.heroType.calculateStat(Stat.AGI, newLvl), true)
        SetHeroInt(this.hero, this.heroType.calculateStat(Stat.INT, newLvl), true)

        wrapper.updateBaseStatsHero()

        for int i = 0 to 10
            wrapper.updateTotalStatBonus(i castTo Stat)

        this.level = newLvl
        
    function onLevelUp()
        this.upgrade()

    static function onLevelUpStatic()
        unitToHero.get( GetTriggerUnit()).onLevelUp()
    
    //handles assists
    function addAssistDuration(CPlayer p)
        this.assistMap.put(p,getElapsedGameTime() + assistDuration)

    function onDamage()
        CPlayer damageSource
        damageSource = GetEventDamageSource().getOwner().getCPlayer()
        if damageSource != null and damageSource.getTeam()!=this.owner.getTeam()
            this.addAssistDuration(damageSource)

    static function onDamageStatic()
        unitToHero.get( GetTriggerUnit()).onDamage()

    function revive()
        TimerDialogDisplay(this.reviveWindow, false)
        vec2 pos
        if this.owner.getTeam() == Team.TEAM1
            pos = gg_rct_GreenAltar.getCenter()+vec2(128,128)
        else
            pos = gg_rct_BrownAltar.getCenter()-vec2(128,128)
            
        this.hero.revive(pos, true)
        this.hero.setMana(this.hero.getMaxMana())
        this.upgrade()
        if this.heroGlow != null
            this.heroGlow
                ..setXY(pos)
                ..setVertexColor(colorA(255, 255, 255, 255))


    static function reviveStatic()
        let t = GetExpiredTimer()
        let hero = t.getData() castTo Hero
        t.pause()
        hero.revive()

    //handles death
    function onDeath()

        this.owner.addDeath()

        if this.heroGlow != null
            this.heroGlow.setVertexColor(colorA(255, 255, 255, 0))

        real maxValue = -1
        CPlayer lastAssistant = null //find last assistant, to replace killer, if killer is not a player
        player killer = GetKillingUnit().getOwner()
        let assistList = new LinkedList<CPlayer>

        let enemyList = CPlayer.getEnemyHeroPlayers(this.owner.getTeam())

        for CPlayer assistant in enemyList
            let time = this.assistMap.get(assistant)
            if(time > getElapsedGameTime() and assistant.getPlayer()!=killer)
                assistList.add(assistant)
                if(time > maxValue)
                    maxValue = time
                    lastAssistant = assistant

        //replace killer with last assistant, if killer is not an enemy hero
        if not enemyList.contains(killer.getCPlayer()) and not assistList.isEmpty()
            killer = lastAssistant.getPlayer()
            assistList.remove(killer.getCPlayer())

        string assistString = ""

        int size = assistList.size()
        int c = 0
        for CPlayer p in assistList
            c++
            assistString += p.getPlayer().getFullColoredName()+" "
            if c == size-1
                assistString += "and "
            else if c < size
                assistString += ", "

        

        if killer.getId() < PLAYER_NEUTRAL_AGGRESSIVE
            let bounty = 240
            int assistBounty = ASSIST_BOUNTY[size]

            int killBounty = KILL_BOUNTY[size]

            if size == 0
                printTimed("{0} was killed by {1} for {2} gold.".format(
                    this.owner.getPlayer().getFullColoredName(), 
                    killer.getFullColoredName(),
                    "|cffffcc00"+bounty.toString()+"|r"
                ), 10)

                killer.getCPlayer()
                    ..addGoldEx(bounty)
                    ..addHeroKill(killer.getId() < MAX_HERO_COUNT)


            else
                printTimed("{0} was killed by {1} for {3} gold. {2} get{5} {4} gold for helping.".format(
                    this.owner.getPlayer().getFullColoredName(), 
                    killer.getFullColoredName(),
                    assistString,
                    "|cffffcc00"+killBounty.toString()+"|r",
                    "|cffffcc00"+assistBounty.toString()+"|r",
                    size==1?"s":""
                ), 10)

                killer.getCPlayer()
                    ..addGoldEx(bounty)
                    ..addHeroKill(killer.getId() < MAX_HERO_COUNT)
                    
                for CPlayer p in assistList
                    p.addGoldEx(assistBounty)
                    p.addAssist()
            
            //+" |cffffcc00( +"+(bounty/(2*size)).toInt().toString()+")|r"

            //xp
            let xp = (this.level + 5) * 10.

            for CPlayer cPLayer in CPlayer.getEnemyHeroPlayers(this.owner.getTeam())
                let hero = Hero.getHero(cPLayer)
                if hero != null
                    hero.addXp(xp)
        else
            printTimed("{0} was killed by {1}.".format(
                this.owner.getPlayer().getFullColoredName(), 
                killer.getName()
            ), 10)

        destroy assistList

        
        this.reviveTimer
            ..start(10.+level*2, function reviveStatic)
        if GetLocalPlayer() == this.owner.getPlayer()
            TimerDialogDisplay(this.reviveWindow, true)
            
            


    static function onDeathStatic()
        unitToHero.get( GetTriggerUnit()).onDeath()

    //kills the Hero without specifying the killer
    function killHero()
        this.hero.kill()
    
    //kills the Hero, the killer is specified
    function killHero(unit killer)
        this.hero.setHP(1)
        killer.damageTarget(this.hero, 10)

    //kills the Hero. If the killing player is a HeroPlayer,
    //the corresponding Hero is the killer
    //else the Hero is killed wihtout a killer.
    function killHero(CPlayer killer)
        if(killer.getPlayerType() == PlayerType.HERO)
            this.killHero(heroes[(killer).getId()].hero)
        else
            this.killHero()

    function toString() returns string
        return "Hero "+ this.owner.getPlayer().getName() +"="+this.hero.getName()

    function getHeroType() returns HeroType
        return this.heroType

    function getLevel() returns int
        return this.level

    static function getHero(unit whichUnit) returns Hero
        return unitToHero.get(whichUnit)

    static function getHero(int index) returns Hero
        if index < 0 or index > MAX_HERO_COUNT - 1
            printWarning("Index does not exist")
            return null
        return heroes[index]
    
    static function getHero(CPlayer owner) returns Hero
        return getHero(owner.getId())

    static function getHero(player owner) returns Hero
        return getHero(owner.getId())


    function addXp(real xp)
        this.sharedXp += xp
        let intXp = this.sharedXp.toInt()
        this.hero.addXp(intXp, true)
        this.sharedXp -= intXp

    //once the game is over
    function destroyTimer()
        TimerDialogDisplay(this.reviveWindow, false)
        DestroyTimerDialog(this.reviveWindow)
        this.reviveTimer.release()

        
init
    Hero.classInit()