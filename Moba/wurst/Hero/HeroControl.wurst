package HeroControl

import HashMap
import GameTimer
import HeroType
import Upgrades
import TimerUtils
import ClosureTimers
import Execute
import ErrorHandling

constant HP_PER_LEVEL = 15
constant STRENGTH_BONUS = 45

constant int array ASSIST_BOUNTY = [0, 60, 40, 30, 24]
constant int array KILL_BOUNTY = [240, 180, 160, 150, 144]

public function delayInit(real maxDelay, CallbackSingle cb)
    doAfter(GetRandomReal(1, maxDelay), cb)

public class Hero

    static constant assistDuration = 10.

    private player owner
    private int ownerId
    private HeroType heroType
    private unit hero
    private integer level
    private static constant onDamageTrigger = CreateTrigger()
    private static constant onDeathTrigger = CreateTrigger()
    private static constant onLevelUpTrigger = CreateTrigger()
    private static string array assistName
    //protected static Hero array heroes
    private static constant unitToHero = new HashMap<unit, Hero>
    private constant assistMap = new HashMap<int, real>
    private int lastAssistant = -1
    private timer reviveTimer
    private timerdialog reviveWindow
    private boolean firstTeam

    private int array [5] skillIds

    private real array [4] defaultCooldown
    //modifies each cooldown seperately
    private real array [4] cooldownMod

    //when gold or xp is shared, their values are mostly non integer. To avoid rounding errors, the remainder will be stored here.
    private real sharedXp = 0

    private unit heroGlow = null

    private timer tooltipUpdateTimer


    protected static function classInit()
        onDamageTrigger.addAction(function onDamageStatic)
        onDeathTrigger.addAction(function onDeathStatic)
        onLevelUpTrigger.addAction(function onLevelUpStatic)

        CreateTrigger()
        ..addAction(() -> (begin
            let heroUnit = GetTriggerUnit()
            let hero = unitToHero.get(heroUnit)
            if hero != null
                //for i = 0 to 3
                    //hero.defaultCooldown[i] = BlzGetAbilityCooldown(hero.skillIds[i], hero.toUnit().getAbilityLevel(hero.skillIds[i]))
                hero.updateCooldowns()

        end))
        ..registerAnyUnitEvent(EVENT_PLAYER_HERO_SKILL)


    function setup()
        this.firstTeam = PlayerWrapper.getTeam(this.ownerId) == TEAM_1
        this.heroType = HeroType.getHeroType(this.hero.getTypeId())

        this.skillIds[0] = this.heroType.getAbilityId(AbilitySlot.Q)
        this.skillIds[1] = this.heroType.getAbilityId(AbilitySlot.W)
        this.skillIds[2] = this.heroType.getAbilityId(AbilitySlot.E)
        this.skillIds[3] = this.heroType.getAbilityId(AbilitySlot.R)
        this.skillIds[4] = this.heroType.getAbilityId(AbilitySlot.PASSIVE)

        for i = 0 to 3
            this.cooldownMod[i] = 0
            this.defaultCooldown[i] = 0

        execute( -> this.heroType.initialize())
        
        
        unitToHero.put(this.hero, this)
        //heroes[this.owner.getId()] = this
        PlayerWrapper.addHero(this.ownerId, this)

        onDamageTrigger.registerUnitEvent(this.hero, EVENT_UNIT_DAMAGED)
        onDeathTrigger.registerUnitEvent(this.hero, EVENT_UNIT_DEATH)
        onLevelUpTrigger.registerUnitEvent(this.hero, EVENT_UNIT_HERO_LEVEL)
            
        let wrapper = this.hero.wrapper()

        this.reviveTimer = getTimer()
        ..setData(this castTo int)
        this.reviveWindow = CreateTimerDialog(this.reviveTimer)
        TimerDialogDisplay(this.reviveWindow, false)
        TimerDialogSetTitle(this.reviveWindow, this.owner.getFullColoredName())

        if this.heroType.getBonusCalculation() != null
            wrapper.setBonusCalculation(this.heroType.getBonusCalculation())

        if this.heroType.getUsesHeroGlow()
            this.heroGlow = createUnit(this.hero.getOwner(), 'n00H', this.hero.getPos(), angle(0))

            

            doPeriodically(0.03, (CallbackPeriodic _) ->(begin
                if this.hero.isAlive()
                    this.heroGlow.setXY(this.hero.getPos())
            end))

        wrapper.addStatAbsoluteBonus(Stat.MR, this.heroType.getBase(Stat.MR) * 1 )
        wrapper.addStatAbsoluteBonus(Stat.HR, this.heroType.getBase(Stat.HR) * 3 )

        wrapper.addStatAbsoluteBonus(Stat.HP, this.heroType.getBase(Stat.HP) * 15 + HP_PER_LEVEL )
        wrapper.addStatAbsoluteBonus(Stat.MP, this.heroType.getBase(Stat.MP) * 10 )

        wrapper.addStatAbsoluteBonus(Stat.MS, this.heroType.getBase(Stat.MS) )

        //upgrade level 1
        SetPlayerTechResearched(this.owner, UPG_AR , this.heroType.getBase(Stat.AR))
        SetPlayerTechResearched(this.owner, UPG_AS , this.heroType.getBase(Stat.AS))

        //SetPlayerTechResearched(upgradePlayer, UPG_MS , this.heroType.getBase(Stat.MS))
        //this.hero.updateDefaultMovementSpeed()

        SetHeroStr(this.hero, this.heroType.getBase(Stat.STR) + STRENGTH_BONUS , true)
        SetHeroAgi(this.hero, this.heroType.getBase(Stat.AGI), true)
        SetHeroInt(this.hero, this.heroType.getBase(Stat.INT), true)


        

        wrapper.updateBaseStatsHero()

        for int i = 0 to 10
            wrapper.updateTotalStatBonus(i castTo Stat)
        if this.heroType.getOnCreateFunction() != null
            this.heroType.getOnCreateFunction().onCreate(this)


        this.heroType.updateTooltipsStr(this.hero)
        this.heroType.updateTooltipsInt(this.hero)

        this.tooltipUpdateTimer = getTimer()..setData(this castTo int)


    construct(int playerId, int unitId, vec2 pos, angle facing )
        objectCount++
        this.owner = players[playerId]
        this.ownerId = playerId
        this.level = 1
        this.hero = createUnit(this.owner, unitId, pos, facing)
        this.setup()
    
    construct(unit u)
        objectCount++
        this.hero = u
        this.level = GetHeroLevel(this.hero)
        this.owner = u.getOwner()
        this.ownerId = owner.getId()
        this.setup()

    function toUnit() returns unit
        return this.hero

    function upgrade()
        int newLvl = GetHeroLevel(this.hero)
        let wrapper = this.hero.wrapper()
        SetPlayerTechResearched(this.owner, UPG_AR , this.heroType.calculateStat(Stat.AR, newLvl))
        SetPlayerTechResearched(this.owner, UPG_AS , this.heroType.calculateStat(Stat.AS, newLvl))
        

        wrapper.addStatAbsoluteBonus(Stat.HP, (this.heroType.calculateStat(Stat.HP, newLvl) - this.heroType.calculateStat(Stat.HP, this.level)) * 15 )
        //upgrade bug
        //SetPlayerTechResearched(upgradePlayer, UPG_HP , this.heroType.calculateStat(Stat.HP, newLvl))
        //SetPlayerTechResearched(upgradePlayer, UPG_HR , this.heroType.calculateStat(Stat.HR, lvl))
        
        wrapper.addStatAbsoluteBonus(Stat.MP, (this.heroType.calculateStat(Stat.MP, newLvl) - this.heroType.calculateStat(Stat.MP, this.level)) * 10 )
        //upgrade bug
        //SetPlayerTechResearched(upgradePlayer, UPG_MP , this.heroType.calculateStat(Stat.MP, newLvl))
        //SetPlayerTechResearched(upgradePlayer, UPG_MR , this.heroType.calculateStat(Stat.MR, lvl))
        
        wrapper.addStatAbsoluteBonus(Stat.MR, (this.heroType.calculateStat(Stat.MR, newLvl) - this.heroType.calculateStat(Stat.MR, this.level)) * 1 )
        wrapper.addStatAbsoluteBonus(Stat.HR, (this.heroType.calculateStat(Stat.HR, newLvl) - this.heroType.calculateStat(Stat.HR, this.level)) * 3 )

        wrapper.addStatAbsoluteBonus(Stat.HP, (newLvl - this.level) * HP_PER_LEVEL )

        //SetPlayerTechResearched(upgradePlayer, UPG_MS , this.heroType.calculateStat(Stat.MS, newLvl))
        //this.hero.updateDefaultMovementSpeed()

        wrapper.addStatAbsoluteBonus(Stat.MS, this.heroType.calculateStat(Stat.MS, newLvl) - this.heroType.calculateStat(Stat.MS, this.level))


        SetHeroStr(this.hero, this.heroType.calculateStat(Stat.STR, newLvl) + STRENGTH_BONUS , true)
        SetHeroAgi(this.hero, this.heroType.calculateStat(Stat.AGI, newLvl), true)
        SetHeroInt(this.hero, this.heroType.calculateStat(Stat.INT, newLvl), true)


        wrapper.updateBaseStatsHero()

        for int i = 0 to STAT_COUNT - 1
            wrapper.updateTotalStatBonus(i castTo Stat)

        this.level = newLvl

    function onLevelUp()
        this.upgrade()

    static function onLevelUpStatic()
        unitToHero.get( GetTriggerUnit()).onLevelUp()
    
    //handles assists
    function addAssistDuration(int playerId)
        this.assistMap.put(playerId ,getElapsedGameTime() + assistDuration)
        this.lastAssistant = playerId

    function onDamage()
        let damageSource = GetEventDamageSource().getOwner()
        let damageSourceId = damageSource.getId()
        if damageSource != null
            if firstTeam
                if PlayerWrapper.getTeam(damageSourceId) == TEAM_2
                    this.addAssistDuration(damageSource.getId())
            else
                if PlayerWrapper.getTeam(damageSourceId) == TEAM_1
                    this.addAssistDuration(damageSource.getId())

    static function onDamageStatic()
        unitToHero.get( GetTriggerUnit()).onDamage()

    function revive()
        TimerDialogDisplay(this.reviveWindow, false)
        vec2 pos
        if this.firstTeam
            pos = gg_rct_GreenAltar.getCenter()+vec2(128,128)
        else
            pos = gg_rct_BrownAltar.getCenter()-vec2(128,128)
            
        this.hero.revive(pos, true)
        this.hero.setMana(this.hero.getMaxMana())
        this.hero.setTimeScale(1)
        this.upgrade()
        if this.hero.getMoveSpeed() < 100
            let wrapper = this.hero.wrapper()
            Log.warn(this.hero.getName()+" has very low movement speed after revive.")
            Log.warn("getStatTotalValue = "+wrapper.getStatTotalValue(Stat.MS).toString())
            Log.warn("getStatTotalBonus = "+wrapper.getStatTotalBonus(Stat.MS).toString())
            Log.warn("getStatAbsoluteBonus = "+wrapper.getStatAbsoluteBonus(Stat.MS).toString())
            Log.warn("getStatRelativeBonus = "+wrapper.getStatRelativeBonus(Stat.MS).toString())
            Log.warn("getStatBaseValue = "+wrapper.getStatBaseValue(Stat.MS).toString())
            Log.warn("actual ms = "+this.hero.getMoveSpeed().toString())
            Log.warn("default ms = "+this.hero.getDefaultMovespeed().toString() )

        if this.heroGlow != null
            this.heroGlow
                ..setXY(pos)
                ..setVertexColor(colorA(255, 255, 255, 255))


    static function reviveStatic()
        let t = GetExpiredTimer()
        let hero = t.getData() castTo Hero
        t.pause()
        hero.revive()

    //handles death
    function onDeath()
        //indetify true killer

        if this.heroGlow != null
            this.heroGlow.setVertexColor(colorA(255, 255, 255, 0))

        player killingPlayer = GetKillingUnit().getOwner()
        int killingId = killingPlayer.getId()

        //replace killer with last assistant, if killer is not an enemy hero
        boolean replaceKiller = false

        //team 1 hero dies
        if firstTeam
            //killer not in team 2
            if killingId < HERO_PLAYER_TEAM_2_FIRST or killingId > HERO_PLAYER_TEAM_2_LAST
                replaceKiller = true
        //team 2 hero dies
        else
            //killer not in team 1
            if killingId < HERO_PLAYER_TEAM_1_FIRST or killingId > HERO_PLAYER_TEAM_1_LAST
                replaceKiller = true

        let gameTime = getElapsedGameTime()
        let assistList = new LinkedList<int>

        string assistString

        let enemyList = PlayerWrapper.getHeroTeam(not this.firstTeam)
        int i = 0
        for assistantId in enemyList
            let time = this.assistMap.get(assistantId)
            if(time > gameTime and assistantId != killingId)
                if not replaceKiller or lastAssistant != assistantId
                    assistList.add(assistantId)
                    assistName[i] = players[assistantId].getFullColoredName()
                    i++


        let assistants = assistList.size()

        //creating the assist string with correct use of <,> and <and>
        if assistants > 2
            if assistants == 3
                assistString = assistName[0]+", "+assistName[1]+" and "+assistName[2]
            else // 4
                assistString = assistName[0]+", "+assistName[1]+", "+assistName[2]+" and "+assistName[3]
        else
            if assistants == 1
                assistString = assistName[0]
            else //2
                assistString = assistName[0]+" and "+assistName[1]


        boolean unknownKiller = false

        if replaceKiller
            if assistMap.get(lastAssistant) > gameTime
                killingId = lastAssistant
                killingPlayer = players[lastAssistant]
            else
                if killingId != TEAM_PLAYER_TEAM_1 and killingId != TEAM_PLAYER_TEAM_2 and killingId != PLAYER_NEUTRAL_AGGRESSIVE
                    unknownKiller = true

        if not unknownKiller
            if killingId <= HERO_PLAYER_TEAM_2_LAST
                int assistBounty = ASSIST_BOUNTY[assistants]

                int killBounty = KILL_BOUNTY[assistants]

                if assistants == 0
                    printTimed("{0} was killed by {1} for {2} gold.".format(
                        owner.getFullColoredName(), 
                        killingPlayer.getFullColoredName(),
                        "|cffffcc00"+killBounty.toString()+"|r"
                    ), 10)

                else
                    printTimed("{0} was killed by {1} for {3} gold. {2} get{5} {4} gold for helping.".format(
                        owner.getFullColoredName(), 
                        killingPlayer.getFullColoredName(),
                        assistString,
                        "|cffffcc00"+killBounty.toString()+"|r",
                        "|cffffcc00"+assistBounty.toString()+"|r",
                        assistants==1?"s":""
                    ), 10)

                        


                doAfter(0.1) ->
                    for p in assistList
                        PlayerWrapper.addGoldEx(p, assistBounty)
                        PlayerWrapper.addAssist(p)
                    PlayerWrapper.addGoldEx(killingId, killBounty)
                    PlayerWrapper.addHeroKill(killingId, killingId <= HERO_PLAYER_TEAM_2_LAST)
                
                    let xp = (this.level + 5) * 10.
                    for p in PlayerWrapper.getHeroTeam(not this.firstTeam)
                        PlayerWrapper.addXp(p, xp)

                    destroy assistList
            else
                printTimed("{0} was killed by {1}.".format(
                    owner.getFullColoredName(), 
                    killingPlayer.getName()
                ), 10)

                destroy assistList
        else
            printTimed("{0} died.".format(
                owner.getFullColoredName()
            ), 10)
            destroy assistList

        

        
        this.reviveTimer
            ..start(10.+level*2, function reviveStatic)
        if GetLocalPlayer() == owner
            TimerDialogDisplay(this.reviveWindow, true)

        doAfter(0.1) ->
            PlayerWrapper.addDeath(this.ownerId)


    static function onDeathStatic()
        unitToHero.get( GetTriggerUnit()).onDeath()



    function toString() returns string
        return "Hero "+ this.owner.getName() +"="+this.hero.getName()

    function getHeroType() returns HeroType
        return this.heroType

    function getLevel() returns int
        return this.level

    static function copyInventory(unit copyFrom, unit copyTo)
        for i = 0 to 5
            let itm = copyTo.itemInSlot(i)
            let itmId = copyFrom.itemInSlot(i).getTypeId()
            if itm.getTypeId() != itmId
                itm.remove()
                copyTo.addItemToSlot(itmId, i)

    static function getHero(unit whichUnit) returns Hero
        return unitToHero.get(whichUnit)

    /*static function getHero(int index) returns Hero
        if index < 0 or index > MAX_HERO_COUNT - 1
            printWarning("Index does not exist")
            return null
        return heroes[index]*/

    /*static function getHero(CPlayer owner) returns Hero
        return getHero(owner.getId())

    static function getHero(player owner) returns Hero
        return getHero(owner.getId())*/


    function addXp(real xp)
        this.sharedXp += xp
        let intXp = this.sharedXp.toInt()
        this.hero.addXp(intXp, true)
        this.sharedXp -= intXp

    //once the game is over
    function destroyTimer()
        TimerDialogDisplay(this.reviveWindow, false)
        DestroyTimerDialog(this.reviveWindow)
        this.reviveTimer.release()

    /*
    **  Changing cooldowns of morph abilities crashes the game, once they are used.
    */
    function updateCooldowns()
        /*
        for i = 0 to 3
            real newCd = (this.defaultCooldown[i]+this.cooldownMod[i]) / (1.0+0.01*heroUnit.wrapper().getStatTotalValue(Stat.CD))
            BlzSetUnitAbilityCooldown(heroUnit, skillIds[i], GetUnitAbilityLevel(heroUnit, skillIds[i]), newCd )  */
        
        /*
            Tooltips do not need to be updated instantly. This serves as a cooldown to prevent lag spikes.
        */
        tooltipUpdateTimer.start(0.125) ->
            let hero = GetExpiredTimer().getData() castTo Hero
            let heroType = hero.getHeroType()
            let heroUnit = hero.toUnit()
            heroType.updateTooltipsStr(heroUnit)
            heroType.updateTooltipsInt(heroUnit)

function charToAbilitySlot(string char) returns AbilitySlot
    AbilitySlot ret = AbilitySlot.PASSIVE
    string s = char.toUpperCase()
    if s == "Q"
        ret = AbilitySlot.Q
    else if s == "W"
        ret = AbilitySlot.W
    else if s == "E"
        ret = AbilitySlot.E
    else if s == "R"
        ret = AbilitySlot.R
    else if s == "D"
        ret = AbilitySlot.PASSIVE
    else
        error("unknown skill slot: "+char)

    return ret


init
    Hero.classInit()
                