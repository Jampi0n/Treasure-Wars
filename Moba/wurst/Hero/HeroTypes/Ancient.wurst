package Ancient

//4

import HeroType
import TimerUtils
import UnitType
import ClosureTimers
import HeroControl


public constant HERO_TREE = 'H014'
HeroType heroType

constant UPROOTED = compiletime(UNIT_ID_GEN.next())

constant ABILITY_REGENERATION = 'AZ4P'
constant ABILITY_EAT_UNIT = 'AZ4Q'
constant ABILITY_IMPALE = 'AZ4W'
constant ABILITY_ROOT = 'AZ4E'
constant ABILITY_NATURES_WRATH = 'AZ4R'

constant int array REGENERATION_HIT_POINT_REGEN = [30, 45, 60, 75, 90]

@compiletime
function passive()
    let aDef =createNoEffectAbiltiy(ABILITY_REGENERATION)
        ..setupWithHotKey("Recovery", "D")
        ..setupIcon("PASSpell_Nature_ResistNature")
        ..setLearnString("Increases the Ancient's hit point regeneration.", (int lvl) -> (begin
            return "{0}% increased regeneration".format(
                REGENERATION_HIT_POINT_REGEN[lvl-1].str())
        end) )

    for lvl = 1 to 5
        aDef
            ..setTooltipNormalExtended(lvl, "Increases the Ancient's hit point regeneration by {0}%.".format(
                REGENERATION_HIT_POINT_REGEN[lvl-1].str())
            )

constant real array DEVOUR_HEAL = [100, 150, 200, 250, 300]
constant real DEVOUR_HEAL_BONUS = 200

constant real array DEVOUR_COOLDOWN = [25, 22, 19, 16, 13]

@compiletime
function rootDummy()
    new UnitDefinition(UPROOTED, 'hfoo')
        ..setNormalAbilities("Aloc")
        ..setModelFile("")
        ..setShadowImageUnit("")
        ..setAttacksEnabled(0)
        ..setMovementType(MovementType.Fly)
        ..setCollisionSize(0)
        ..setFoodCost(0)
        ..setSightRadiusDay(0)
        ..setSightRadiusNight(0)
        ..setUpgradesUsed("")
        ..setUnitSoundSet("")
        ..setName("Uprooted")

@compiletime
function devourUnit()
    int array MANA = [120, 115, 110, 105, 100]

    let aDef = new AbilityDefinitionFarseerChainLightning(ABILITY_EAT_UNIT)
        ..setupIcon("BTNStrengthofNature")
        ..setAnimationNames("spell")
        ..setupWithHotKey("Eat Unit", "Q")
        ..setLightningEffects("")
        ..setArtTarget("")
        ..setMissileArt("")
        ..setArtSpecial("")
        ..setLightningEffects("")
        ..setRequirements(int2fourchar(UPROOTED))
        ..setCheckDependencies(true)
        ..setLearnString(CHANNELING_SPELL + "Grabs the target enemy unit to devour it and heals the hero.", (int lvl) -> (begin
            return "{0} hit points healed, {1} seconds cooldown.".format( DEVOUR_HEAL[lvl-1].str()+DEVOUR_HEAL_BONUS.getBonusString(C_INT), DEVOUR_COOLDOWN[lvl-1].str())
        end) )

    for lvl = 1 to 5
        aDef
            ..setCooldown(lvl, DEVOUR_COOLDOWN[lvl-1])
            ..setManaCost(lvl, MANA[lvl-1])
            ..setNumberofTargetsHit(lvl, 1)
            ..setDamageperTarget(lvl, 0)
            ..setCastRange(lvl, 150)
            ..setDurationNormal(lvl, 0.1)
            ..setTargetsAllowed(lvl, "air,enemies,ground,neutral,nonancient,organic,nonhero")
            ..setTooltipNormalExtended(lvl, CHANNELING_SPELL + "Grabs the target enemy unit to devour it and heals the hero for {0} hit points.".format(
                DEVOUR_HEAL[lvl-1].str()+DEVOUR_HEAL_BONUS.getBonusString(C_INT)
            ))

constant real array ENTANGLE_DURATION = [2, 2.4, 2.8, 3.2, 3.6]
constant real ENTANGLE_DURATION_BONUS = 3
constant real array ENTANGLE_HIT_DAMAGE = [100, 150, 200, 250, 300]
constant real ENTANGLE_HIT_DAMAGE_BONUS = 200

constant BuffType BUFF_ENTAGLING_ROOTS = new BuffType(false, true)
constant int ENTAGLING_ROOTS_BUFF_ID = compiletime(createAuraBuff("Entangling Roots", "This unit was hit by Entangling Roots; it cannot move or attack.", "BTNEntnagle"))
constant int ENTAGLING_ROOTS_ABILITY_ID = compiletime(createNegativeBuffAbility(5, ENTAGLING_ROOTS_BUFF_ID, Abilities.entanglingRootsTarget, "origin"))


@compiletime
function entanglingRoots()
    int array MANA = [120, 130, 140, 150, 160]
    real array COOLDOWN = [14, 13, 12, 11, 10]


    let aDef = new AbilityDefinitionDreadlordCarrionSwarm(ABILITY_IMPALE)
        ..setupIcon("BTNEntnagle")
        ..setAnimationNames("attack,2")
        ..setupWithHotKey("Entangling Roots", "W")
        ..setMissileArt("")
        //..setRequirements(int2fourchar(UPROOTED))
        //..setCheckDependencies(true)
        ..setLearnString("Releases thorns in a line, damaging and entangling every enemy unit they pass through.", (int lvl) -> (begin
            return "{0} damage, {1} second.".format( ENTANGLE_HIT_DAMAGE[lvl-1].str()+ENTANGLE_HIT_DAMAGE_BONUS.getBonusString(C_INT), ENTANGLE_DURATION[lvl-1].toString()+ENTANGLE_DURATION_BONUS.getBonusString(C_INT) )
        end) )

    for lvl = 1 to 5
        aDef
            ..setCooldown(lvl, COOLDOWN[lvl-1])
            ..setManaCost(lvl, MANA[lvl-1])
            ..setCastRange(lvl, 800)
            ..setTargetsAllowed(lvl, "none")
            ..setTooltipNormalExtended(lvl, "Releases thorns in a line, dealing {0} damage and entangling every enemy unit they pass through for {1} seconds.".format(
                ENTANGLE_HIT_DAMAGE[lvl-1].str()+ENTANGLE_HIT_DAMAGE_BONUS.getBonusString(C_INT), ENTANGLE_DURATION[lvl-1].toString()+ENTANGLE_DURATION_BONUS.getBonusString(C_INT)
            ))




constant int array ROOT_RESISTANCE = [10, 20, 30, 40, 50]
constant real array ROOT_AOE_DAMAGE = [20, 30, 40, 50, 60]
constant real ROOT_AOE_DAMAGE_BONUS = 40
constant real array ROOT_AOE_RANGE = [150, 175, 200, 225, 250]

constant real ROOT_DURATION = 1.75//2.57

@compiletime
function root()
    int array MANA = [25, 25, 25, 25, 25]
    real array COOLDOWN = [3, 3, 3, 3, 3]

    let aDef = new AbilityDefinitionBearform(ABILITY_ROOT)
        ..setupIcon(Icons.bTNRoot)
        ..setIconTurnOff(Icons.bTNUproot)
        ..setupWithHotKey("Root", "E")
        ..setLearnString("Burrows the Ancient's roots into the ground, rendering it immobile, but allowing to hurl enormous rocks dealing area of effect damage. The Ancient's armor and willpower are increased while rooted.", (int lvl) -> (begin
            return "{0} area of effect damage, {1} bonus armor and willpower.".format( ROOT_AOE_DAMAGE[lvl-1].str()+ROOT_AOE_DAMAGE_BONUS.getBonusString(C_STR), ROOT_RESISTANCE[lvl-1].str())
        end) )

    for lvl = 1 to 5
        aDef
            ..setCooldown(lvl, COOLDOWN[lvl-1])
            ..setManaCost(lvl, MANA[lvl-1])
            ..setNormalFormUnit(lvl, int2fourchar('H014'))
            ..setAlternateFormUnit(lvl, int2fourchar('H015'))
            ..setDurationNormal(lvl, ROOT_DURATION)
            ..setTooltipTurnOff(lvl, "(E) Uproot - [|cffffcc00Level "+lvl.toString()+"|r]")
            ..setTooltipNormalExtended(lvl, "Burrows the Ancient's roots into the ground, rendering it immobile, but allowing to hurl enormous rocks dealing {0} area of effect damage. The Ancient's armor and willpower are increased by {1} while rooted.".format(
                ROOT_AOE_DAMAGE[lvl-1].str()+ROOT_AOE_DAMAGE_BONUS.getBonusString(C_STR), ROOT_RESISTANCE[lvl-1].str()
            ))
            ..setTooltipTurnOffExtended(lvl, "Allows the Ancient to pull itself up out of the ground so that it can move and engage units in melee combat.")

constant int NATURES_WRATH_DUMMY_BUFF = compiletime(createDummyBuff())

constant real array NATURES_WRATH_COOLDOWN = [60, 50, 40, 30, 20]
constant real array NATURES_WRATH_TOTAL_DAMAGE = [300, 350, 400, 450, 500]
constant real NATURES_WRATH_TOTAL_DAMAGE_BONUS = 450
constant real array NATURES_WRATH_DURATION = [5, 5, 5, 5, 5]

constant real NATURES_WRATH_AOE = 300

@compiletime
function naturesWrath()
    int array MANA = [160, 170, 180, 190, 200]

    let aDef = new AbilityDefinitionBeserk(ABILITY_NATURES_WRATH)
        ..setupIcon("BTNNaturesWrath")
        ..setupWithHotKey("Nature's Wrath", "R")
        ..setLearnString("Covers the ancient in a storm of sharp leaves, that deal damage to nearby enemies.", (int lvl) -> (begin
            return "{0} damage per second, lasts {1} seconds, {2} seconds cooldown.".format( 
                NATURES_WRATH_TOTAL_DAMAGE[lvl-1].str()+NATURES_WRATH_TOTAL_DAMAGE_BONUS.getBonusString(C_INT), NATURES_WRATH_DURATION[lvl-1].str(), NATURES_WRATH_COOLDOWN[lvl-1].str()
            )
        end) )

    for lvl = 1 to 5
        aDef
            ..setCooldown(lvl, NATURES_WRATH_COOLDOWN[lvl-1])
            ..setManaCost(lvl, MANA[lvl-1])
            ..setBuffs(lvl, int2fourchar(NATURES_WRATH_DUMMY_BUFF))
            ..setDamageTakenIncrease(lvl, 0)
            ..setAttackSpeedIncrease(lvl, 0)
            ..setMovementSpeedIncrease(lvl, 0)
            ..setTooltipNormalExtended(lvl, "Covers the ancient in a storm of sharp leaves, that deal {0} damage to nearby enemies over {1} seconds.".format(
                NATURES_WRATH_TOTAL_DAMAGE[lvl-1].str()+NATURES_WRATH_TOTAL_DAMAGE_BONUS.getBonusString(C_INT), NATURES_WRATH_DURATION[lvl-1].str()
            ))


function string.findLastCharacter(string char) returns int
    for i = this.length()-1 downto 0
        if this.charAt(i) == char
            return i
    
    return -1


unit array uprooted_dummy


class EatTreeAnimation


    private real xFactor
    private vec2 startPos
    private angle direction

    private unit caster
    private unit target
    private int level
    private timer checkTimer
    private int count

    private boolean kill = false
    private effect model


    construct(unit caster, unit target)
        this.count = 0
        this.caster = caster
        this.target = target
        
        this.level = caster.getAbilityLevel(ABILITY_EAT_UNIT)
        this.startPos = target.getPos()
        this.direction = startPos.angleTo(caster.getPos())

        string modelPath = ""
        let uType = UnitType.getUnitType(target.getTypeId())
        if uType != null
            modelPath = uType.getModel()



            modelPath = modelPath.substring(modelPath.findLastCharacter("\\")+1, modelPath.length()-4)+"NoDeath"+".mdx"

            doAfter( 0, () -> caster.setColor(target.getOwner().getColor()))


        this.model = caster.addEffect(modelPath, "sprite, eattree")

        xFactor = caster.getPos().distanceTo(this.startPos)

        target.hide()
        target.pause()

        this.checkTimer = getTimer()
            ..setData(this castTo int)
            ..startPeriodic(0.02, function updateStatic)

    function update()
        this.count++

    
        if count >= 75
            kill = true

        if this.caster.getCurrentOrder()!= OrderId("chainlightning")
            destroy this
            return
    
    static function updateStatic()
        (GetExpiredTimer().getData() castTo EatTreeAnimation).update()

    ondestroy

        this.model.destr()

        target.show()
        target.unpause()
        
        if kill
            target.setXY(caster.getPos())
            target.setHP(1)
            caster.dealDamage(target, 10, ReductionType.NONE)
            target.remove()
            caster.addHP(DEVOUR_HEAL[level-1].bonus(caster.getInt(), DEVOUR_HEAL_BONUS))

        this.checkTimer.release()

function onRootStats(unit caster, int level) // add bonus
    caster.wrapper().addStatAbsoluteBonus(Stat.AR, ROOT_RESISTANCE[level-1])
    caster.wrapper().addStatAbsoluteBonus(Stat.AGI, ROOT_RESISTANCE[level-1])
    caster.wrapper().addStatAbsoluteBonus(Stat.MS, 0)

function onRoot(unit caster, int level) // add bonus
    doAfter(0, () -> caster.setPropWindow(0))
    onRootStats(caster, level)
    caster.setTimeScale(1)

function onUprootStats(unit caster, int level) // remove bonus
    caster.wrapper().addStatAbsoluteBonus(Stat.AR, -ROOT_RESISTANCE[level-1])
    caster.wrapper().addStatAbsoluteBonus(Stat.AGI, -ROOT_RESISTANCE[level-1])
    caster.wrapper().addStatAbsoluteBonus(Stat.MS, 0)
    

function onUproot(unit caster, int level) // remove bonus
    caster.setPropWindow(GetUnitDefaultPropWindow(caster))
    onUprootStats(caster, level)
    caster.setTimeScale(1)

class NaturesWrath

    unit caster
    effect model
    int count
    timer checkTimer
    int level

    construct(unit caster, int level)
        this.caster = caster
        this.model = caster.addEffect("Models\\EarthTornado2NoSound.mdx", "origin")
        this.count = 0
        this.level = level

        this.checkTimer = getTimer()
        ..setData(this castTo int)
        ..startPeriodic(0.02, function updateStatic)

    function update()
        this.count++


        if not this.caster.isAlive() or count >= 5 * 50
            destroy this
        else if count > 0.5 * 50
            group nearby = CreateGroup()
            nearby.enumUnitsInRange(caster.getPos(), NATURES_WRATH_AOE)

            let dmg = 0.02 * (NATURES_WRATH_TOTAL_DAMAGE[level-1].bonus(caster.getInt(), NATURES_WRATH_TOTAL_DAMAGE_BONUS))/NATURES_WRATH_DURATION[level-1]

            while(not nearby.isEmpty())
                unit u = FirstOfGroup(nearby)
                nearby.removeUnit(u)
                if not u.isType(UNIT_TYPE_STRUCTURE) and u.isTargetable(caster.getOwner(), false, true)
                    caster.dealDamage(u, dmg, ReductionType.MAGIC)

            nearby.destr()

    static function updateStatic()
        (GetExpiredTimer().getData() castTo NaturesWrath).update()

    ondestroy
        this.checkTimer.release()
        this.model.destr()


function onAttack(unit attacker, unit target, boolean _isActive)
    let level = attacker.getAbilityLevel(ABILITY_ROOT)
    if level != 0 and attacker.getTypeId() == 'H015'
        group nearby = CreateGroup()
        nearby.enumUnitsInRange(target.getPos(), ROOT_AOE_RANGE[level-1])

        let dmg = ROOT_AOE_DAMAGE[level-1].bonus(attacker.getStr(), ROOT_AOE_DAMAGE_BONUS)

        while(not nearby.isEmpty())
            unit u = FirstOfGroup(nearby)
            nearby.removeUnit(u)
            if not u.isType(UNIT_TYPE_STRUCTURE) and u.isTargetable(attacker.getOwner(), false, true)
                attacker.dealDamage(u, dmg, ReductionType.PHYSICAL)

        nearby.destr()

function onSpellCast()
    let spellId = GetSpellAbilityId()
    let caster = GetTriggerUnit()
    let level = caster.getAbilityLevel(spellId)

    if(spellId == ABILITY_EAT_UNIT)
        new EatTreeAnimation(caster, GetSpellTargetUnit())

    else if (spellId == ABILITY_ROOT)
        let pId = caster.getOwner().getId()
        if caster.getTypeId() == 'H014'
            caster.setTimeScale(2.57/ROOT_DURATION)
            uprooted_dummy[pId].setOwner(Player(PLAYER_NEUTRAL_PASSIVE), false)
            doAfter( ROOT_DURATION, () -> onRoot(caster, level))
        else
            uprooted_dummy[pId].setOwner(Player(pId), false)
            caster.setTimeScale(2.57/ROOT_DURATION)
            doAfter( ROOT_DURATION, () -> onUproot(caster, level))

    else if (spellId == ABILITY_IMPALE)

        let startPos = caster.getPos()
        let direction = startPos.angleTo(vec2(GetSpellTargetX(), GetSpellTargetY()))

        for i = 0 to 8
            doAfter(0.1 * i, () -> (begin
                let thisPos = startPos.polarOffset(direction, i*125.)
                addEffect("Sylvanspear2.mdx", thisPos).destr()

                group nearby = CreateGroup()
                nearby.enumUnitsInRange(thisPos, 130)
        
                let dur = ENTANGLE_DURATION[level-1].bonus(caster.getInt(), ENTANGLE_DURATION_BONUS)

                while(not nearby.isEmpty())
                    unit u = FirstOfGroup(nearby)
                    nearby.removeUnit(u)
                    if not u.isType(UNIT_TYPE_STRUCTURE) and u.isTargetable(caster.getOwner(), false, true)
                        
                        if not BuffList.hasBuffType(u, BUFF_ENTAGLING_ROOTS)
                            caster.dealDamage(u, ENTANGLE_HIT_DAMAGE[level-1].bonus(caster.getInt(), ENTANGLE_HIT_DAMAGE_BONUS), ReductionType.MAGIC)

                        u.addBuffReduced(caster, dur, ENTANGLED, 1)
                        u.addBuffReduced(caster, dur, BUFF_ENTAGLING_ROOTS, level)
        
                nearby.destr()
            end))

    else if spellId == ABILITY_NATURES_WRATH
        doAfter(0, () -> caster.removeAbility(NATURES_WRATH_DUMMY_BUFF))
        new NaturesWrath(caster, level)



function setupStats()
    heroType
        //..setStat(Stat.AD, 5, 40)
        ..setStat(Stat.AR, 8, 39)
        ..setStat(Stat.AS, 0, 8)
        ..setStat(Stat.HP, 13, 69)
        ..setStat(Stat.HR, 13, 54)
        ..setStat(Stat.MP, 15, 48)
        ..setStat(Stat.MR, 12, 38)
        ..setStat(Stat.MS, 0, 6)
        ..setStat(Stat.STR, 22, 54)
        ..setStat(Stat.AGI, 7, 36)
        ..setStat(Stat.INT, 12, 31)

function initHeroType()
    setupStats()

    heroType
        ..setOnAttackFunc((unit attacker, unit target, boolean isActive, boolean advanced) -> onAttack(attacker, target, isActive))
        ..addOnSpellCastFunc(function onSpellCast)
        ..useHeroGlow()
        ..addMorph('H015')

    var abilityList = new LinkedList<int>
        ..add(ENTAGLING_ROOTS_ABILITY_ID)
    BUFF_ENTAGLING_ROOTS.setup(abilityList, ENTAGLING_ROOTS_BUFF_ID)

    for i = 0 to bj_MAX_PLAYERS-1
        uprooted_dummy[i] = null 

    CreateTrigger()
        ..registerAnyUnitEvent(EVENT_PLAYER_HERO_SKILL)
        ..addAction(() -> (begin
            let u = GetTriggerUnit()
            if GetLearnedSkill() == ABILITY_REGENERATION
                let newLevel = u.getAbilityLevel(ABILITY_REGENERATION)
                if newLevel!= 1
                    u.wrapper().addStatRelativeBonus(Stat.HR, -REGENERATION_HIT_POINT_REGEN[newLevel-2]*10)

                u.wrapper().addStatRelativeBonus(Stat.HR, REGENERATION_HIT_POINT_REGEN[newLevel-1]*10)

                

            else if GetLearnedSkill() == ABILITY_ROOT and u.getTypeId() == 'H015' 
                let newLevel = u.getAbilityLevel(ABILITY_ROOT)
                onUprootStats(u, newLevel - 1)
                onRootStats(u, newLevel)
        end))

    CreateTrigger()
        ..registerAnyUnitEvent(EVENT_PLAYER_UNIT_DEATH)
        ..addAction(() -> (begin
            if GetTriggerUnit().getTypeId() == 'H015' 
                let u = GetTriggerUnit()
                onUproot(u, u.getAbilityLevel(ABILITY_ROOT))

    end))


function createHeroType(Hero hero)
    uprooted_dummy[hero.toUnit().getOwner().getId()] = createUnit(hero.toUnit().getOwner(), UPROOTED, hero.toUnit().getPos(), angle(0))
    CreateTrigger()
        ..registerUnitEvent(hero.toUnit(), EVENT_UNIT_ISSUED_POINT_ORDER)
        ..addAction(() ->(begin
            let u = GetTriggerUnit()
            if GetIssuedOrderId() == OrderId("smart") and u.getTypeId() == 'H015'
                let pos = vec2( GetOrderPointX(), GetOrderPointY() )
                doAfter(0, () -> u.issuePointOrder("attack", pos))
    end))

init
    heroType = new HeroType(HERO_TREE)
        ..setOnInitFunction(() -> initHeroType())
        ..setOnCreateFunction((Hero hero) -> createHeroType(hero))

   


