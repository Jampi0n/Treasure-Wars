package Destroyer

//13

import HeroType
import BuffObjEditing
import UnitTypeConfig
import ClosureTimers

public constant HERO_DESTROYER = 'H00R'
HeroType heroType

public constant ABILITY_DEATH_FRENZY = 'AY3P'
constant ABILITY_PREY = 'AY3Q'
constant ABILITY_IMMOLATION = 'AY3W'
constant ABILITY_BONE_WALL = 'AY3E'
constant ABILITY_WILD_RAGE = 'AY3R'

unit heroDestroyer = null

public constant real array DEATH_FRENZY_BONUS = [25, 35, 45, 55, 65]

@compiletime
function passive()
    let aDef = createNoEffectAbiltiy(ABILITY_DEATH_FRENZY)
        ..setupIcon("PASbloodpresence")
        ..setupWithHotKey("Death Frenzy", "D")
        ..setLearnString("The Destroyer deals increased damage from all sources, the more injured he becomes.", (int lvl) -> (begin
            return "up to {0}% increased damage.".format(
                DEATH_FRENZY_BONUS[lvl-1].str())
        end) )

    for lvl = 1 to 5
        aDef
            ..setDescriptionString(false, lvl, "The Destroyer deals up to {0}% increased damage from all sources, the more injured he becomes".format( 
                DEATH_FRENZY_BONUS[lvl-1].str())
            )


constant real array PREY_BONUS_DAMAGE = [25, 40, 55, 70, 85]
constant real PREY_DURATION = 12
constant int array PREY_MOVE_SPEED = [40, 50, 60, 70, 80]

BuffType buffPreyTarget
BuffType buffPreyCaster

constant int PREY_TARGET_BUFF_ID = compiletime(createAuraBuff("Prey", "This unit is under the effect of Prey; it is revealed and takes increased damage from the caster.", "BTNBlood_eye"))
constant int PREY_TARGET_ABILITY_ID = compiletime(createNegativeBuffAbility(5, PREY_TARGET_BUFF_ID, Abilities.curseTarget, "overhead"))


constant int PREY_CASTER_BUFF_ID = compiletime(createAuraBuff("Prey", "This unit has casted Prey; it's movement speed is increased while moving towards the target.", "BTNBlood_eye"))
constant int PREY_CASTER_ABILITY_ID = compiletime(createNegativeBuffAbility(5, PREY_CASTER_BUFF_ID, "", ""))

@compiletime
function abilityQ()
    int array MANA = [90, 95, 100, 105, 110]
    real array COOLDOWN = [16, 16, 16, 16, 16]
    real array RANGE = [2000, 2000, 2000, 2000, 2000]

    let aDef = new AbilityDefinitionIllidanChannel(ABILITY_PREY)
        ..setupIcon("BTNBlood_eye")
        ..setupWithHotKey("Prey", "Q")
        ..setAnimationNames("spell")
        ..setupChannel(TargetType.UNIT, "channel", 0.5)

    for lvl = 1 to 5
        aDef
            ..setCooldown(lvl, COOLDOWN[lvl-1])
            ..setManaCost(lvl, MANA[lvl-1])
            ..setCastRange(lvl, RANGE[lvl-1])
            ..setTargetsAllowed(lvl, "ground,enemy,nonancient,neutral,organic,air")


constant real array IMMOLATION_DAMAGE = [20, 30, 40, 50, 60]
constant real IMMOLATION_DAMAGE_BONUS = 30

constant int array IMMOLATION_ATTACK_SPEED = [15, 20, 25, 30, 35]
constant real array IMMOLATION_MANA_DRAIN = [5, 6, 7, 8, 9]

BuffType buffImmolation
constant IMMOLATION_BUFF_ID = compiletime(BUFF_ID_GEN.next())


@compiletime
function abilityW()
    int array MANA = [25, 25, 25, 25, 25]
    real AOE = 250
    
    new BuffDefinition(IMMOLATION_BUFF_ID, 'BEim')
        ..setTooltipNormalExtended(1, "This unit has Immolation; it attacks faster and nearby enemy units will take damage over time.")
        ..setArtSpecial(1, Abilities.immolationRedDamage)
        ..setArtTarget(1, Abilities.immolationREDTarget)
        ..setTargetAttachmentPoint0(1, "chest")

    let aDef = new AbilityDefinitionDemonHunterImmolation(ABILITY_IMMOLATION)
        ..setupIcon(Icons.bTNImmolationOn)
        ..setIconTurnOff(Icons.bTNImmolationOff)
        ..setupWithHotKey("Immolation", "W")
        ..setTurnOff("Deactivate Immolation","W")
        ..setAnimationNames("spell")

    for lvl = 1 to 5
        aDef
            ..setCooldown(lvl, 0)
            ..setManaCost(lvl, MANA[lvl-1])
            ..setAreaofEffect(lvl, AOE)
            ..setManaDrainedperSecond(lvl, IMMOLATION_MANA_DRAIN[lvl-1])
            ..setBuffs(lvl, IMMOLATION_BUFF_ID.toRawCode()+",BEia")
            ..setTargetsAllowed(lvl, "ground,enemy,nonancient,neutral,organic,air")


constant int array WALL_NUMBER = [6, 7, 8, 9, 10]
constant real array WALL_DURATION = [4, 4.5, 5, 5.5, 6]

@compiletime
function abilityE()
    int array MANA = [90, 90, 90, 90, 90]
    real array COOLDOWN = [17, 16, 15, 14, 13]
    real array RANGE = [1000, 1000, 1000, 1000, 1000]


    let aDef = new AbilityDefinitionIllidanChannel(ABILITY_BONE_WALL)
        ..setAnimationNames("spell")
        ..setupIcon(Icons.bTNRaiseDead)
        ..setupWithHotKey("Bone Wall", "E")
        ..setupChannel(TargetType.POINT, "ward", 0.5)
        ..setLearnString("Summons a wall of bones at the target location, blocking the way for the Destroyer's victims to flee. The wall gets bigger on higher levels.", (int lvl) -> (begin
            return "Lasts {0} seconds.".format(
                WALL_DURATION[lvl-1].toExactString())
        end) )

    for lvl = 1 to 5
        aDef
            ..setCastRange(lvl, RANGE[lvl-1])
            ..setCooldown(lvl, COOLDOWN[lvl-1])
            ..setManaCost(lvl, MANA[lvl-1])
            ..setDescriptionString(false, lvl, "Summons a wall of bones at the target location, blocking the way for the Destroyer's victims to flee. Lasts {0} seconds.".format(
                WALL_DURATION[lvl-1].toExactString()
            ))


        
constant real array RAGE_SELF_DAMAGE = [30, 40, 50, 60, 70]

constant real RAGE_DURATION = 15
constant real RAGE_DURATION_BONUS = 4

constant int array RAGE_DAMAGE_BONUS = [25, 30, 35, 40, 45]

public constant real RAGE_LIFE_STEAL = 0.25

public constant int RAGE_BUFF_ID = compiletime(createAuraBuff("Wild Rage", "This unit has increased damage and is healed for dealing damage. It takes damage over time.", Icons.bTNUnholyFrenzy))
constant int RAGE_ABILITY_ID = compiletime(createPositiveBuffAbility(5, RAGE_BUFF_ID, Abilities.unholyFrenzyTarget, "overhead"))

BuffType buffRage

@compiletime
function abilityR()
    int array MANA = [140, 150, 160, 170, 180]
    real array COOLDOWN = [75, 75, 75, 75, 75]

    let aDef = new AbilityDefinitionRoar(ABILITY_WILD_RAGE)
        ..setupIcon(Icons.bTNUnholyFrenzy)
        ..setAnimationNames("")
        ..setupWithHotKey("Wild Rage", "R")
        ..setLightningEffects("")
        ..setArtTarget("")
        ..setMissileArt("")
        ..setArtSpecial("")
        ..setLightningEffects("")
        ..setCheckDependencies(true)

    for lvl = 1 to 5
        aDef
            ..setCooldown(lvl, COOLDOWN[lvl-1])
            ..setManaCost(lvl, MANA[lvl-1])
            ..setTargetsAllowed(lvl, "none")



function setupStats()
    heroType
        //..setStat(Stat.AD, 5, 40)
        ..setStat(Stat.AR, 12, 31)
        ..setStat(Stat.AS, 29, 73)
        ..setStat(Stat.HP, 14, 43)
        ..setStat(Stat.HR, 32, 69)
        ..setStat(Stat.MP, 19, 41)
        ..setStat(Stat.MR, 17, 38)
        ..setStat(Stat.MS, 31, 77)
        ..setStat(Stat.STR, 17, 64)
        ..setStat(Stat.AGI, 13, 43)
        ..setStat(Stat.INT, 11, 33)

function onDamage()


function onAttack(unit attacker, unit target, boolean _isActive)

    let prey = BuffList.getBuffOfType(target, buffPreyTarget)
    if prey != null
        let level = prey.getLevel()
        attacker.dealDamage(target, PREY_BONUS_DAMAGE[level-1], ReductionType.PHYSICAL)


function onSpellCast()
    let spellId = GetSpellAbilityId()
    let caster = GetTriggerUnit()
    let level = caster.getAbilityLevel(spellId)

    if(spellId==ABILITY_PREY)
        let target = GetSpellTargetUnit()
        target.addBuffReduced(caster, PREY_DURATION, buffPreyTarget, level)
        caster.addBuff(caster, -1, buffPreyCaster, level)

    if(spellId==ABILITY_IMMOLATION)
        caster.addBuff(caster, -1, buffImmolation, 1)

    if(spellId==ABILITY_BONE_WALL)
        let pos = vec2(GetSpellTargetX(), GetSpellTargetY())
        let angle1 = caster.getPos().angleTo(pos)
        let angle2 = angle1.op_minus(angle(bj_PI/2))
        let facing = angle1
        let modelPath = "Doodads\\LordaeronSummer\\Props\\SkullPile\\SkullPile0.mdl"

        var wall = createUnit(caster.getOwner(), WALL, pos, angle(0))
        wall.setXY(pos)
        var model = addEffect(modelPath, pos)
        model.setRoll(facing)
        doAfter(WALL_DURATION[level-1]) ->
            model.setAlpha(0)
            model.destr()
            wall.kill()

        for i = 1 to WALL_NUMBER[level-1]
            var newPos = pos.polarOffset(angle2, 64. * i)
            wall = createUnit(caster.getOwner(), WALL, newPos, angle(0))
            wall.setXY(newPos)
            model = addEffect(modelPath, newPos)
            model.setRoll(facing)
            doAfter(WALL_DURATION[level-1]) ->
                model.setAlpha(0)
                model.destr()
                wall.kill()

            newPos = pos.polarOffset(angle2, -64. * i)
            wall = createUnit(caster.getOwner(), WALL, newPos, angle(0))
            wall.setXY(newPos)
            model = addEffect(modelPath, newPos)
            model.setRoll(facing)
            doAfter(WALL_DURATION[level-1]) ->
                model.setAlpha(0)
                model.destr()
                wall.kill()
    

    if(spellId==ABILITY_WILD_RAGE)
        caster.addBuff(caster, RAGE_DURATION.bonus(caster.getInt(), RAGE_DURATION_BONUS), buffRage, level)
        


function retreatAI(HeroAI _ai)

function attackAI(HeroAI _ai)

function teamFightAI(HeroAI _ai)
            

function setupTooltips()
    DynamicTooltip tooltip = new DynamicTooltip(ABILITY_PREY)
    tooltip.setLearnString("Marks the target enemy unit as his prey. The target will be revealed, the Destroyer will deal bonus damage against the target and have increased movmement speed when moving towards the target. Lasts {0}{I0} seconds.".format(PREY_DURATION.toExactString()), (int lvl) -> (begin
        return "{0} damage, {1}% movement speed".format(
            PREY_BONUS_DAMAGE[lvl-1].str(),
            PREY_MOVE_SPEED[lvl-1].str())
    end) )
    
    for lvl = 1 to 5
        tooltip.setNormalString(true, lvl, "Marks the target enemy unit as his prey. The target will be revealed, the Destroyer will deal {1} bonus damage against the target and have move {2}% faster when moving towards the target. Lasts {0} seconds.".format(
            PREY_DURATION.str(),
            PREY_BONUS_DAMAGE[lvl-1].str(),
            PREY_MOVE_SPEED[lvl-1].str())
        )
    tooltip.setReplaceIntelligence(0)
    heroType.addDynamicTooltipIntelligence(tooltip)

    tooltip = new DynamicTooltip(ABILITY_IMMOLATION)
    tooltip.setLearnString("Engulfs the Destroyer in flames, damaging nearby enemies and the Destroyer himself. Also increases the Destroyer's attack speed.|nDrains mana until deactivated.", (int lvl) -> (begin
        return "{0}{I0} damage per second, {1}% attack speed.".format(
        IMMOLATION_DAMAGE[lvl-1].str(),
        IMMOLATION_ATTACK_SPEED[lvl-1].str())
    end) )
    for lvl = 1 to 5
        tooltip.setNormalString(true, lvl, "Engulfs the Destroyer in flames, dealing {0}{I0} damage per second to nearby enemies and the Destroyer himself. Also increases the Destroyer's attack speed by {1}%.|nDrains mana until deactivated.".format(
            IMMOLATION_DAMAGE[lvl-1].str(),
            IMMOLATION_ATTACK_SPEED[lvl-1].str()))
    tooltip.setReplaceIntelligence(IMMOLATION_DAMAGE_BONUS)
    heroType.addDynamicTooltipIntelligence(tooltip)

    tooltip = new DynamicTooltip(ABILITY_WILD_RAGE)
    tooltip.setLearnString("Increases the Destroyer's attack damage and heals the Destroyer for {0}% of the damage he deals, but deals damage to the Destroyer over time. Lasts {1}{I0} seconds.".format((RAGE_LIFE_STEAL*100).str(), RAGE_DURATION.toExactString()), (int lvl) -> (begin
        return "{0} bonus attack damage, {1} damage per second.".format(
        RAGE_DAMAGE_BONUS[lvl-1].toString(), RAGE_SELF_DAMAGE[lvl-1].toExactString())
    end) )
    
    for lvl = 1 to 5
        tooltip.setNormalString(true, lvl, "Increases the Destroyer's attack damage by {0} and heals the Destroyer for {2}% of the damage he deals, but deals {1} damage per second to the Destroyer. Lasts {3}{I0} seconds.".format(
            RAGE_DAMAGE_BONUS[lvl-1].toString(), RAGE_SELF_DAMAGE[lvl-1].toExactString(), (RAGE_LIFE_STEAL*100).str(), RAGE_DURATION.toExactString()
            ))
    tooltip.setReplaceIntelligence(RAGE_DURATION_BONUS)
    heroType.addDynamicTooltipIntelligence(tooltip)

function initHeroType()
    setupStats()
    setupTooltips()
    heroType.setSkillBuild("QWQWQWQWQWEEEEE")
    delayInit(5) ->
        heroType
            ..setOnAttackFunc((unit attacker, unit target, boolean isActive, boolean advanced) -> onAttack(attacker, target, isActive))
            ..addOnSpellCastFunc(function onSpellCast)
            ..setRetreatAI((HeroAI ai) -> (retreatAI(ai)))
            ..setAttackAI((HeroAI ai) -> (attackAI(ai)))
            ..setTeamFightAI((HeroAI ai) -> (teamFightAI(ai)))
            ..addItem(ITEM_ID_HEAVY_BOOTS)
            ..addItem(ITEM_ID_BLOOD_SWORD)
            ..addItem(ITEM_ID_INFERNAL_BOW)
            ..addItem(ITEM_ID_RUNIC_ARMOR)
            ..addItem(ITEM_ID_SACRIFICIAL_DAGGER)
            ..addItem(ITEM_ID_CURSED_SWORD)

        var abilityList = new LinkedList<int>
        ..add(PREY_TARGET_ABILITY_ID)
        buffPreyTarget = new BuffType(false, true)
        buffPreyTarget.setup(abilityList, PREY_TARGET_BUFF_ID)
        buffPreyTarget.setPeriodicTime(0.2)

        buffPreyTarget.addPeriodicFunction( (Buff whichBuff) -> (begin
            let caster = whichBuff.getCaster()
            let target = whichBuff.getTarget()
            let direction = caster.getPos().angleTo(target.getPos())
            let facing = caster.getFacingAngle()
            var diffDegrees = (direction - facing).degrees() %360

            if diffDegrees < 0
                diffDegrees += 360
            if diffDegrees > 180
                diffDegrees = 360 - diffDegrees

            if diffDegrees < 90
                if whichBuff.getData() == 0
                    whichBuff.setData(1)
                    caster.wrapper().addStatRelativeBonus(Stat.MS, PREY_MOVE_SPEED[whichBuff.getLevel()-1]*10)
            else
                if whichBuff.getData() == 1
                    whichBuff.setData(0)
                    caster.wrapper().addStatRelativeBonus(Stat.MS, -PREY_MOVE_SPEED[whichBuff.getLevel()-1]*10)
                
        end))

        buffPreyTarget.addFirstFunction( (Buff whichBuff) -> (begin
            let caster = whichBuff.getCaster()
            let target = whichBuff.getTarget()
            let level = whichBuff.getLevel()
            whichBuff.setData(0)
            let direction = caster.getPos().angleTo(target.getPos())
            let facing = caster.getFacingAngle()
            var diffDegrees = (direction - facing).degrees() %360

            if diffDegrees < 0
                diffDegrees += 360
            if diffDegrees > 180
                diffDegrees = 360 - diffDegrees

            if diffDegrees < 90
                whichBuff.setData(1)
                caster.wrapper().addStatRelativeBonus(Stat.MS, PREY_MOVE_SPEED[level-1]*10)

            target.wrapper().incReveal()
        end))

        buffPreyTarget.addEndFunction( (Buff whichBuff) -> (begin
            let caster = whichBuff.getCaster()
            let target = whichBuff.getTarget()
            let level = whichBuff.getLevel()
            if whichBuff.getData()==1
                caster.wrapper().addStatRelativeBonus(Stat.MS, -PREY_MOVE_SPEED[level-1]*10)

            target.wrapper().decReveal()
            let casterBuff = BuffList.getBuffOfType(caster, buffPreyCaster)
            if casterBuff!= null
                casterBuff.dispel()
        end))

        abilityList = new LinkedList<int>
        ..add(PREY_CASTER_ABILITY_ID)
        buffPreyCaster = new BuffType(true, true)
        buffPreyCaster.setup(abilityList, PREY_CASTER_BUFF_ID)

        buffImmolation = new BuffType(true, true)
        buffImmolation.setPeriodicTime(0.2)

        buffImmolation.addFirstFunction( (Buff whichBuff) -> (begin
            let level = whichBuff.getLevel()
            whichBuff.setData(level)
            heroDestroyer.wrapper().addStatAbsoluteBonus(Stat.AS, IMMOLATION_ATTACK_SPEED[level-1])
        end))

        buffImmolation.addEndFunction( (Buff whichBuff) -> (begin
            let level = whichBuff.getData()
            heroDestroyer.wrapper().addStatAbsoluteBonus(Stat.AS, -IMMOLATION_ATTACK_SPEED[level-1])
        end))

        buffImmolation.addPeriodicFunction((Buff whichBuff) -> (begin
            let owner = heroDestroyer.getOwner()
            let level = whichBuff.getData()
            if heroDestroyer.hasAbility(IMMOLATION_BUFF_ID)
                let dmg = IMMOLATION_DAMAGE[level-1].bonus(heroDestroyer.getInt(), IMMOLATION_DAMAGE_BONUS) * 0.2
                //use hp to not trigger damage event
                heroDestroyer.addHP(-(dmg.reduceMagic(heroDestroyer.getInt())))
                group g = CreateGroup()
                g.enumUnitsInRange(heroDestroyer.getPos(), 250)
                while true
                    let u = FirstOfGroup(g)
                    if u == null
                        break
                    g.removeUnit(u)
                    if not u.isType(UNIT_TYPE_STRUCTURE) and u.isTargetable(owner, false, true)
                        heroDestroyer.dealDamage(u, dmg, ReductionType.MAGIC)
            else
                whichBuff.dispel()
        end))


        abilityList = new LinkedList<int>
        ..add(RAGE_ABILITY_ID)
        buffRage = new BuffType(true, true)
        buffRage.setup(abilityList, RAGE_BUFF_ID)

        buffRage.setPeriodicTime(0.2)
        buffRage.addPeriodicFunction((Buff whichBuff) -> (begin
            //use hp to not trigger damage event
            heroDestroyer.addHP(-0.2 * (RAGE_SELF_DAMAGE[whichBuff.getLevel()-1].reduceMagic(heroDestroyer.getInt())))
        end))

        buffRage.addFirstFunction( (Buff whichBuff) -> (begin
            heroDestroyer.wrapper().addStatAbsoluteBonus(Stat.AD, RAGE_DAMAGE_BONUS[whichBuff.getLevel()-1])
        end))

        buffRage.addEndFunction( (Buff whichBuff) -> (begin
            heroDestroyer.wrapper().addStatAbsoluteBonus(Stat.AD, -RAGE_DAMAGE_BONUS[whichBuff.getLevel()-1])
        end))

    
init
    
    heroType = new HeroType(HERO_DESTROYER, "BTNEligor", 13, false)
        ..setOnInitFunction(() -> initHeroType())
        ..setOnCreateFunction((Hero h) -> begin
        heroDestroyer = h.toUnit()
    end)
        
