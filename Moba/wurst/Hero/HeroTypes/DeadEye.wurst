package DeadEye

//1

import HeroType
import Missile
import ClosureTimers
import OnUnitEnterLeave
import DamageDetection
import SoundUtils

public constant HERO_DEADEYE = 'H00I'
HeroType heroType

constant ABILITY_BLACK_ARROW = 'AZ1P'
constant ABILITY_PIERCING_SHOT = 'AZ1Q'
constant ABILITY_TERROR = 'AZ1W'
constant ABILITY_BONE_BROTHERS = 'AZ1E'
constant ABILITY_DEATH_PACT = 'AZ1R'
constant ABILITY_DEATH_COIL = 'AZ1S'

constant SOUND_BLACK_ARROW = new SoundDefinition(Sounds.raiseSkeleton1, false, true)

//Balancing and Object Editing

constant real array BLACK_ARROW_THRESHOLD = [40, 55, 70, 85, 90]
constant real array BLACK_ARROW_DURATION = [30, 35, 40, 45, 50]

@compiletime
function blackArrow()
    let aDef = createNoEffectAbiltiy(ABILITY_BLACK_ARROW)
        ..setupIcon("PASTheBlackArrow")
        ..setupWithHotKey("Black Arrow", "D")
        ..setLearnString("Increases the damage of killing attacks against enemies and spawns a skeleton.", (int lvl) -> (begin
            return "{0} damage, lasts {1} seconds.".format(
            BLACK_ARROW_THRESHOLD[lvl-1].str(), 
            BLACK_ARROW_DURATION[lvl-1].str())
        end) )

    for lvl = 1 to 5
        aDef
            ..setDescriptionString(false, lvl, "Increases the damage of killing attacks against enemies by {0} and spawns a skeleton for {1} seconds.".format( 
            BLACK_ARROW_THRESHOLD[lvl-1].str(), 
            BLACK_ARROW_DURATION[lvl-1].str())
            )


constant real array PIERCING_SHOT_DAMAGE = [80, 135, 190, 245, 300]
constant real PIERCING_SHOT_DAMAGE_BONUS = 250

@compiletime
function piercingShot()
    int array MANA = [70, 75, 80, 85, 90]
    real array COOLDOWN = [9, 9, 9, 9, 9]
    real array RANGE = [800, 800, 800, 800, 800]

    let aDef = new AbilityDefinitionIllidanChannel(ABILITY_PIERCING_SHOT)
        ..setupIcon("BTNBlackArrows")
        ..setupWithHotKey("Piercing Shot", "Q")
        ..setArtCaster("")
        ..setArtEffect("")
        ..setMissileArt("")
        ..setArtTarget("")
        ..setAnimationNames("spell,throw")
        /*..setLearnString("Shoots an arrow towards the target direction, dealing damage to enemies it strikes through.", (int lvl) -> (begin
            return "{0} damage.".format(
            PIERCING_SHOT_DAMAGE[lvl-1].str()+PIERCING_SHOT_DAMAGE_BONUS.getBonusString(C_STR))
        end) )*/

    for lvl = 1 to 5
        aDef
            ..setCooldown(lvl, COOLDOWN[lvl-1])
            ..setManaCost(lvl, MANA[lvl-1])
            ..setArtDuration(lvl, 0)
            ..setOptions(lvl, 1)
            ..setTargetType(lvl, 2)
            ..setFollowThroughTime(lvl, 0)
            ..setDisableOtherAbilities(lvl, false)
            ..setBaseOrderID(lvl, "channel")
            ..setCastRange(lvl, RANGE[lvl-1])
            /*..setDescriptionString(true, lvl, "Shoots an arrow towards the target direction, dealing {0} damage to enemies it strikes through.".format(
            PIERCING_SHOT_DAMAGE[lvl-1].str()+PIERCING_SHOT_DAMAGE_BONUS.getBonusString(C_STR))
            )*/


constant real array TERROR_DURATION = [2, 2.6, 3.2, 3.8, 4.4]
constant real TERROR_DURATION_BONUS = 4
real array TERROR_AOE = [600, 650, 700, 750, 800]

constant BUFF_TERROR = new BuffType(false, true)

@compiletime
function terror()
    int array MANA = [90, 100, 110, 120, 130]
    real array COOLDOWN = [16, 16, 16, 16, 16]
    
    let aDef = new AbilityDefinitionPitLordHowlofTerror(ABILITY_TERROR)
        ..setAnimationNames("spell,slam")
        ..setupIcon("BTNHowlOfTerror")
        ..setupWithHotKey("Terror", "W")
        /*..setLearnString("Terrifies nearby enemies, making them miss on their attacks.", (int lvl) -> (begin
            return "{0} seconds, {1} area of effect.".format(
            TERROR_DURATION[lvl-1].toString()+TERROR_DURATION_BONUS.getBonusString(C_INT),
            TERROR_AOE[lvl-1].str())
        end) )*/

    for lvl = 1 to 5
        aDef
            ..setCooldown(lvl, COOLDOWN[lvl-1])
            ..setManaCost(lvl, MANA[lvl-1])
            ..setTargetsAllowed(lvl, "none")
            /*..setDescriptionString(true, lvl, "Terrifies enemies within {0} range, making them miss on their attacks for {1} seconds.".format(
            TERROR_AOE[lvl-1].str(), TERROR_DURATION[lvl-1].toString()+TERROR_DURATION_BONUS.getBonusString(C_INT)))*/



@compiletime
function boneBrothers()
    int array MANA = [70, 65, 60, 55, 50]
    real array COOLDOWN = [18, 15, 12, 9, 6]
    real array RANGE = [600, 700, 800, 900, 1000]

    string learnString = "Switches position with one of his skeletons.|n"
    for lvl = 1 to 5
        learnString+=getLevelString(lvl)+
        "{0} range, {1} seconds cooldown.".format( RANGE[lvl-1].str(), COOLDOWN[lvl-1].str() )

    let aDef = new AbilityDefinitionFarseerChainLightning(ABILITY_BONE_BROTHERS)
        ..setAnimationNames("spell")
        ..setupIcon("BTNSkeletalLongevity")
        ..setupWithHotKey("Bone Brothers", "E")
        ..setMissileArt("")
        ..setArtTarget("")
        ..setLightningEffects("")
        ..setTooltipLearnExtended(learnString)

    for lvl = 1 to 5
        aDef
            ..setDamageperTarget(lvl, 0)
            ..setDamageReductionperTarget(lvl, 0)
            ..setNumberofTargetsHit(lvl, 1)
            ..setCastRange(lvl, RANGE[lvl-1])
            ..setCooldown(lvl, COOLDOWN[lvl-1])
            ..setManaCost(lvl, MANA[lvl-1])
            ..setTargetsAllowed(lvl, "nonancient,player")
            ..setDescriptionString(true, lvl, "Switches position with one of his skeletons." )


        
constant real array DEATH_COIL_DMG_BASE = [200, 275, 350, 425, 500]
constant real array DEATH_COIL_DMG_FACTOR = [20, 35, 50, 65, 80]
constant real DEATH_COIL_DMG_BASE_BONUS = 250
constant real DEATH_COIL_DMG_FACTOR_BONUS = 60
constant real DEATH_COIL_DURATION = 10

constant integer BUFF_ID_ON_DEATH_COIL = compiletime(createDummyBuff())

@compiletime
function deathpact()
    int array MANA = [150, 160, 170, 180, 190]
    real array COOLDOWN = [90, 90, 90, 90, 90]
    real array RANGE = [800, 900, 1000, 1100, 1200]

    let aDef = new AbilityDefinitionRoar(ABILITY_DEATH_PACT)
        ..setLevels(5)
        ..setAnimationNames("spell")
        ..setupIcon("BTNSkullSpirits")
        ..setupWithHotKey("Death Pact", "R")
        ..setArtCaster("Abilities\\Spells\\Undead\\DeathPact\\DeathPactCaster.mdl")

        /*..setLearnString("Sacrifices all his skeletons to unlock the power of Death Coil for "+DEATH_COIL_DURATION.str()+" seconds.|nDeath Coil deals massive magic damage at the target enemy hero. Sacrificing more skeletons increases the damage of Death Coil.", (int lvl) -> (begin
            return "{0} base damage, {1} damage per sacrificed skeleton.".format(
            DEATH_COIL_DMG_BASE[lvl-1].str()+DEATH_COIL_DMG_BASE_BONUS.getBonusString(C_INT),
            DEATH_COIL_DMG_FACTOR[lvl-1].str()+DEATH_COIL_DMG_FACTOR_BONUS.getBonusString(C_INT))
        end) )*/

    for lvl = 1 to 5
        aDef
            ..setCooldown(lvl, COOLDOWN[lvl-1])
            ..setManaCost(lvl, MANA[lvl-1])
            ..setTargetsAllowed(lvl, "none")
            /*..setDescriptionString(true, lvl, "Sacrifices all his skeletons to unlock the power of Death Coil for {0} seconds.|nDeath Coil deals {1} plus {2} for every sacrificed skeleton magic damage to the target enemy hero.".format(
            DEATH_COIL_DURATION.str(),
            DEATH_COIL_DMG_BASE[lvl-1].str()+DEATH_COIL_DMG_BASE_BONUS.getBonusString(C_INT),
            DEATH_COIL_DMG_FACTOR[lvl-1].str()+DEATH_COIL_DMG_FACTOR_BONUS.getBonusString(C_INT)))*/

    let aDefDeathCoil = createTargetMissile(ABILITY_DEATH_COIL, BUFF_ID_ON_DEATH_COIL)
        ..setLevels(5)
        ..setButtonPositionNormalX(3)
        ..setButtonPositionNormalY(2)
        ..setHotkeyNormal("R")
        ..setupIcon("BTNDeathCoil")
        ..setHeroAbility(false)
        ..setMissileArt("Abilities\\Spells\\Undead\\DeathCoil\\DeathCoilMissile.mdl")
        ..setMissileArc(0)
        ..setMissileSpeed(1100)
        ..setArtSpecial("Abilities\\Spells\\Undead\\DeathCoil\\DeathCoilSpecialArt.mdl")

    for lvl = 1 to 5
        aDefDeathCoil
            ..setCastRange(lvl, RANGE[lvl-1])
            ..setManaCost(lvl, 0)
            ..setCooldown(lvl, COOLDOWN[lvl-1])
            ..setTargetsAllowed(lvl, "air,enemies,ground,neutral,nonancient,organic,hero")
            ..setTooltipNormal(lvl, "(R) Learn Death Coil - [|cffffcc00Level "+lvl.toString()+"|r]")
            /*..setDescriptionString(true, lvl, "Deals {0} magic damage and additional {1} magic damage for every sacrificed skeleton to the target enemy hero.".format(
            DEATH_COIL_DMG_BASE[lvl-1].str()+DEATH_COIL_DMG_BASE_BONUS.getBonusString(C_INT),
            DEATH_COIL_DMG_FACTOR[lvl-1].str()+DEATH_COIL_DMG_FACTOR_BONUS.getBonusString(C_INT)))*/
        

group skeletons = CreateGroup()
int skeletonCount = 0

function setupStats()
    heroType
        //..setStat(Stat.AD, 5, 40)
        ..setStat(Stat.AR, 4, 16)
        ..setStat(Stat.AS, 34, 88)
        ..setStat(Stat.HP, 7, 32)
        ..setStat(Stat.HR, 4, 19)
        ..setStat(Stat.MP, 12, 29)
        ..setStat(Stat.MR, 7, 22)
        ..setStat(Stat.MS, 6, 21)
        ..setStat(Stat.STR, 16, 91)
        ..setStat(Stat.AGI, 4, 11)
        ..setStat(Stat.INT, 6, 23)

function onDamage()
    let target = GetTriggerUnit()
    if(target.hasAbility(BUFF_ID_ON_DEATH_COIL))
        target.removeAbility(BUFF_ID_ON_DEATH_COIL)

        let caster = GetEventDamageSource()
        if target.isTargetable(caster.getOwner(), false, true)
            let level = caster.getAbilityLevel(ABILITY_DEATH_PACT)
            GetEventDamageSource().dealDamage(target, 
            DEATH_COIL_DMG_BASE[level-1].bonus(caster.getInt(), DEATH_COIL_DMG_BASE_BONUS)+
            skeletonCount*DEATH_COIL_DMG_FACTOR[level-1].bonus(caster.getInt(), DEATH_COIL_DMG_FACTOR_BONUS), ReductionType.MAGIC)
        doAfter(1, () -> (begin
            caster.removeAbility(ABILITY_DEATH_COIL)
            caster.getOwner().setAbilityAvailable(ABILITY_DEATH_PACT, true)
        end))

function onAttack(unit attacker, unit target, boolean _isActive)
    let level = attacker.getAbilityLevel(ABILITY_BLACK_ARROW)
    if level!=0 and target.isTargetable(attacker.getOwner(), false, true) and target.isVisible(attacker.getOwner()) and not target.isType(UNIT_TYPE_STRUCTURE) and not target.isType(UNIT_TYPE_HERO)
        doAfter(0, () -> (begin
            if(target.getHP() <= BLACK_ARROW_THRESHOLD[level-1])
                let pos =  target.getPos()
                attacker.dealDamage(target, BLACK_ARROW_THRESHOLD[level-1]+1, ReductionType.NONE)
                doAfter(0.1, () -> (begin
                    let skeleton = createUnit(attacker.getOwner(), 'n00B'+level, pos, attacker.getPos().angleTo(target.getPos()))
                    ..setTimedLife(BLACK_ARROW_DURATION[level-1])
                    skeletons.addUnit(skeleton)
                    SOUND_BLACK_ARROW.playOnPoint(pos.toVec3()).snd.setVolume(150)
                end))
        end))

function onSpellCast()
    let spellId = GetSpellAbilityId()
    let caster = GetTriggerUnit()
    let level = caster.getAbilityLevel(spellId)

    if(spellId==ABILITY_TERROR)
        group nearby = CreateGroup()
        nearby.enumUnitsInRange(caster.getPos(), TERROR_AOE[level-1])

        let dur = TERROR_DURATION[level-1].bonus(caster.getInt(), TERROR_DURATION_BONUS)

        while(not nearby.isEmpty())
            unit target = FirstOfGroup(nearby)
            nearby.removeUnit(target)
            if not target.isType(UNIT_TYPE_STRUCTURE) and target.isTargetable(caster.getOwner(), false, true)
                target.addBuffReduced( caster, dur, MISS, 1)
                target.addBuffReduced( caster, dur, BUFF_TERROR, level)

        nearby.destr()

    if(spellId==ABILITY_PIERCING_SHOT)
        let facing = caster.getPos().angleTo(vec2(GetSpellTargetX(), GetSpellTargetY()))
        new Missile(caster, caster.getPos().withZ(80), 1500, facing, "Abilities\\Weapons\\BallistaMissile\\BallistaMissile.mdl")
            ..hitOnce()
            ..setSize(75)
            ..setScale(1.2)
            ..addModel(Abilities.avengerMissile)
            ..setHitCondition((Missile missile, unit target) -> (begin
            return not target.isType(UNIT_TYPE_STRUCTURE) and target.isTargetable(missile.getOwner().getOwner(), false, true)
        end) )
            ..setHitFunction((Missile missile, unit target) -> (begin
            let missileCaster = missile.getOwner()
            missileCaster.dealDamage(Missile.getMissileTarget(), (PIERCING_SHOT_DAMAGE[level-1]).bonus(missileCaster.getStr(), PIERCING_SHOT_DAMAGE_BONUS), ReductionType.PHYSICAL)

        end) )
            ..setMaxRange(1000)

    if(spellId==ABILITY_BONE_BROTHERS)
        let target = GetSpellTargetUnit()
        let targetPos = target.getPos()
        let casterPos = caster.getPos()
        doAfter(0, () -> (begin
            target.setPos(casterPos)
            caster.setPos(targetPos)
            //target might nor be at the exact place, because it was still occupied by caster
            target.setPos(casterPos)
        end))

        let lfx = addLightning(LIGHTNING_DRAIN, true, targetPos, casterPos)
        doAfter(0.5, ()->lfx.destr())

    if(spellId==ABILITY_DEATH_PACT)
        
        var skeleton = FirstOfGroup(skeletons)
        var count = 0
        


        while(skeleton!=null)
            skeletons.removeUnit(skeleton)
            if(skeleton.isAlive())
                skeleton.addEffect("Abilities\\Spells\\Undead\\DeathPact\\DeathPactTarget.mdl", "origin").destr()
                skeleton.kill()
                count++
            skeleton = FirstOfGroup(skeletons)
        skeletonCount = count
        doAfter(1, () -> (begin
            caster.getOwner().setAbilityAvailable(ABILITY_DEATH_PACT, false)
            caster.addAbility(ABILITY_DEATH_COIL)
            caster.setAbilityLevel(ABILITY_DEATH_COIL, level)
        end))
        doAfter(DEATH_COIL_DURATION+1, () -> (begin
            caster.removeAbility(ABILITY_DEATH_COIL)
            caster.getOwner().setAbilityAvailable(ABILITY_DEATH_PACT, true)
        end))


function retreatAI(HeroAI _ai)

function attackAI(HeroAI ai)
    let hero = ai.getHeroUnit()

    unit target
    if hero.getMana()/hero.getMaxMana() > 0.5
        target = hero.findTarget(500, AbilityTargetFocus.ENEMY_HERO, AbilityTargetPriority.LOW_HEALTH, null)
        if target.isTargetable(hero.getOwner(), false, true)
            ai.issue("channel", target.getPos())

    target = hero.findTarget(600, AbilityTargetFocus.ENEMY, AbilityTargetPriority.LOW_HEALTH, null)
    if target.isTargetable(hero.getOwner(), false, true)

        if not ai.getAttacking()
            ai.attack(target)

function teamFightAI(HeroAI ai)
    let ulti = HeroAI.getAbilityId(ai.getHero().getHeroType().getHeroId(), AbilitySlot.R)
    let hero = ai.getHeroUnit()

    if hero.getAbilityLevel(ulti) > 0
        ai.issue("roar")
        ai.issue("acidbomb", ai.getTeamFightTarget())

    if ai.getTeamFightTarget().getPos().distanceTo(hero.getPos()) < 600
        ai.issue("channel", ai.getTeamFightTarget().getPos())

    let g = CreateGroup()
    unit u
    int count = 0
    g.enumUnitsInRange(hero.getPos(), TERROR_AOE[hero.getAbilityLevel(ABILITY_TERROR)])
    while(true)
        u = FirstOfGroup(g)
        if u == null
            break
        g.removeUnit(u)
        if u.isTargetable(hero.getOwner(), false, true)
            if u.isType(UNIT_TYPE_HERO)
                count++

    g.destr()
    if count != 0
        if ai.issue("howlofterror")
            return

        
    unit target = ai.getTeamFightTarget()
    if target.isTargetable(hero.getOwner(), false, true)


        if not ai.getAttacking()
            ai.attack(target)
            

function setupTooltips()
    DynamicTooltip tooltip = new DynamicTooltip(ABILITY_PIERCING_SHOT)
    tooltip.setLearnString("Shoots an arrow towards the target direction, dealing damage to enemies it strikes through.", (int lvl) -> (begin
        return "{0}{S0} damage.".format(
        PIERCING_SHOT_DAMAGE[lvl-1].str())
    end) )
    
    for lvl = 1 to 5
        tooltip.setNormalString(true, lvl, "Shoots an arrow towards the target direction, dealing {0}{S0} damage to enemies it strikes through.".format(
            PIERCING_SHOT_DAMAGE[lvl-1].str())
        )
    tooltip.setReplaceStrength(PIERCING_SHOT_DAMAGE_BONUS)
    heroType.addDynamicTooltipStrength(tooltip)

    tooltip = new DynamicTooltip(ABILITY_TERROR)
    tooltip.setLearnString("Terrifies nearby enemies, making them miss on their attacks.", (int lvl) -> (begin
        return "{0}{I0} seconds, {1} area of effect.".format(
        TERROR_DURATION[lvl-1].toString(),
        TERROR_AOE[lvl-1].str())
    end) )
    for lvl = 1 to 5
        tooltip.setNormalString(true, lvl, "Terrifies enemies within {0} range, making them miss on their attacks for {1}{I0} seconds.".format(
            TERROR_AOE[lvl-1].str(), TERROR_DURATION[lvl-1].toString()))
    tooltip.setReplaceIntelligence(TERROR_DURATION_BONUS)
    heroType.addDynamicTooltipIntelligence(tooltip)

    tooltip = new DynamicTooltip(ABILITY_DEATH_PACT)
    tooltip.setLearnString("Sacrifices all his skeletons to unlock the power of Death Coil for "+DEATH_COIL_DURATION.str()+" seconds.|nDeath Coil deals massive magic damage at the target enemy hero. Sacrificing more skeletons increases the damage of Death Coil.", (int lvl) -> (begin
        return "{0}{I0} base damage, {1}{I1} damage per sacrificed skeleton.".format(
        DEATH_COIL_DMG_BASE[lvl-1].str(),
        DEATH_COIL_DMG_FACTOR[lvl-1].str())
    end) )
    for lvl = 1 to 5
        tooltip.setNormalString(true, lvl, "Sacrifices all his skeletons to unlock the power of Death Coil for {0} seconds.|nDeath Coil deals {1}{I0} plus {2}{I1} for every sacrificed skeleton magic damage to the target enemy hero.".format(
            DEATH_COIL_DURATION.str(),
            DEATH_COIL_DMG_BASE[lvl-1].str(),
            DEATH_COIL_DMG_FACTOR[lvl-1].str()))

    tooltip.setReplaceIntelligence(DEATH_COIL_DMG_BASE_BONUS, DEATH_COIL_DMG_FACTOR_BONUS)
    heroType.addDynamicTooltipIntelligence(tooltip)

    tooltip = new DynamicTooltip(ABILITY_DEATH_COIL)
    tooltip.setLearnString("", (lvl) -> "" )
    
    for lvl = 1 to 5
        tooltip.setNormalString(true, lvl, "Deals {0}{I0} magic damage and additional {1}{I1} magic damage for every sacrificed skeleton to the target enemy hero.".format(
            DEATH_COIL_DMG_BASE[lvl-1].str()+DEATH_COIL_DMG_BASE_BONUS.getBonusString(C_INT),
            DEATH_COIL_DMG_FACTOR[lvl-1].str()+DEATH_COIL_DMG_FACTOR_BONUS.getBonusString(C_INT)))
    tooltip.setReplaceIntelligence(DEATH_COIL_DMG_BASE_BONUS, DEATH_COIL_DMG_FACTOR_BONUS)
    heroType.addDynamicTooltipIntelligence(tooltip)

function initHeroType()
    setupTooltips()
    heroType
        ..setOnAttackFunc((unit attacker, unit target, boolean isActive, boolean advanced) -> onAttack(attacker, target, isActive))
        ..addOnSpellCastFunc(function onSpellCast)
        ..setRetreatAI((HeroAI ai) -> (retreatAI(ai)))
        ..setAttackAI((HeroAI ai) -> (attackAI(ai)))
        ..setTeamFightAI((HeroAI ai) -> (teamFightAI(ai)))
        ..setSkillBuild("QWQWQWQWQWEEEEE")
        ..addItem(ITEM_ID_HEAVY_BOOTS)
        ..addItem(ITEM_ID_BLOOD_SWORD)
        ..addItem(ITEM_ID_INFERNAL_BOW)
        ..addItem(ITEM_ID_RUNIC_ARMOR)
        ..addItem(ITEM_ID_SACRIFICIAL_DAGGER)
        ..addItem(ITEM_ID_CURSED_SWORD)

    onLeave(() -> (begin
        skeletons.removeUnit(getEnterLeaveUnit())
    end))

    var abilityList = new LinkedList<int>
    ..add('A00A')
    BUFF_TERROR.setup(abilityList, 'B00E')

    setupStats()

    addOnDamageFunc( Condition (function onDamage))
    
init
    
    heroType = new HeroType(HERO_DEADEYE, Icons.bTNSkeletonArcher, 1, true)
        ..setOnInitFunction(() -> initHeroType())
        
