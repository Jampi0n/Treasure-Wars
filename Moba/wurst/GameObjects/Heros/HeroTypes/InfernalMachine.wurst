package InfernalMachine

//8

import HeroInclude

int HERO_ORDER = 8

class InfernalMachineInstance
    use HeroInstance

class AttackOrderTrack

    private unit trackUnit
    private trigger trackTrigger
    //linked list instead of hashmap, because the number of elements is 0 or 1
    //still this implementation supports MUI, even if there is no intention to have same heroes at the moment
    private static constant attackTracks = new LinkedList<AttackOrderTrack>()

    private boolean targetedAttack = false
    private unit target = null

    construct(unit u)
        this.trackUnit = u
        attackTracks.add(this)
        this.trackTrigger = CreateTrigger()
            ..registerUnitEvent(u, EVENT_UNIT_ISSUED_ORDER)
            ..registerUnitEvent(u, EVENT_UNIT_ISSUED_POINT_ORDER)
            ..registerUnitEvent(u, EVENT_UNIT_ISSUED_TARGET_ORDER)
            ..addAction(function onOrder)

    static function getAttackTrack(unit u) returns AttackOrderTrack
        for AttackOrderTrack track in attackTracks
            if track.trackUnit == u
                return track
        return null

    static function onOrder()
        AttackOrderTrack thisTrack = getAttackTrack(GetTriggerUnit())
        if thisTrack == null
            return
        let orderTarget = GetOrderTargetUnit()
        if GetIssuedOrderId() == OrderId("attack") and orderTarget != null
            thisTrack.targetedAttack = true
            thisTrack.target = GetOrderTargetUnit()
        else
            if GetIssuedOrderId() == OrderId("smart") and orderTarget.isTargetable(thisTrack.trackUnit.getOwner(), false, true)
                thisTrack.targetedAttack = true
                thisTrack.target = GetOrderTargetUnit()
            else
                if GetIssuedOrderId() != OrderId("chemicalrage")
                    thisTrack.targetedAttack = false
                    thisTrack.target = null

    function getTarget() returns unit
        return this.target

    ondestroy
        this.trackTrigger.clearActions()
        this.trackTrigger.destr()
        attackTracks.remove(this)

class HeroInfernalMachine extends HeroTemplate
    use HeroTemplateModule
    constant MELEE = compiletime(UNIT_ID_GEN.next())
    static constant HERO_INFERNAL_MACHINE_MORPH = compiletime(HERO_ID_GEN.next())

    override function customDefintions(HeroDefinition def)
        new UnitDefinition(MELEE, 'hfoo')
            ..setNormalAbilities("Aloc")
            ..setModelFile("")
            ..setShadowImageUnit("")
            ..setAttacksEnabled(0)
            ..setMovementType(MovementType.Fly)
            ..setCollisionSize(0)
            ..setFoodCost(0)
            ..setSightRadiusDay(0)
            ..setSightRadiusNight(0)
            ..setUpgradesUsed("")
            ..setUnitSoundSet("")
            ..setName("Melee")

    override function objectDefinition()
            
    static constant real FIERY_HANDS_AOE = 250
    static constant real array FIERY_HANDS_DMG = [15, 25, 35, 45, 55]
    static constant real FIERY_HANDS_DMG_BONUS = 30


    override function setupPassive(int abilityId, IHeroType heroType)
        if compiletime
            createNoEffectAbiltiy(abilityId)
                ..setupWithHotKey("Fiery Hands", "D")
                ..setupIcon("PASFierySoul")

        let tooltip = new DynamicTooltip(abilityId)
        tooltip.setReplaceIntelligence(FIERY_HANDS_DMG_BONUS)
        tooltip.setLearnString("Killing a unit creates a fire explosion, dealing magic damage to nearby targets.", (int lvl) -> (begin
            return "{0}{I0} damage".format(FIERY_HANDS_DMG[lvl-1].str())
        end))
        for lvl = 1 to 5
            tooltip.setNormalString(false, lvl, "Killing a unit creates a fire explosion, dealing {0}{I0} magic damage to nearby targets.".format(
                FIERY_HANDS_DMG[lvl-1].str()
            ))
        addDynamicTooltipIntelligence(heroType, tooltip)

    static constant int array BASH_DAMAGE_BONUS = [50, 85, 120, 155, 190]
    static constant real array BASH_STUN_DURATION = [1.2, 1.4, 1.6, 1.8, 2]
    static constant real BASH_BUFF_DURATION = 4
    static constant int array BASH_MOVEMENT_SPEED = [100, 125, 150, 175, 200]

    static constant int BASH_BUFF_ID = compiletime(createAuraBuff("Bash", "This unit's movement speed is increased and its next attack will stun the opponent.", "BTNFistOfFire"))
    static constant int BASH_ABILITY_ID = compiletime(createPositiveBuffAbility(5, BASH_BUFF_ID, "", ""))

    static BuffType buffBash


    override function setupQ(int abilityId, IHeroType heroType)

        if compiletime
            let MANA = skillData(60, 60, 60, 60, 60)
            let COOLDOWN = skillData(9, 9, 9, 9, 9)

            let aDef = new AbilityDefinitionBeserk(abilityId)
                ..setupIcon("BTNFistOfFire")
                ..setAnimationNames("")
                ..setupWithHotKey("Bash", "Q")
                ..setLightningEffects("")
                ..setArtTarget("")
                ..setMissileArt("")
                ..setArtSpecial("")
                ..setLightningEffects("")
                ..setCheckDependencies(true)
                ..setRequirements(MELEE.toRawCode())
                ..targetSelf()
                ..setSkillData(COOLDOWN, MANA, 0)

            for lvl = 1 to 5
                aDef
                    ..setAttackSpeedIncrease(lvl, 0)
                    ..setDamageTakenIncrease(lvl, 0)
                    ..setMovementSpeedIncrease(lvl, 0)
                    ..setBuffs(lvl, BASH_BUFF_ID.toRawCode())
                    ..setDurationHero(lvl, 0.01)

        let tooltip = new DynamicTooltip(abilityId)
        tooltip.setReplaceIntelligence(0)
        tooltip.setLearnString("Increases the movement speed of the Infernal Machine and causes the next attack to stun the target and deal bonus damage. Lasts {0} seconds.".format(BASH_BUFF_DURATION.toSmartString()), (int lvl) -> (begin
            return "{0} bonus damage, {1} seconds stun.".format(
                BASH_DAMAGE_BONUS[lvl-1].str(), BASH_STUN_DURATION[lvl-1].toSmartString()
                )
        end) )
        for lvl = 1 to 5
            tooltip.setNormalString(true, lvl, "Increases the movement speed of the Infernal Machine and causes the next attack to stun the target for {0} seconds and deal {1} bonus bonus damage. Lasts {2} seconds.".format(
                BASH_STUN_DURATION[lvl-1].toSmartString(), BASH_DAMAGE_BONUS[lvl-1].str(), BASH_BUFF_DURATION.toSmartString()
            ))
        addDynamicTooltipIntelligence(heroType, tooltip)


    static constant int array INNER_FIRE_DMG = [10, 15, 20, 25, 30]
    static constant int INNER_FIRE_DMG_BONUS = 10

    static constant int array INNER_FIRE_DEF = [10, 15, 20, 25, 30]
    static constant int INNER_FIRE_DEF_BONUS = 20

    static constant real INNER_FIRE_DURATION = 12

    static constant int INNER_FIRE_BUFF_ID = compiletime(createAuraBuff("Inner Fire", "This unit's strength and armor and willpower are increased.", Icons.bTNInnerFire))
    static constant int INNER_FIRE_ABILITY_ID = compiletime(createPositiveBuffAbility(5, INNER_FIRE_BUFF_ID, Abilities.innerFireTarget, "overhead"))

    static constant real INNER_FIRE_AOE = 900

    static BuffType buffInnerFire


    override function setupW(int abilityId, IHeroType heroType)

        if compiletime
            let MANA = skillData(80, 85, 90, 95, 100)
            let COOLDOWN = skillData(19, 19, 19, 19, 19)

            new AbilityDefinitionRoar(abilityId)
                ..setAnimationNames("spell")
                ..setupIcon(Icons.bTNInnerFire)
                ..setupWithHotKey("Inner Fire", "W")
                ..targetNone()
                ..setSkillData(COOLDOWN, MANA, 0)


        let tooltip = new DynamicTooltip(abilityId)
        tooltip.setReplaceIntelligence(INNER_FIRE_DMG_BONUS.toReal(), INNER_FIRE_DEF_BONUS.toReal())
        tooltip.setLearnString("Increases nearby units strength, armor and willpower.", (int lvl) -> (begin
            return "+{0}{I0}% strength, +{1}{I1} armor and willpower, {2} seconds".format(
            INNER_FIRE_DMG[lvl-1].str(),
            INNER_FIRE_DEF[lvl-1].str(),
            INNER_FIRE_DURATION.toSmartString()
            )
        end) )
        for lvl = 1 to 5
            tooltip.setNormalString(true, lvl, "Increases nearby units' strength by {0}{I0}% and armor and willpower by {1}{I1} for {2} seconds.".format(
                INNER_FIRE_DMG[lvl-1].str(),
                INNER_FIRE_DEF[lvl-1].str(),
                INNER_FIRE_DURATION.toSmartString()
            ))
        addDynamicTooltipIntelligence(heroType, tooltip)
        setAnimationSpeed(abilityId, 2)

    static constant real array FLAME_THROWER_DAMAGE = [60, 90, 120, 150, 180]
    static constant real FLAME_THROWER_DAMAGE_BONUS = 100

    static constant real array FLAME_THROWER_DOT = [16, 24, 32, 40, 48]
    static constant real FLAME_THROWER_DOT_BONUS = 30

    static constant real array FLAME_THROWER_DURATION = [3, 3.5, 4, 4.5, 5]

    static constant real array FLAME_THROWER_AOE = [350, 350, 350, 350, 350]

    static constant int FLAME_THROWER_BUFF_ID = compiletime(createAuraBuff("Flame Thrower", "This unit was hit by Flame Thrower; it takes damage over time.", Icons.bTNWallOfFire))
    static constant int FLAME_THROWER_ABILTIY_ID = compiletime(createNegativeBuffAbility(5, FLAME_THROWER_BUFF_ID, Abilities.breathOfFireDamage, "origin"))

    static constant int FLAME_THROWER_ARTILLERY = compiletime(ArtilleryDetection.createArtilleryDummy(30, 20, 210, 2.5, Abilities.redDragonMissile, 900, 0.3))


    static BuffType buffFlameThrower



    override function setupE(int abilityId, IHeroType heroType)

        if compiletime
            let MANA = skillData(90, 100, 110, 120, 130)
            let COOLDOWN = skillData(11, 11, 11, 11, 11)
            let RANGE = skillData(900, 900, 900, 900, 900)

            let aDef = new AbilityDefinitionIllidanChannel(abilityId)
                ..setupIcon(Icons.bTNWallOfFire)
                ..setupWithHotKey("Flame Thrower", "E")
                ..setArtCaster("")
                ..setArtEffect("")
                ..setMissileArt("")
                ..setArtTarget("")
                ..setAnimationNames("spell,throw")
                ..setupChannel(TargetType.AREA, "shockwave", 0.5)
                ..setSkillData(COOLDOWN, MANA, RANGE)

            for lvl = 1 to 5
                aDef
                    ..setAreaofEffect(lvl, FLAME_THROWER_AOE[lvl-1])

        let tooltip = new DynamicTooltip(abilityId)
        tooltip.setReplaceIntelligence(FLAME_THROWER_DAMAGE_BONUS, FLAME_THROWER_DOT_BONUS)
        tooltip.setLearnString("Launches a fiery missile at the target location that deals large initial damage and ignites the targets, dealing additional damage over time.", (int lvl) -> (begin
            return "{0}{I0} initial damage, {1}{I1} damage per second for {2} seconds.".format(
                FLAME_THROWER_DAMAGE[lvl-1].str(),
                FLAME_THROWER_DOT[lvl-1].str(),
                FLAME_THROWER_DURATION[lvl-1].toSmartString()
            )
        end) )
        for lvl = 1 to 5
            tooltip.setNormalString(true, lvl, "Launches a fiery missile at the target location that deals {0}{I0} initial damage and ignites the targets, dealing {1}{I1} damage per second for {2} seconds.".format(
                FLAME_THROWER_DAMAGE[lvl-1].str(),
                FLAME_THROWER_DOT[lvl-1].str(),
                FLAME_THROWER_DURATION[lvl-1].toSmartString()
            ))
        addDynamicTooltipIntelligence(heroType, tooltip)
        setAnimationSpeed(abilityId, 2)

    static constant int array RAPID_FIRE_ATTACK_SPEED = [80, 120, 160, 200, 240]
    static constant real RAPID_FIRE_DURATION = 3
    static constant real array RAPID_FIRE_STUN_DURATION = [0.2, 0.2, 0.2, 0.2, 0.2]

    static constant int RAPID_FIRE_BUFF_ID = compiletime(createDummyBuff("Rapid Fire"))


    override function setupR(int abilityId, IHeroType heroType)

        if compiletime
            let MANA = skillData(150, 165, 180, 195, 210)
            let COOLDOWN = skillData(120, 120, 120, 120, 120)

            let aDef = new AbilityDefinitionAlchemistChemicalRage(abilityId)
                ..setupIcon(Icons.bTNHumanMissileUpThree)
                ..setupWithHotKey("Rapid Fire", "R")
                ..setSkillData(COOLDOWN, MANA, 0)

            for lvl = 1 to 5
                aDef
                    ..setNormalFormUnit(lvl, UNIT_ID_HERO.toRawCode())
                    ..setAlternateFormUnit(lvl, HERO_INFERNAL_MACHINE_MORPH.toRawCode())
                    ..setDurationNormal(lvl, 0)
                    ..setDurationHero(lvl, RAPID_FIRE_DURATION)
                    ..setAttackSpeedBonusInfoPanelOnly(lvl, 0.8)
                    ..setMoveSpeedBonusInfoPanelOnly(lvl, 0)
                    ..setBuffs(lvl, RAPID_FIRE_BUFF_ID.toRawCode())

        let tooltip = new DynamicTooltip(abilityId)
        tooltip.setReplaceIntelligence(0)
        tooltip.setLearnString("Enables a rapid firing ranged attack for the Infernal Machine, that stuns enemies it hits for a short time. Bash is disabled while under the effect of Rapid Fire.|nLasts {0} seconds.".format(RAPID_FIRE_DURATION.str()), (int lvl) -> (begin
            return "+{0}% attack speed, {1} stun duration.".format(
                RAPID_FIRE_ATTACK_SPEED[lvl-1].str(), RAPID_FIRE_STUN_DURATION[lvl-1].toSmartString()
            )
        end) )
        for lvl = 1 to 5
            tooltip.setNormalString(true, lvl, "Enables a rapid firing ranged attack with {0}% faster attack speed for the Infernal Machine, that stuns enemies it hits for {1} seconds. Bash is disabled while under the effect of Rapid Fire.|nLasts {2} seconds.".format(
                RAPID_FIRE_ATTACK_SPEED[lvl-1].str(), RAPID_FIRE_STUN_DURATION[lvl-1].toSmartString(), RAPID_FIRE_DURATION.str()
            ))
        addDynamicTooltipIntelligence(heroType, tooltip)

                
    static unit array melee_dummy

        
    override function castQ()
        let spellId = GetSpellAbilityId()
        let caster = GetTriggerUnit()
        let level = caster.getAbilityLevel(spellId)
        caster.addBuff(caster, 4, buffBash, level)

    override function castW()
        let spellId = GetSpellAbilityId()
        let caster = GetTriggerUnit()
        let level = caster.getAbilityLevel(spellId)
        let nearby = CreateGroup()
        nearby.enumUnitsInRange(caster.getPos(), INNER_FIRE_AOE)

        while not nearby.isEmpty()
            let target = FirstOfGroup(nearby)
            nearby.removeUnit(target)
            if not target.isType(UNIT_TYPE_STRUCTURE) and target.isTargetable(caster.getOwner(), true, false)
                target.addBuff( caster, INNER_FIRE_DURATION, buffInnerFire, level)

        nearby.destr()

    override function castE()
        let caster = GetTriggerUnit()
        ArtilleryDetection.fireArtillery(caster, FLAME_THROWER_ARTILLERY, caster.getPos(), vec2(GetSpellTargetX(), GetSpellTargetY())) (unit impact, unit caster, int data) ->
            let nearby = CreateGroup()
            let level = caster.getAbilityLevel(ABILITY_ID_E)
            nearby.enumUnitsInRange(impact.getPos(), FLAME_THROWER_AOE[level-1])

            
            var fx = new Fx(impact.getPos(), Abilities.liquidfire)
            fx.setScale(3.5)
            doAfter(1, () -> destroy fx)

            for i = 0 to 10
                fx = new Fx(impact.getPos().polarOffset(GetRandomDirectionDeg().fromDeg(), GetRandomReal(0, 300)), Abilities.flameStrikeEmbers)
                fx.setScale(2)
                doAfter(0.5, () -> destroy fx)
                

            let dmg = (FLAME_THROWER_DAMAGE[level-1]).bonus(caster.getHeroInt(), FLAME_THROWER_DAMAGE_BONUS)
            while not nearby.isEmpty()
                let target = FirstOfGroup(nearby)
                nearby.removeUnit(target)
                if not target.isType(UNIT_TYPE_STRUCTURE) and target.isTargetable(impact.getOwner(), false, true)

                    caster.dealDamage(target, dmg, ReductionType.MAGIC)
                    target.addBuffReduced(caster, FLAME_THROWER_DURATION[level-1], buffFlameThrower, level)

            nearby.destr()

            addEffect(Abilities.demolisherFireMissile, impact.getPos()).destr()

    static function onRapidStats(unit caster, int level) // add bonus
        caster.wrapper().modAttackSpeed( RAPID_FIRE_ATTACK_SPEED[level-1] - 80)
        caster.wrapper().modMoveSpeed( 0)

    static function onRapid(unit caster, int level) // add bonus
        doAfter(0, () -> (begin
            caster.toHero().morph()
            onRapidStats(caster, level)
            DamageEvent.useAlternate(caster, true)
            let track = AttackOrderTrack.getAttackTrack(caster)
            if track != null
                let target =track.getTarget()
                if target != null
                    caster.issueImmediateOrder("stop")
                    doAfter(0, () -> caster.issueTargetOrder("attack", target))
        end))
        melee_dummy[caster.getOwner().getId()].setOwner(Player(PLAYER_NEUTRAL_PASSIVE), false)
        if BuffList.hasBuffType(caster, buffBash)
            BuffList.getBuffOfType(caster, buffBash).dispel()

    static function onRapidEndStats(unit caster, int level) // remove bonus
        caster.wrapper().modAttackSpeed( -RAPID_FIRE_ATTACK_SPEED[level-1] + 80)
        caster.wrapper().modMoveSpeed( 0)


    static function onRapidEnd(unit caster, int level) // remove bonus
        doAfter(0, () -> (begin
            caster.toHero().morph()
            onRapidEndStats(caster, level)
            DamageEvent.useAlternate(caster, false)
        end))
        melee_dummy[caster.getOwner().getId()].setOwner(Player(caster.getOwner().getId()), false)

    override function castR()
        let spellId = GetSpellAbilityId()
        let caster = GetTriggerUnit()
        let level = caster.getAbilityLevel(spellId)
        if caster.getTypeId() == UNIT_ID_HERO
            doAfter( 0, () -> onRapid(caster, level))
        else
            doAfter( 0, () -> onRapidEnd(caster, level))


    override function stats(IHeroType heroType)
        heroType
        ..setStat(Stat.AR, 31, 59)
        ..setStat(Stat.AS, 7, 22)
        ..setStat(Stat.HP, 13, 52)
        ..setStat(Stat.HR, 17, 34)
        ..setStat(Stat.MP, 15, 41)
        ..setStat(Stat.MR, 13, 28)
        ..setStat(Stat.MS, 18, 41)
        ..setStat(Stat.STR, 17, 52)
        ..setStat(Stat.AGI, 30, 55)
        ..setStat(Stat.INT, 6, 16)




    override function retreatAI(IHeroAI ai)
        ai.issue("berserk")

    override function attackAI(IHeroAI ai)
        let hero = ai.getHeroUnit()

        if hero.getMana()/hero.getMaxMana() > 0.5
            let targetPos = hero.findAreaTarget(800, FLAME_THROWER_AOE[hero.getAbilityLevel(ABILITY_ID_E)-1], 3)
            if targetPos.getValue() >= 6
                ai.issue("shockwave", targetPos.getPos())

        unit target = hero.findTarget(250, AbilityTargetFocus.ENEMY, AbilityTargetPriority.LOW_HEALTH, null)
        if target.isTargetable(hero.getOwner(), false, true)
            ai.attack(target)

        target = hero.findTarget(500, AbilityTargetFocus.ENEMY, AbilityTargetPriority.LOW_DISTANCE, null)
        if target.isTargetable(hero.getOwner(), false, true)
            ai.attack(target)

    override function teamFightAI(IHeroAI ai)
        let hero = ai.getHeroUnit()

        let target = ai.getTeamFightTarget()


        if target.isTargetable(hero.getOwner(), false, true)

            if hero.getTypeId() == this.UNIT_ID_HERO
                if target.getPos().distanceTo(hero.getPos()) < 600
                    ai.issue("chemicalrage")
                    ai.issue("berserk")
                ai.issue("roar")
                ai.issue("shockwave", target.getPos())

            if not ai.getAttacking()
                ai.attack(target)


    override function skillBuild() returns string
        return "QEWQQWQEQWEWEWE"

    override function recommendedItems(LinkedList<int> list)
        list.add(ITEM_ID_BOOTS_BASE)

    override function onInitDelayed(IHeroType heroType)
        heroType.addMorph(HERO_INFERNAL_MACHINE_MORPH)
        heroType
        ..setOnAttackFunc() (unit source, unit target, DamageEventUnit sourceWrapper, DamageEventUnit targetWrapper, real damage, boolean attack, boolean active, boolean advanced) ->
            if target.isTargetable(source.getOwner(), false, true) and not target.isType(UNIT_TYPE_STRUCTURE)
                if source.getTypeId() == UNIT_ID_HERO and BuffList.hasBuffType(source, buffBash)
                    let bash = BuffList.getBuffOfType(source, buffBash)
                    target.addBuffReduced(source, BASH_STUN_DURATION[bash.getLevel()-1], STUNNED, 1).setDispelLevel(DispelLevel.DISPEL)
                    source.dealDamage(target, BASH_DAMAGE_BONUS[bash.getLevel()-1].toReal(), ReductionType.PHYSICAL)
                    bash.dispel()
                else if advanced
                    target.addBuffReduced(source, RAPID_FIRE_STUN_DURATION[source.getAbilityLevel(ABILITY_ID_R)-1], STUNNED, 1).setDispelLevel(DispelLevel.DISPEL)

        buffBash = new BuffType(true, DispelLevel.DISPEL)

        buffBash.setupBuffWithIcon(BASH_BUFF_ID, BASH_ABILITY_ID)
        buffBash.addLevelFunction() (Buff thisBuff, int factor) ->
            thisBuff.getTarget().wrapper().modMoveSpeed( factor * BASH_MOVEMENT_SPEED[thisBuff.getLevel()-1])

        buffInnerFire = new BuffType(true, DispelLevel.DISPEL)
        buffInnerFire.setupBuffWithIcon(INNER_FIRE_BUFF_ID, INNER_FIRE_ABILITY_ID)
        buffInnerFire.addLevelFunction() (Buff thisBuff, int factor) ->
            let level = thisBuff.getLevel()
            let wrapper = thisBuff.getTarget().wrapper()
            int intel
            if factor == 1
                intel = thisBuff.getCaster().getHeroInt()
                thisBuff.setData(intel)
            else
                intel = thisBuff.getData()
            wrapper.modStrengthRelative( factor * 10 * INNER_FIRE_DMG[level-1].bonus(intel, INNER_FIRE_DMG_BONUS).toInt() )
            wrapper.modArmor( factor * INNER_FIRE_DEF[level-1].bonus(intel, INNER_FIRE_DEF_BONUS).toInt() )
            wrapper.modWillpower( factor * INNER_FIRE_DEF[level-1].bonus(intel, INNER_FIRE_DEF_BONUS).toInt() )

        buffFlameThrower = new BuffType(false, DispelLevel.DISPEL)
        buffFlameThrower.setupBuffWithIcon(FLAME_THROWER_BUFF_ID, FLAME_THROWER_ABILTIY_ID)
        buffFlameThrower.setPeriodicTime(0.25)
        buffFlameThrower.addPeriodicFunction((Buff whichBuff) -> (begin
            let caster = whichBuff.getCaster()
            let target = whichBuff.getTarget()
            if target.isTargetable(caster.getOwner(), false, true)
                caster.dealDamage(target, 0.25 * FLAME_THROWER_DOT[whichBuff.getLevel()-1].bonus(caster.getHeroInt(), FLAME_THROWER_DOT_BONUS), ReductionType.MAGIC)
        end))


        CreateTrigger()
        ..registerAnyUnitEvent(EVENT_PLAYER_UNIT_DEATH)
        ..addAction(() -> (begin
            let killer = GetKillingUnit()
            let dyingUnit = GetTriggerUnit()
            if not dyingUnit.isType(UNIT_TYPE_STRUCTURE) and killer.hasAbility(HeroInfernalMachine.instance.ABILITY_ID_PASSIVE)
                addEffect(Abilities.fireLordDeathExplode, dyingUnit.getPos()).destr()
                let g = CreateGroup()
                g.enumUnitsInRange(dyingUnit.getPos(), FIERY_HANDS_AOE)
                let dmg = FIERY_HANDS_DMG[killer.getAbilityLevel(HeroInfernalMachine.instance.ABILITY_ID_PASSIVE)-1].bonus(killer.getHeroInt(), FIERY_HANDS_DMG_BONUS)
                for unit u in g
                    if not u.isType(UNIT_TYPE_STRUCTURE) and u.isTargetable(killer.getOwner(), false, true)
                        killer.dealDamage(u, dmg, ReductionType.MAGIC)
                g.destr()
        end))

            

    function createHeroType(IHero hero)
        let heroUnit = hero.toUnit()
        melee_dummy[heroUnit.getOwner().getId()] = createUnit(heroUnit.getOwner(), MELEE, heroUnit.getPos(), angle(0))
        new AttackOrderTrack(hero.toUnit())


        CreateTrigger()
        ..registerUnitEvent(heroUnit, EVENT_UNIT_DEATH)
        ..addAction(() -> (begin
            if GetTriggerUnit().getTypeId() == HERO_INFERNAL_MACHINE_MORPH
                let u = GetTriggerUnit()
                onRapidEnd(u, u.getAbilityLevel(HeroInfernalMachine.instance.ABILITY_ID_R))
        end))

        CreateTrigger()
        ..registerUnitEvent(heroUnit, EVENT_UNIT_HERO_SKILL)
        ..addAction(() -> (begin
            let u = GetTriggerUnit()

            if GetLearnedSkill() == HeroInfernalMachine.instance.ABILITY_ID_R and u.getTypeId() == HERO_INFERNAL_MACHINE_MORPH
                let newLevel = u.getAbilityLevel(HeroInfernalMachine.instance.ABILITY_ID_R)
                onRapidEndStats(u, newLevel - 1)
                onRapidStats(u, newLevel)
        end))

init
    initialize()
    
@compiletime
function initialize()
    HeroType.create(new HeroInfernalMachine(), HERO_ORDER)

   


