package IHeroAI

import UnitLib
import IHero
import LinkedList
import HeroAIImpl

public enum Lane
    TOP
    MID
    BOT

public enum AbilityTargetType
    INSTANT
    UNIT
    AREA
    LINE

public enum AbilityTargetFocus
    SELF
    ALLY_HERO
    ALLY_UNIT
    ALLY
    FRIEND_HERO
    FRIEND_UNIT
    FRIEND
    ENEMY_HERO
    ENEMY_UNIT
    ENEMY

public enum AbilityTargetPriority
    LOW_HEALTH
    LOW_DISTANCE
    HIGH_VALUE
    HIGH_HEALTH


public interface Filter
    function filter(unit u) returns boolean


public tuple targetPoint(vec2 pos, int value)

public function targetPoint.getValue() returns int
    return this.value

public function targetPoint.getPos() returns vec2
    return this.pos
    
public function unit.findAreaTarget(real range, real aoe, int heroValue) returns targetPoint
    int currentValue = 0

    let g = CreateGroup()
    let nearby = CreateGroup()
    let pos = this.getPos()

    let owner = this.getOwner()
    unit u
    g.enumUnitsInRange(pos, range)
    let targetUnit = g.getRandomUnit()
    let unitPos = targetUnit.getPos()
    if targetUnit != null
        if not targetUnit.isType(UNIT_TYPE_STRUCTURE) and targetUnit.isAlive() and targetUnit.isVisible(owner) and IsUnitEnemy(targetUnit, owner)
            nearby.enumUnitsInRange(unitPos, aoe)
            while(true)
                
                u = FirstOfGroup(nearby)
                if u == null
                    break
                nearby.removeUnit(u)
            
                if not u.isType(UNIT_TYPE_STRUCTURE) and u.isAlive() and u.isVisible(owner) and IsUnitEnemy(u, owner)
                    if u.isType(UNIT_TYPE_HERO)
                        currentValue += heroValue
                    else
                        currentValue++

    nearby.destr()
    g.destr()

    return targetPoint(unitPos, currentValue)



public function unit.findTarget(real range, AbilityTargetFocus focus, AbilityTargetPriority priority, Filter filter) returns unit
    let g = CreateGroup()
    let pos = this.getPos()

    real currentPrio = 0
    unit currentTarget = null
    real newPrio
    boolean valid

    unit u
    g.enumUnitsInRange(pos, range)
    while(true)
        u = FirstOfGroup(g)
        if u == null
            break
        g.removeUnit(u)
        newPrio = 0
        valid = false
        if not u.isType(UNIT_TYPE_STRUCTURE) and u.isAlive() and u.isVisible(this.getOwner())
            if focus == AbilityTargetFocus.ALLY_HERO and u.isType(UNIT_TYPE_HERO) and u.getOwner().isAllyOf(this.getOwner()) and u!=this
                valid = true
            else if focus == AbilityTargetFocus.ALLY_UNIT and not u.isType(UNIT_TYPE_HERO) and u.getOwner().isAllyOf(this.getOwner()) and u.getOwner() != this.getOwner()
                valid = true
            else if focus == AbilityTargetFocus.ALLY and u.getOwner().isAllyOf(this.getOwner()) and u.getOwner() != this.getOwner()
                valid = true
            else if focus == AbilityTargetFocus.FRIEND_HERO and u.isType(UNIT_TYPE_HERO) and (u.getOwner().isAllyOf(this.getOwner()) or u.getOwner() == this.getOwner())
                valid = true
            else if focus == AbilityTargetFocus.FRIEND_UNIT and not u.isType(UNIT_TYPE_HERO) and (u.getOwner().isAllyOf(this.getOwner()) or u.getOwner() == this.getOwner())
                valid = true
            else if focus == AbilityTargetFocus.FRIEND and (u.getOwner().isAllyOf(this.getOwner()) or u.getOwner() == this.getOwner())
                valid = true
            else if focus == AbilityTargetFocus.ENEMY_HERO and u.isType(UNIT_TYPE_HERO) and u.getOwner().isEnemyOf(this.getOwner()) and not u.isType(UNIT_TYPE_ANCIENT)
                valid = true            
            else if focus == AbilityTargetFocus.ENEMY_UNIT and not u.isType(UNIT_TYPE_HERO) and u.getOwner().isEnemyOf(this.getOwner()) and not u.isType(UNIT_TYPE_ANCIENT)
                valid = true
            else if focus == AbilityTargetFocus.ENEMY and u.getOwner().isEnemyOf(this.getOwner()) and not u.isType(UNIT_TYPE_ANCIENT)
                valid = true

        if filter != null
            valid = valid and filter.filter(u)

        if valid
            if priority == AbilityTargetPriority.LOW_HEALTH
                newPrio = 1/u.getHP()
            else if priority == AbilityTargetPriority.LOW_DISTANCE
                newPrio = 1/u.getPos().distanceTo(pos)
            else if priority == AbilityTargetPriority.HIGH_VALUE
                let uType = UnitType.get(u.getTypeId())
                if uType != null
                    newPrio = uType.getBounty().toReal()
                else
                    newPrio = 0
            else if priority == AbilityTargetPriority.HIGH_HEALTH
                newPrio = u.getHP()


        if newPrio > currentPrio
            currentTarget = u
            currentPrio = newPrio



        
    if filter != null
        destroy filter


    g.destr()
    return currentTarget

public interface IHeroAI
    function aiMessage(string _msg)
    function getHomeLoc() returns vec2
    function getTargetLoc() returns vec2
    function getOwningPlayer() returns player
    function getHero() returns IHero
    function getHeroUnit() returns unit
    function getCasting() returns boolean
    function getAttacking() returns boolean
    function getTeamFightLoc() returns vec2
    function getTeamFightTarget() returns unit
    function attackedByTower()
    function buyItems()
    function onDamage(real damage)
    function issue(string order) returns boolean
    function issue(string order, vec2 target) returns boolean
    function issue(string order, widget targetWidget) returns boolean
    function attack(widget targetWidget) returns boolean
    function togglePause()
    function addGold(int gold)

public function unit.toHeroAI() returns IHeroAI
    return HeroAIImpl.getAI(this)
public abstract class HeroAI
    static function getAiList(int i) returns LinkedList<IHeroAI>
        return HeroAIImpl.getAiList(i)
    static function create(IHero hero, aidifficulty diff) returns IHeroAI
        return new HeroAIImpl(hero, diff)
