package ItemConfiguration

import public LinkedList
import public ItemInShop
import public Icons
import ItemObjEditing
import HashMap
import public Execute
import public ItemIds
import public Assets
import public ObjectEditingPreset
import public ClosureTimers
import public AbilityObjEditing
import public HeroObjectEditing
import public Stats
import public UnitLib
//import public OnAttack
import public Buff
import public StandardBuffs
import public FastDamageEvent
import public DamageIds

interface ItemPickUp
    function onItemPickUp()

interface ItemDrop
    function onItemDrop()

interface ItemDropOrPickUp
    function dropOrPickUp(int factor)

public function getItemItem() returns item
    return ItemEffect.triggerItem

public function getItemItemType() returns int
    return ItemEffect.triggerItem.getTypeId()

public function getItemUnit() returns unit
    return ItemEffect.triggerUnit

public function getItemUnitWrapper() returns IUnit
    return ItemEffect.triggerWrapper

public function getItemSign() returns int
    return ItemEffect.inventoryChangeDirection

public class ItemEffect

    private int itemId

    protected static item triggerItem
    protected static unit triggerUnit
    protected static IUnit triggerWrapper
    protected static int inventoryChangeDirection

    private static constant itemIdToEffect = new HashMap<int, ItemEffect>
    private static trigger onItemPickUp = CreateTrigger()
    private static trigger onItemDrop = CreateTrigger()
    protected constant onPickUp = new LinkedList<ItemPickUp>
    protected constant onDrop = new LinkedList<ItemDrop>
    protected constant onDropOrPickUp = new LinkedList<ItemDropOrPickUp>
    private LinkedList<trigger> attachedTriggers = null

    private int useCount = 0

    construct(int itemId)
        this.itemId = itemId
        itemIdToEffect.put(itemId, this)

    static function retrieveItemEffect(int itemId) returns ItemEffect
        if itemIdToEffect.has(itemId)
            return itemIdToEffect.get(itemId)
        else
            return new ItemEffect(itemId)

    function attachTrigger(trigger trg) returns trigger
        if this.attachedTriggers == null
            this.attachedTriggers = new LinkedList<trigger>

        this.attachedTriggers.add(trg)
        return trg

    function enableEffect()
        if this.attachedTriggers != null
            for trg in this.attachedTriggers
                trg.enable()

    function disableEffect()
        if this.attachedTriggers != null
            for trg in this.attachedTriggers
                trg.disable()

    static function classInit()
        onItemPickUp = CreateTrigger()
            ..addAction(function onItemPickUp)
            ..registerAnyUnitEvent(EVENT_PLAYER_UNIT_PICKUP_ITEM)
        onItemDrop = CreateTrigger()
            ..addAction(function onItemDrop)
            ..registerAnyUnitEvent(EVENT_PLAYER_UNIT_DROP_ITEM)

    static function onItemPickUp()
        triggerItem = GetManipulatedItem()
        if itemIdToEffect.has(triggerItem.getTypeId())
            triggerUnit = GetTriggerUnit()
            triggerWrapper = triggerUnit.wrapper()
            inventoryChangeDirection = 1
            let itemType = itemIdToEffect.get(triggerItem.getTypeId())
            itemType.useCount++
            if itemType.useCount == 1
                itemType.enableEffect()
            for c in itemType.onPickUp
                c.onItemPickUp()
            for c in itemType.onDropOrPickUp
                c.dropOrPickUp(1)

    static function onItemDrop()
        triggerItem = GetManipulatedItem()
        if itemIdToEffect.has(triggerItem.getTypeId())
            triggerUnit = GetTriggerUnit()
            triggerWrapper = triggerUnit.wrapper()
            inventoryChangeDirection = -1
            let itemType = itemIdToEffect.get(triggerItem.getTypeId())
            itemType.useCount--
            if itemType.useCount == 0
                itemType.disableEffect()
            for c in itemType.onDrop
                c.onItemDrop()
            for c in itemType.onDropOrPickUp
                c.dropOrPickUp(-1)


int currentItemId
ItemEffect currentItemEffect
ItemDefinition currentItemDefinition
ItemInShop currentItemInShop

public function createItemEffectTrigger() returns trigger
    return currentItemEffect.attachTrigger(CreateTrigger())

public function onPickUp(ItemPickUp onPickUp)
    if compiletime
        return
        
    currentItemEffect.onPickUp.add(onPickUp)

public function onDrop(ItemDrop onDrop)
    if compiletime
        return

    currentItemEffect.onDrop.add(onDrop)

public function onEither(ItemDropOrPickUp onDropOrPickUp)
    if compiletime
        return

    currentItemEffect.onDropOrPickUp.add(onDropOrPickUp)

public function anyDamageFunction(DamageFunction f)
    anyDamageFunction(1, f)
public function anyDamageFunction(int factor, DamageFunction f)
    if isUnique()
        let u = DamageEventUnit.fromUnit(getItemUnit())
        if getItemSign() == 1
            u.saveIntSlow(factor * getItemItemType(), u.anyDamage.add(f))
        else
            u.anyDamage.remove(u.loadIntSlow(factor * getItemItemType()))

public function anyHitFunction(DamageFunction f)
    anyHitFunction(1, f)
public function anyHitFunction(int factor, DamageFunction f)
    if isUnique()
        let u = DamageEventUnit.fromUnit(getItemUnit())
        if getItemSign() == 1
            u.saveIntSlow(factor * getItemItemType(), u.anyHit.add(f))
        else
            u.anyHit.remove(u.loadIntSlow(factor * getItemItemType()))

public function attackDamageFunction(DamageFunction f)
    attackDamageFunction(1, f)
public function attackDamageFunction(int factor, DamageFunction f)
    if isUnique()
        let u = DamageEventUnit.fromUnit(getItemUnit())
        if getItemSign() == 1
            u.saveIntSlow(factor * getItemItemType(), u.attackDamageNoBuilding.add(f))
        else
            u.attackDamageNoBuilding.remove(u.loadIntSlow(factor * getItemItemType()))

public function attackHitFunction(DamageFunction f)
    attackHitFunction(1, f)
public function attackHitFunction(int factor, DamageFunction f)
    if isUnique()
        let u = DamageEventUnit.fromUnit(getItemUnit())
        if getItemSign() == 1
            u.saveIntSlow(factor * getItemItemType(), u.attackHitNoBuilding.add(f))
        else
            u.attackHitNoBuilding.remove(u.loadIntSlow(factor * getItemItemType()))

public function damageEventInt(int key)
    let u = DamageEventUnit.fromUnit(getItemUnit())
    u.saveIntFast(key, u.loadIntFast(key) + getItemSign())

public function modArmor(int modifier)
    getItemUnitWrapper().modArmor(modifier * getItemSign())
public function modAttackSpeed(int modifier)
    getItemUnitWrapper().modAttackSpeed(modifier * getItemSign())
public function modStrength(int modifier)
    getItemUnitWrapper().modStrength(modifier * getItemSign())
public function modWillpower(int modifier)
    getItemUnitWrapper().modWillpower(modifier * getItemSign())
public function modIntelligence(int modifier)
    getItemUnitWrapper().modIntelligence(modifier * getItemSign())
public function modMoveSpeed(int modifier)
    getItemUnitWrapper().modMoveSpeed(modifier * getItemSign())
public function modHealth(int modifier)
    getItemUnitWrapper().modHealth(modifier * getItemSign())
public function modMana(int modifier)
    getItemUnitWrapper().modMana(modifier * getItemSign())
public function modHealthRegen(int modifier)
    getItemUnitWrapper().modHealthRegen(modifier * getItemSign())
public function modManaRegen(int modifier)
    getItemUnitWrapper().modManaRegen(modifier * getItemSign())

public function modArmorRelative(int modifier)
    getItemUnitWrapper().modArmorRelative(modifier * getItemSign())
public function modStrengthRelative(int modifier)
    getItemUnitWrapper().modStrengthRelative(modifier * getItemSign())
public function modWillpowerRelative(int modifier)
    getItemUnitWrapper().modWillpowerRelative(modifier * getItemSign())
public function modIntelligenceRelative(int modifier)
    getItemUnitWrapper().modIntelligenceRelative(modifier * getItemSign())
public function modMoveSpeedRelative(int modifier)
    getItemUnitWrapper().modMoveSpeedRelative(modifier * getItemSign())
public function modHealthRelative(int modifier)
    getItemUnitWrapper().modHealthRelative(modifier * getItemSign())
public function modManaRelative(int modifier)
    getItemUnitWrapper().modManaRelative(modifier * getItemSign())
public function modHealthRegenRelative(int modifier)
    getItemUnitWrapper().modHealthRegenRelative(modifier * getItemSign())
public function modManaRegenRelative(int modifier)
    getItemUnitWrapper().modManaRegenRelative(modifier * getItemSign())

public function setupItem(int itemId, int category, int goldCost)
    if compiletime
        let iDef = getItemDefintion(itemId)
        iDef.setGoldCost(goldCost)
        currentItemDefinition = iDef
    else
        currentItemId = itemId
        currentItemInShop = ItemInShop.retrieveItemFromId(itemId)
        currentItemInShop.setupItem(category, iconFromItem(itemId), goldCost)
        currentItemEffect = ItemEffect.retrieveItemEffect(itemId)

public function setInfo(string name, string desc)
    if compiletime
        currentItemDefinition.setName(name)
        currentItemDefinition.setTooltipBasic(name)
        currentItemDefinition.setDescription(desc)
        currentItemDefinition.setTooltipExtended(desc)
    else
        currentItemInShop.setupStrings(name, desc)

public function setAbilities(vararg int ids)
    if compiletime
        let list = new LinkedList<int>
        for id in ids
            list.add(id)
        let result = list.joinBy((int i) -> i.toRawCode(), ",")
        currentItemDefinition.setAbilities(result)
        setCooldownGroup(result.substring(0, 4))
        currentItemDefinition.setActivelyUsed(true)
        destroy list

public function setCooldownGroup(int id)
    if compiletime
        currentItemDefinition.setCooldownGroup(id.toRawCode())

public function setCooldownGroup(string str)
    if compiletime
        currentItemDefinition.setCooldownGroup(str)

public function consumable(int charges)
    if compiletime
        currentItemDefinition.setPerishable(true)
        currentItemDefinition.setNumberofCharges(charges)

public function consumable()
    consumable(1)

public function addRequirement(int itemId)
    if not compiletime
        let child = ItemInShop.retrieveItemFromId(itemId)
        currentItemInShop.addRequirement(child)

//returns if the picked up item is the first of its type and if the dropped item is the last of its type
public function isUnique() returns boolean
    return getItemUnit().countItemsOfType(getItemItemType()) == 1

//returns if the the hero has not this item
public function hasNot(int itemTypeId) returns boolean
    return getItemUnit().countItemsOfType(itemTypeId) == 0

init
    ItemEffect.classInit()