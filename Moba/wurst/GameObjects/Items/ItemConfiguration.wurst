package ItemConfiguration

import public LinkedList
import public ItemInShop
import public Icons
import ItemObjEditing
import HashMap
import public Execute
import public ItemIdDefinitions
import public Assets
import public ObjectEditingPreset
import public ClosureTimers
import public AbilityObjEditing
import public HeroObjectEditing
import public Stats
import public UnitLib
//import public OnAttack
import public Buff
import public StandardBuffs
import public FastDamageEvent
import public DamageIds
import public UnitImpl
import public IUnit
import public ChannelTeleport
import public BuffTypeConfig
import public ItemBalance
import public Constants
import JItemUtils
import ErrorHandling
import GameTimer

class PassiveItemCooldownElement
    int itm
    real cd
    construct(int itm, real cd)
        this.itm = itm
        this.cd = cd

public class PassiveItemCooldown
    protected static constant table = InitHashtable()
    protected static constant ITEM_LOCKED_UNTIL = 0
    protected static constant ITEM_ABILITY_ID = 1
    protected static constant UNIT_NUM_LOCKS = 0
    protected static constant ITEM_TYPE_ABILITY_ID = 0

    protected static function lockItem(item itm, int abil, real cd)
        let h = itm.getHandleId()
        table.saveReal(h, ITEM_LOCKED_UNTIL, getElapsedGameTime() + cd)
        table.saveInt(h, ITEM_ABILITY_ID, abil)
        doAfter(cd + 1) ->
            checkLockItem(h)

    protected static function checkLockItem(int h) returns real
        if table.hasReal(h, 0)
            let lockedUntil = table.loadReal(h, ITEM_LOCKED_UNTIL)
            if lockedUntil < getElapsedGameTime()
                unlockItem(h)
                return -1
            return lockedUntil
        return -1

    protected static function unlockItem(int h)
        PassiveItemCooldown.table.flushChild(h)

    protected static function lockUnit(unit u, int itm, int abil, real cd)
        BlzStartUnitAbilityCooldown(u, abil, cd)

        let h = u.getHandleId()
        let current = table.hasReal(h, itm) ? table.loadReal(h, itm) : 0
        if current == 0.0 // previously no lock for this item type
            table.saveInt(h, UNIT_NUM_LOCKS, table.hasInt(h, UNIT_NUM_LOCKS) ? table.loadInt(h, UNIT_NUM_LOCKS) + 1 : 1)
        table.saveReal(h, itm, max(current, getElapsedGameTime() + cd))
        table.saveInt(itm, ITEM_TYPE_ABILITY_ID, abil)

        ItemEffect.doItemEvents = false
        for i = 0 to 5
            var itmInSlot = u.itemInSlot(i)
            if itmInSlot.getTypeId() == itm
                u.removeItem(itmInSlot)
                u.addItemHandleToSlot(itmInSlot, i)
                itmInSlot = u.itemInSlot(i)
                lockItem(itmInSlot, abil, cd)
        ItemEffect.doItemEvents = true

        doAfter(cd + 1) -> 
            checkLockUnit(h, itm)


    protected static function checkLockUnit(int h, int itm) returns real
        if table.hasReal(h, itm)
            let lockedUntil = table.loadReal(h, itm)
            if lockedUntil < getElapsedGameTime()
                unlockUnit(h, itm)
                return -1
            return lockedUntil
        return -1

    protected static function unlockUnit(int h, int itm)
        table.removeReal(h, itm)
        let locks = table.loadInt(h, UNIT_NUM_LOCKS)
        if locks == 1
            table.flushChild(h)
        else
            table.saveInt(h, UNIT_NUM_LOCKS, locks - 1)

    static function tryStartCooldown(unit u, int itm, int abil, real cd) returns bool
        if u.getAbilityCooldownRemaining(abil) == 0.0
            lockUnit(u, itm, abil, cd)
            return true
        return false

public function generateCooldownAbility() returns int
    let id = ABIL_ID_GEN.next()
    new AbilityDefinitionAnimateDead(id)
    return id

public class IntToTrigger
    trigger trg
    construct()
        this.trg = CreateTrigger()

    ondestroy
        this.trg.destr()

interface ItemDropOrPickUp
    function dropOrPickUp(int factor)

public function getItemItem() returns item
    return ItemEffect.triggerItem

public function getItemItemType() returns int
    return ItemEffect.triggerItem.getTypeId()

public function getItemUnit() returns unit
    return ItemEffect.triggerUnit

public function getItemUnitWrapper() returns IUnit
    return ItemEffect.triggerWrapper

public function getItemSign() returns int
    return ItemEffect.inventoryChangeDirection

public class ItemEffect

    private int itemId

    protected static constant tomeToStat = new HashMap<int,Stat>()
    protected static constant tomeToValue = new HashMap<int,int>()

    protected static bool doItemEvents = true

    protected static item triggerItem
    protected static unit triggerUnit
    protected static IUnit triggerWrapper
    protected static int inventoryChangeDirection

    private static constant itemIdToEffect = new HashMap<int, ItemEffect>
    private static trigger onItemPickUp = CreateTrigger()
    private static trigger onItemDrop = CreateTrigger()
    protected ItemDropOrPickUp onDropOrPickUp = null

    private int useCount = 0

    construct(int itemId)
        this.itemId = itemId
        itemIdToEffect.put(itemId, this)

    static function retrieveItemEffect(int itemId) returns ItemEffect
        if itemIdToEffect.has(itemId)
            return itemIdToEffect.get(itemId)
        else
            return new ItemEffect(itemId)


    static function classInit()
        onItemPickUp = CreateTrigger()
            ..addAction(function onItemPickUp)
            ..registerAnyUnitEvent(EVENT_PLAYER_UNIT_PICKUP_ITEM)
        onItemDrop = CreateTrigger()
            ..addAction(function onItemDrop)
            ..registerAnyUnitEvent(EVENT_PLAYER_UNIT_DROP_ITEM)

    static function onItemPickUp()
        triggerItem = GetManipulatedItem()
        let itemTypeId = triggerItem.getTypeId()
        triggerUnit = GetTriggerUnit()
        // item is locked
        let itemHandleId = triggerItem.getHandleId()
        let lockedUntilItem = PassiveItemCooldown.checkLockItem(itemHandleId)
            
        // hero is locked for item type
        let unitHandleId = triggerUnit.getHandleId()
        let lockedUntilUnit = PassiveItemCooldown.checkLockUnit(unitHandleId, itemTypeId)

        if lockedUntilItem > lockedUntilUnit and lockedUntilItem >= 0
            let abil = PassiveItemCooldown.table.loadInt(itemHandleId, PassiveItemCooldown.ITEM_ABILITY_ID)
            let cd = lockedUntilItem - getElapsedGameTime()
            // the item is locked, but the unit x item type may not be locked yet
            PassiveItemCooldown.lockUnit(triggerUnit, itemTypeId, abil, cd)
        else if lockedUntilUnit >= 0
            let abil = PassiveItemCooldown.table.loadInt(itemTypeId, PassiveItemCooldown.ITEM_TYPE_ABILITY_ID)
            let cd = lockedUntilUnit - getElapsedGameTime()
            // the unit x item type is locked, but the item may not be locked yet
            PassiveItemCooldown.lockItem(triggerItem, abil, cd)
            BlzStartUnitAbilityCooldown(triggerUnit, abil, cd)

        if doItemEvents
            if itemIdToEffect.has(itemTypeId)
                triggerWrapper = triggerUnit.wrapper()
                inventoryChangeDirection = 1
                let itemType = itemIdToEffect.get(itemTypeId)
                itemType.useCount++
                if itemType.onDropOrPickUp != null
                    itemType.onDropOrPickUp.dropOrPickUp(1)

    static function onItemDrop()
        if doItemEvents
            triggerItem = GetManipulatedItem()
            if itemIdToEffect.has(triggerItem.getTypeId())
                triggerUnit = GetTriggerUnit()
                triggerWrapper = triggerUnit.wrapper()
                inventoryChangeDirection = -1
                let itemType = itemIdToEffect.get(triggerItem.getTypeId())
                itemType.useCount--
                if itemType.onDropOrPickUp != null
                    itemType.onDropOrPickUp.dropOrPickUp(-1)


int currentItemId
string currentDescription = ""
ItemEffect currentItemEffect
ItemDefinition currentItemDefinition
ItemInShop currentItemInShop


public function onEither(ItemDropOrPickUp onDropOrPickUp)
    if compiletime
        return
    if currentItemEffect.onDropOrPickUp != null
        error("The item already has an effect!")
    currentItemEffect.onDropOrPickUp = onDropOrPickUp

/**
Adds a trigger which is active while the item is carried by the hero.
The trigger is returned only if the item is unique and the item was picked up.
Check if the trigger is null:

onEither() (int factor) ->
    let trg = itemTrigger()
    if trg != null
        trg.register...
        trg.addAction...
        ...
**/
public function itemTrigger() returns trigger
    return itemTrigger(1)

public function itemTrigger(int factor) returns trigger
    if isUnique()
        if getItemSign() == 1
            let trg = new IntToTrigger()
            DamageEventUnit.fromUnit(getItemUnit()).saveIntSlow(factor * getItemItemType(), trg castTo int)
            return trg.trg
        else
            destroy DamageEventUnit.fromUnit(getItemUnit()).loadIntSlow(factor * getItemItemType()) castTo IntToTrigger
            return null
    return null

public function anyDamageFunction(DamageFunction f)
    anyDamageFunction(1, f)
public function anyDamageFunction(int factor, DamageFunction f)
    if isUnique()
        let u = DamageEventUnit.fromUnit(getItemUnit())
        if getItemSign() == 1
            u.saveIntSlow(factor * getItemItemType(), u.anyDamage.add(f))
        else
            u.anyDamage.remove(u.loadIntSlow(factor * getItemItemType()))

public function anyHitFunction(DamageFunction f)
    anyHitFunction(1, f)
public function anyHitFunction(int factor, DamageFunction f)
    if isUnique()
        let u = DamageEventUnit.fromUnit(getItemUnit())
        if getItemSign() == 1
            u.saveIntSlow(factor * getItemItemType(), u.anyHit.add(f))
        else
            u.anyHit.remove(u.loadIntSlow(factor * getItemItemType()))

public function attackDamageFunction(DamageFunction f)
    attackDamageFunction(1, f)
public function attackDamageFunction(int factor, DamageFunction f)
    if isUnique()
        let u = DamageEventUnit.fromUnit(getItemUnit())
        if getItemSign() == 1
            u.saveIntSlow(factor * getItemItemType(), u.attackDamageNoBuilding.add(f))
        else
            u.attackDamageNoBuilding.remove(u.loadIntSlow(factor * getItemItemType()))

public function attackHitFunction(DamageFunction f)
    attackHitFunction(1, f)
public function attackHitFunction(int factor, DamageFunction f)
    if isUnique()
        let u = DamageEventUnit.fromUnit(getItemUnit())
        if getItemSign() == 1
            u.saveIntSlow(factor * getItemItemType(), u.attackHitNoBuilding.add(f))
        else
            u.attackHitNoBuilding.remove(u.loadIntSlow(factor * getItemItemType()))

public function damageEventInt(int key)
    let u = DamageEventUnit.fromUnit(getItemUnit())
    u.saveIntFast(key, u.loadIntFast(key) + getItemSign())

public function modArmor(int modifier)
    getItemUnitWrapper().modArmor(modifier * getItemSign())
public function modAttackSpeed(int modifier)
    getItemUnitWrapper().modAttackSpeed(modifier * getItemSign())
public function modStrength(int modifier)
    getItemUnitWrapper().modStrength(modifier * getItemSign())
public function modWillpower(int modifier)
    getItemUnitWrapper().modWillpower(modifier * getItemSign())
public function modIntelligence(int modifier)
    getItemUnitWrapper().modIntelligence(modifier * getItemSign())
public function modMoveSpeed(int modifier)
    getItemUnitWrapper().modMoveSpeed(modifier * getItemSign())
public function modHealth(int modifier)
    getItemUnitWrapper().modHealth(modifier * getItemSign())
public function modMana(int modifier)
    getItemUnitWrapper().modMana(modifier * getItemSign())
public function modHealthRegen(int modifier)
    getItemUnitWrapper().modHealthRegen(modifier * getItemSign())
public function modManaRegen(int modifier)
    getItemUnitWrapper().modManaRegen(modifier * getItemSign())
public function modCooldown(int modifier)
    getItemUnitWrapper().modCooldown(modifier * getItemSign())

public function modArmorRelative(int modifier)
    getItemUnitWrapper().modArmorRelative(modifier * getItemSign())
public function modStrengthRelative(int modifier)
    getItemUnitWrapper().modStrengthRelative(modifier * getItemSign())
public function modWillpowerRelative(int modifier)
    getItemUnitWrapper().modWillpowerRelative(modifier * getItemSign())
public function modIntelligenceRelative(int modifier)
    getItemUnitWrapper().modIntelligenceRelative(modifier * getItemSign())
public function modMoveSpeedRelative(int modifier)
    getItemUnitWrapper().modMoveSpeedRelative(modifier * getItemSign())
public function modHealthRelative(int modifier)
    getItemUnitWrapper().modHealthRelative(modifier * getItemSign())
public function modManaRelative(int modifier)
    getItemUnitWrapper().modManaRelative(modifier * getItemSign())
public function modHealthRegenRelative(int modifier)
    getItemUnitWrapper().modHealthRegenRelative(modifier * getItemSign())
public function modManaRegenRelative(int modifier)
    getItemUnitWrapper().modManaRegenRelative(modifier * getItemSign())

public function setupItem(int itemId, int category, int goldCost)
    if compiletime
        let iDef = getItemDefintion(itemId)
        iDef.setGoldCost(goldCost)
        currentItemDefinition = iDef
    else
        currentItemId = itemId
        currentItemInShop = ItemInShop.retrieveItemFromId(itemId)
        currentItemInShop.setupItem(category, goldCost)
        currentItemEffect = ItemEffect.retrieveItemEffect(itemId)

public function setInfo(string name, string desc)
    if compiletime
        currentItemDefinition.setName(name)
        currentItemDefinition.setTooltipBasic(name)
        currentItemDefinition.setDescription(desc)
        currentItemDefinition.setTooltipExtended(desc)
    else
        currentItemInShop.setupStrings(name, desc)

public function setInfo(string name)
    setInfo(name, currentDescription)
    currentDescription = ""

public function addLine(string text)
    currentDescription += text + "|n"
public function addText(string text)
    currentDescription += text
public function addPassive(string name, string desc)
    currentDescription += COLOR_GOLD.toColorString() + name + ":|r|n" + desc + "|n"
public function addUnique(string desc)
    currentDescription += COLOR_GOLD.toColorString() + "Unique:|r|n" + desc + "|n"
public function addActive(string name, string desc)
    currentDescription += COLOR_GOLD.toColorString() + name + " (Active):|r|n" + desc + "|n"

public function setPassiveAbility(int id)
    if compiletime
        currentItemDefinition.setAbilities(id.toRawCode())
        currentItemDefinition.setActivelyUsed(false)
        setCooldownGroup(id)

public function setAbilities(vararg int ids)
    if compiletime
        let list = new LinkedList<int>
        for id in ids
            list.add(id)
        let result = list.joinBy((int i) -> i.toRawCode(), ",")
        currentItemDefinition.setAbilities(result)
        setCooldownGroup(result.substring(0, 4))
        currentItemDefinition.setActivelyUsed(true)
        destroy list

public function setCooldownGroup(int id)
    if compiletime
        currentItemDefinition.setCooldownGroup(id.toRawCode())

public function setCooldownGroup(string str)
    if compiletime
        currentItemDefinition.setCooldownGroup(str)

public function consumable(int charges)
    if compiletime
        currentItemDefinition.setPerishable(true)
        currentItemDefinition.setNumberofCharges(charges)

public function consumable()
    consumable(1)

public function addRequirement(int itemId)
    if not compiletime
        let child = ItemInShop.retrieveItemFromId(itemId)
        currentItemInShop.addRequirement(child)

public function tomeModStat(Stat whichStat, int modValue)
    if not compiletime
        let itemTypeId = currentItemInShop.getItemId()
        ItemEffect.tomeToStat.put(itemTypeId, whichStat)
        ItemEffect.tomeToValue.put(itemTypeId, modValue)
    else
        currentItemDefinition.setClassification("PowerUp")

public function onTomePickUp(unit hero, int itemTypeId)
    if ItemEffect.tomeToStat.has(itemTypeId)
        hero.wrapper().modStatDispatch(ItemEffect.tomeToStat.get(itemTypeId), ItemEffect.tomeToValue.get(itemTypeId))

//returns if the picked up item is the first of its type and if the dropped item is the last of its type
public function isUnique() returns boolean
    return getItemUnit().countItemsOfType(getItemItemType()) == 1

//returns if the the hero has not this item
public function hasNot(int itemTypeId) returns boolean
    return getItemUnit().countItemsOfType(itemTypeId) == 0

public function isUniqueExt(vararg int itemTypeIds) returns boolean
    let u = getItemUnit()
    int sum = 0
    for int id in itemTypeIds
        sum += u.countItemsOfType(id)
    return sum == 1

public function isFirstBoots() returns bool
    return isUniqueExt(ITEM_ID_BOOTS_BASE, ITEM_ID_BOOTS_GUARDIAN, ITEM_ID_BOOTS_HUNTER, ITEM_ID_BOOTS_RUNNER, ITEM_ID_BOOTS_WIZARD)

init
    ItemEffect.classInit()
    /*
    Drop items before the unit wrapper is destroyed.
    The item drop event for removed units happens after the unit removal event, so if there are still items left when the unit wrapper is destroyed, the onDrop functions can no longer access the unit wrapper. To fix this, all items are dropped before the unit wrapper is destroyed.
    */
    addPreDestroyEvent() (unit u, IUnit iUnit) ->
        for i = 0 to u.inventorySize() - 1
            let itm = u.itemInSlot(i)
            if itm != null
                itm.remove()
