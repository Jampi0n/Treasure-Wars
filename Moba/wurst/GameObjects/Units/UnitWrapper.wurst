package UnitWrapper

import UnitIndexer
import HashMap
import Buff
import Constants
import Upgrades
import initlater HeroControl
import PlayerControl
import ErrorHandling
import LinkedList
import ObjectIds
import TeamUtil
import BuffTypeConfig
import ItemIds
import Execute
import Missile
import AbilityScaling
import Assets
import StandardTextTags

import public BonusMod

public constant DEFAULT_HERO_SPEED = 270.0

public interface CalculateTotalBonus
    function calculate(UnitWrapper whichWrapper, Stat whichStat)


public function createUnitType(int baseHp, int unitId, int bounty, int baseAttack, int upgradeAttack, int attackUpgradeId, int baseArmor, int upgradeArmor, int armorUpgradeId, int hitBox, string modelPath, int powerLevel) returns int
    new UnitType(baseHp, unitId, bounty, baseAttack, upgradeAttack, attackUpgradeId, baseArmor, upgradeArmor, armorUpgradeId, hitBox, modelPath, powerLevel)
    return unitId

public function createUnitType(int baseHp, int unitId, int bounty, int baseAttack, int baseArmor, int hitBox, string modelPath, int powerLevel) returns int
    new UnitType(baseHp, unitId, bounty, baseAttack, 0, 0, baseArmor, 0, 0, hitBox, modelPath, powerLevel)
    return unitId

public function createUnitType(int unitId) returns int
    new UnitType(100, unitId, 0, 0, 0, 0, 0, 0, 0, 32, "", 0)
    return unitId

public class UnitType

    private static constant unitIdToUnitType = new HashMap<int, UnitType>

    private int unitId
    private int bounty

    private int baseAttack
    private int baseArmor
    private int baseHp

    private int upgradeAttack
    private int upgradeArmor

    private int attackUpgradeId
    private int armorUpgradeId

    private int hitBox

    private int powerLevel // used instead of the actual unit level, so creeps can have level 0 and have green camp icons.

    private string modelPath

    construct(int baseHp, int unitId, int bounty, int baseAttack, int upgradeAttack, int attackUpgradeId, int baseArmor, int upgradeArmor, int armorUpgradeId, int hitBox, string modelPath, int powerLevel)
        this.setup(baseHp, unitId, bounty, baseAttack, upgradeAttack, attackUpgradeId, baseArmor, upgradeArmor, armorUpgradeId, hitBox, modelPath, powerLevel)

    private function setup(int baseHp, int unitId, int bounty, int baseAttack, int upgradeAttack, int attackUpgradeId, int baseArmor, int upgradeArmor, int armorUpgradeId, int hitBox, string modelPath, int powerLevel)
        objectCount++
        this.unitId = unitId
        this.bounty = bounty
        this.baseAttack = baseAttack
        this.upgradeAttack = upgradeAttack
        this.attackUpgradeId = attackUpgradeId
        this.upgradeArmor = upgradeArmor
        this.armorUpgradeId = armorUpgradeId
        this.baseArmor = baseArmor
        this.baseHp = baseHp
        this.hitBox = hitBox
        this.modelPath = modelPath
        this.powerLevel = powerLevel
        unitIdToUnitType.put(unitId, this)

    static function getUnitType(int unitId) returns UnitType
        return unitIdToUnitType.get(unitId)

    function getUnitId() returns int
        return this.unitId

    function getBounty() returns int
        return this.bounty

    function getBaseAttack() returns int
        return this.baseAttack

    function getBaseArmor() returns int
        return this.baseArmor

    function getBaseHp() returns int
        return this.baseHp

    function getPowerLevel() returns int
        return this.powerLevel


    function getUpgradeAttack(player owner) returns int
        if this.upgradeAttack != 0
            return this.upgradeAttack * GetPlayerTechCount(owner, this.attackUpgradeId, true)
        else
            return 0

    function getUpgradeArmorCount(player owner) returns int
        return GetPlayerTechCount(owner, this.armorUpgradeId, true)

    function getUpgradeArmor(player owner) returns int
        if this.upgradeArmor != 0
            return this.upgradeArmor * GetPlayerTechCount(owner, this.armorUpgradeId, true)
        else
            return 0

    function getHitBox() returns int
        return this.hitBox

    function getModel() returns string
        return this.modelPath

function onUnitDeath()
    let dyingUnit = GetTriggerUnit()
    let dyingType = UnitType.getUnitType(dyingUnit.getTypeId())

    if dyingType != null

        
        let killingUnit = GetKillingUnit()
        let killingId = killingUnit.getOwner().getId()
        let dyingId = dyingUnit.getOwner().getId()
        let dyingTeam = Players.team(dyingId)
        let pos = dyingUnit.getPos()

        // army unit dies
        if dyingTeam == TEAM_1 or dyingTeam == TEAM_2
            let bounty = dyingType.getBounty()
            let xp = dyingType.getPowerLevel() * 8.0

            let killerIsEnemy = killingUnit != null and Players.team(killingId) == Teams.invert(dyingTeam)
            int killerIsHero = 0
            //the killing player belongs to the enemy team
            if killerIsEnemy and killingId < MAX_HERO_COUNT 
                killerIsHero = 1

            // gold
            if killerIsEnemy and killerIsHero == 1
                PlayerWrapper.addGoldEx(killingId, bounty)
                PlayerWrapper.addUnitKill(killingId)
                
                addEffect(UI.goldCredit, pos).destr()

                createGoldBountyTextTag(dyingUnit, bounty, players[killingId])

            //xp
            if killerIsHero == 1 or not killingUnit.isType(UNIT_TYPE_STRUCTURE)
                Teams.rewardXp(Teams.invert(dyingTeam), pos, xp)

/**
    Every unit gets a unit wrapper

    Contains functionality every unit needs in one place, so only one HashMap is needed.
**/
public class UnitWrapper

    private CalculateTotalBonus bonusCalculation = null

    protected static unit array allUnits
    protected static int unitWrapperCount = 0

    protected int index

    private static constant unitMap = new HashMap<unit, UnitWrapper>()
    private unit assocUnit
    private int ownerId

    //protected real currentMovementSpeed
    //protected real defaultMovementSpeed

    private static int array statBaseValue_static
    private static int array statsAbsoluteBonus_static //default = 0
    private static int array statsAbsoluteBonusReal_static //default = 0
    private static int array statsRelativeBonus_static //default = 0.00

    int arrayOffset

    /*
        Use integer to avoid rounding errors. 1000 means 100% or 1
    */
    static int array statsTotalBonus_static //default = 0
    // total = (base + absolute) * (1 + relative/1000)

    private static constant unknownUnitTypes = new LinkedList<int>()

    protected BuffList buffList

    private int blueCount = 0
    private int revealCount = 0

    private int team

    /*
        In the getWrapper() function, a new wrapper will be created, if it does not exist already.
        To prevent cyclic function calls this is done with a trigger function.
    */
    private static constant CREATE_TRIGGER = CreateTrigger()..addAction(function createWrapper)
    private static unit createForUnit = null

    static function create(unit assocUnit)
        if not unitMap.has(assocUnit)
            new UnitWrapper(assocUnit)

    construct(unit assocUnit)
        objectCount++
        if assocUnit == null or assocUnit.getTypeId() == 0
            destroy this
        else
            this.ownerId = assocUnit.getOwner().getId()
            this.assocUnit = assocUnit
            this.team = Players.team(this.ownerId)
            this.arrayOffset = (this castTo int) * STAT_COUNT

            allUnits[unitWrapperCount] = this.assocUnit
            this.index = unitWrapperCount
            unitWrapperCount++


            unitMap.put(assocUnit, this)

            this.buffList = null // new BuffList  create BuffList only when needed

            for int i = 0 to STAT_COUNT-1
                statsAbsoluteBonus_static[this.arrayOffset + i] = 0
                statsAbsoluteBonusReal_static[this.arrayOffset + i] = 0
                statsRelativeBonus_static[this.arrayOffset + i] = 0
                statsTotalBonus_static[this.arrayOffset + i] = 0

            // Init base values
            statBaseValue_static[this.arrayOffset + Stat.MS.toInt()] = GetUnitDefaultMoveSpeed(this.assocUnit).toInt()
            statBaseValue_static[this.arrayOffset + Stat.STR.toInt()] = this.assocUnit.getStr(false)
            statBaseValue_static[this.arrayOffset + Stat.AGI.toInt()] = this.assocUnit.getAgi(false)
            statBaseValue_static[this.arrayOffset + Stat.INT.toInt()] = this.assocUnit.getInt(false)
            statBaseValue_static[this.arrayOffset + Stat.AR.toInt()] = this.assocUnit.getArmor().toInt()
            statBaseValue_static[this.arrayOffset + Stat.AD.toInt()] = 0 // strength
            statBaseValue_static[this.arrayOffset + Stat.AS.toInt()] = 0 //not needed as only absolute bonus will be used
            statBaseValue_static[this.arrayOffset + Stat.HR.toInt()] = 0
            statBaseValue_static[this.arrayOffset + Stat.MR.toInt()] = 0
            statBaseValue_static[this.arrayOffset + Stat.HP.toInt()] = this.assocUnit.getMaxHP().toInt()
            statBaseValue_static[this.arrayOffset + Stat.MP.toInt()] = this.assocUnit.getMaxMana().toInt()
            statBaseValue_static[this.arrayOffset + Stat.CD.toInt()] = 0

            let uType = UnitType.getUnitType(this.assocUnit.getTypeId())

            if uType != null
                updateBaseStatsUnits()
            else if this.assocUnit.isType(UNIT_TYPE_HERO)
                statBaseValue_static[this.arrayOffset + Stat.AD.toInt()] = statBaseValue_static[this.arrayOffset + Stat.STR.toInt()]
                statBaseValue_static[this.arrayOffset + Stat.AR.toInt()] = 0
            else
                if not this.assocUnit.isType(UNIT_TYPE_STRUCTURE)
                    if this.assocUnit.getAbilityLevel('Aloc') == 0
                        if not unknownUnitTypes.has(this.assocUnit.getTypeId())
                            unknownUnitTypes.add(this.assocUnit.getTypeId())
                            Log.warn("Warning unknown unit type: ("+GetUnitName(this.assocUnit) + ")_" + this.assocUnit.getTypeId().toRawCode() + "_" + this.assocUnit.getTypeId().toString())

    function updateBaseStatsUnits()
        let uType = UnitType.getUnitType(this.assocUnit.getTypeId())
        if uType != null
            statBaseValue_static[this.arrayOffset + Stat.STR.toInt()] = uType.getBaseAttack() + uType.getUpgradeAttack(this.assocUnit.getOwner())
            statBaseValue_static[this.arrayOffset + Stat.AR.toInt()] = uType.getBaseArmor() + uType.getUpgradeArmor(this.assocUnit.getOwner())
            statBaseValue_static[this.arrayOffset + Stat.HP.toInt()] = uType.getBaseHp() //(uType.getBaseHp() * ( 1 + 0.1 * uType.getUpgradeArmorCount(this.assocUnit.getOwner()))).round()
            //willpower is same as armor
            statBaseValue_static[this.arrayOffset + Stat.AGI.toInt()] = uType.getBaseArmor() + uType.getUpgradeArmor(this.assocUnit.getOwner())
            this.addStatAbsoluteBonus(Stat.HP, 0)

    function updateBaseStatsHero()
        if not this.assocUnit.isType(UNIT_TYPE_HERO)
            Log.warn("Base stats for non-hero units are constant and must not be updated.")
        statBaseValue_static[this.arrayOffset + Stat.STR.toInt()] = this.assocUnit.getStr(false)
        statBaseValue_static[this.arrayOffset + Stat.AGI.toInt()] = this.assocUnit.getAgi(false)
        statBaseValue_static[this.arrayOffset + Stat.INT.toInt()] = this.assocUnit.getInt(false)

        statBaseValue_static[this.arrayOffset + Stat.AD.toInt()] = 0
        statBaseValue_static[this.arrayOffset + Stat.AR.toInt()] = GetPlayerTechCount(this.assocUnit.getOwner(), UPG_AR, true)
        statBaseValue_static[this.arrayOffset + Stat.AS.toInt()] = 0
        
        statBaseValue_static[this.arrayOffset + Stat.HP.toInt()] = 400 + GetPlayerTechCount(this.assocUnit.getOwner(), UPG_HP, true) * 15
        statBaseValue_static[this.arrayOffset + Stat.HR.toInt()] = 0
        
        statBaseValue_static[this.arrayOffset + Stat.MP.toInt()] = 100 + GetPlayerTechCount(this.assocUnit.getOwner(), UPG_MP, true) * 10
        statBaseValue_static[this.arrayOffset + Stat.MR.toInt()] = 0
        //statBaseValue[Stat.MS.toInt()] = this.defaultMovementSpeed.toInt()
        statBaseValue_static[this.arrayOffset + Stat.CD.toInt()] = 0
    
    ondestroy
        objectCount--
        for int i = 0 to STAT_COUNT-1
            statsAbsoluteBonus_static[this.arrayOffset + i] = 0
            statsRelativeBonus_static[this.arrayOffset + i] = 0
            statsTotalBonus_static[this.arrayOffset + i] = 0

    private static function createWrapper()
        new UnitWrapper(createForUnit)

    protected static function getWrapper(unit whichUnit) returns UnitWrapper
        let w = unitMap.get(whichUnit)
        if w == null
            createForUnit = whichUnit
            CREATE_TRIGGER.execute()
            return unitMap.get(whichUnit)
        return w

    //custom destroy function, so unit wrapper is destroyed last and can be used in the clean up routines
    protected function destr()

        

        //the dispel function must be executed before the unit wrapper is destroyed
        if this.buffList != null
            for Buff b in this.buffList.getLinkedList()
                b.dispel()

            destroy this.buffList

        //remove unit wrapper
        unitWrapperCount--
        allUnits[this.index] = allUnits[unitWrapperCount]
        unitMap.remove(this.assocUnit)
        destroy this


    function createBuffList()
        if this.buffList == null
            this.buffList = new BuffList()
        else
            error("This unit wrapper already has a buffList")


    function setBonusCalculation(CalculateTotalBonus bonusCalculation)
        this.bonusCalculation = bonusCalculation

    function getBonusCalculation() returns CalculateTotalBonus
        return this.bonusCalculation

    function defaultBonusCalcualtion(Stat whichStat)
        let stat = whichStat.toInt()
        UnitWrapper.statsTotalBonus_static[this.arrayOffset + stat] = ((this.getStatAbsoluteBonus(whichStat)) * (1. + this.getStatRelativeBonus(whichStat)/1000 ) + (this.getStatBaseValue(whichStat) * this.getStatRelativeBonus(whichStat)/1000) ).round()
    

    /**
    Updates the total stat bonus based on base stat, absolute stat bonus and relative stat bonus
    **/
    function updateTotalStatBonus(Stat whichStat)
        if this.bonusCalculation != null
            this.bonusCalculation.calculate(this, whichStat)
        else
            this.defaultBonusCalcualtion(whichStat)
            
        this.applyTotalStatBonus(whichStat)
        

    function applyTotalStatBonus(Stat whichStat)
        if whichStat != Stat.MS and whichStat != Stat.HR and whichStat!= Stat.MR and whichStat!= Stat.HP and whichStat!= Stat.MP and whichStat != Stat.CD
            if whichStat == Stat.STR or whichStat == Stat.INT
                //update ability tooltips
                if this.toUnit().isType(UNIT_TYPE_HERO)
                    this.toUnit().setBonus(whichStat, statsTotalBonus_static[this.arrayOffset + whichStat.toInt()])
                    let hero = Hero.getHero(this.toUnit())
                    if hero != null
                        let hType = hero.getHeroType()
                        if whichStat == Stat.STR
                            hType.updateTooltipsStr(this.toUnit())
                        else
                            hType.updateTooltipsInt(this.toUnit())
                else
                    if whichStat == Stat.STR // units get AD increased instead of STR
                        this.toUnit().setBonus(Stat.AD, statsTotalBonus_static[this.arrayOffset + whichStat.toInt()])
                    else
                        this.toUnit().setBonus(whichStat, statsTotalBonus_static[this.arrayOffset + whichStat.toInt()])
            else
                this.toUnit().setBonus(whichStat, statsTotalBonus_static[this.arrayOffset + whichStat.toInt()])
                        
        else
            if whichStat == Stat.MS
                this.toUnit().setMoveSpeed( this.getStatBaseValue(whichStat) + statsTotalBonus_static[this.arrayOffset + whichStat.toInt()].toReal() )
            else if whichStat == Stat.HP
                this.toUnit().setMaxHP(this.getStatTotalValue(Stat.HP), true)
            else if whichStat == Stat.MP
                this.toUnit().setMaxMana(this.getStatTotalValue(Stat.MP), true)
            else if whichStat == Stat.CD
                let hero = Hero.getHero(this.toUnit())
                if hero != null
                    hero.updateCooldowns()
    /**
    Sets the absolute stat bonus and updates the total bonus.
    **/
    function setStatAbsoluteBonus(Stat whichStat, int newValue)
        let stat = whichStat.toInt()
        statsAbsoluteBonus_static[this.arrayOffset + stat] = newValue
        updateTotalStatBonus(whichStat)


    /**
    If real values are needed, the variable statsAbsoluteBonusReal keeps track of the bonus and increases the standard int value,
    as soon as it is over 1.
    **/  
    function addStatAbsoluteBonusReal(Stat whichStat, int plusValue)
        let arrayIndex = this.arrayOffset + whichStat.toInt()
        statsAbsoluteBonusReal_static[arrayIndex] += plusValue
        if statsAbsoluteBonusReal_static[arrayIndex].abs() >= 1000
            addStatAbsoluteBonus(whichStat, (statsAbsoluteBonusReal_static[arrayIndex]/1000).toInt() )
            statsAbsoluteBonusReal_static[arrayIndex] -= (statsAbsoluteBonusReal_static[arrayIndex]/1000).toInt()*1000
            

    /**
    Sets the relative stat bonus and updates the total bonus.
    **/
    function setStatRelativeBonus(Stat whichStat, int newValue)
        statsRelativeBonus_static[this.arrayOffset + whichStat.toInt()] = newValue
        updateTotalStatBonus(whichStat)

    function addStatAbsoluteBonus(Stat whichStat, int plusValue)
        this.setStatAbsoluteBonus(whichStat, statsAbsoluteBonus_static[this.arrayOffset + whichStat.toInt()] + plusValue)

    function addStatRelativeBonus(Stat whichStat, int plusValue)
        this.setStatRelativeBonus(whichStat, statsRelativeBonus_static[this.arrayOffset + whichStat.toInt()] + plusValue)

    function printStats()
        for i = 0 to STAT_COUNT-1
            printStat(i castTo Stat)

    function printStat(Stat whichStat)
        let stat = whichStat.toInt()
        Log.debug(whichStat.toString()+" ( "+statBaseValue_static[this.arrayOffset + stat].toString()+" + "+statsAbsoluteBonus_static[this.arrayOffset + stat].toString()+" ) * "+statsRelativeBonus_static[this.arrayOffset + stat].toString() + "->" +statsTotalBonus_static[this.arrayOffset + stat].toString() )

    function toUnit() returns unit
        return this.assocUnit

    function getStatAbsoluteBonus(Stat whichStat) returns int
        return statsAbsoluteBonus_static[this.arrayOffset + whichStat.toInt()]

    function getStatRelativeBonus(Stat whichStat) returns int
        return statsRelativeBonus_static[this.arrayOffset + whichStat.toInt()]
    
    function getStatBaseValue(Stat whichStat) returns int
        return statBaseValue_static[this.arrayOffset + whichStat.toInt()]

    function getStatTotalBonus(Stat whichStat) returns int
        return statsTotalBonus_static[this.arrayOffset + whichStat.toInt()]

    function getStatTotalValue(Stat whichStat) returns int
        return this.getStatTotalBonus(whichStat) + this.getStatBaseValue(whichStat)

    function copyBaseStatsFrom(UnitWrapper wrapper)
        for i = 0 to STAT_COUNT - 1
            statBaseValue_static[this.arrayOffset + i] = statBaseValue_static[wrapper.arrayOffset + i]
            this.updateTotalStatBonus(i castTo Stat)

    function incBlue()
        blueCount++
        if blueCount == 1
            this.assocUnit.setVertexColor(140, 220, 255, 255)

    function decBlue()
        blueCount--
        if blueCount == 0
            this.assocUnit.setVertexColor(255, 255, 255, 255)

    function incReveal()
        revealCount++
        if revealCount == 1
            if this.team == TEAM_1
                UnitShareVision(this.toUnit(), players[Teams.army2()], true)
            else if this.team == TEAM_2
                UnitShareVision(this.toUnit(), players[Teams.army1()], true)

    function decReveal()
        revealCount--
        if revealCount == 0
            if this.team == TEAM_1
                UnitShareVision(this.toUnit(), players[Teams.army2()], false)
            else if this.team == TEAM_2
                UnitShareVision(this.toUnit(), players[Teams.army1()], false)


public function unit.wrapper() returns UnitWrapper
    return UnitWrapper.getWrapper(this)

public function unit.getBuffList() returns BuffList
    return this.wrapper().buffList

public enum ReductionType
    PHYSICAL
    MAGIC
    NONE


public function unit.isTargetable(player source, boolean allowFriends, boolean allowEnemies) returns boolean
    boolean ret = true
    if this == null
        ret = false
    else if not this.isAlive()
        ret = false
    else if IsUnitEnemy(this, source) 
        ret = allowEnemies and not IsUnitType(this, UNIT_TYPE_ANCIENT) and not IsUnitType(this, UNIT_TYPE_MAGIC_IMMUNE)
    else if IsUnitAlly(this, source) 
        ret = allowFriends and not IsUnitType(this, UNIT_TYPE_MAGIC_IMMUNE)

    return ret

public function unit.isVisible(player source) returns boolean
    return IsUnitVisible(this, source)

public function unit.isMovable() returns boolean
    if GetUnitPropWindow(this) < 0.00001
        return false
    if BuffList.hasBuffType(this, ENSNARED)
        return false
    if BuffList.hasBuffType(this, ENTANGLED)
        return false
    if this.getDefaultMovespeed() == 0
        return false
    return true

public function unit.getStr() returns int
    int ret
    if this.isType(UNIT_TYPE_HERO)
        ret = GetHeroStr(this, true)
    else
        ret = this.wrapper().getStatTotalValue(Stat.STR)
    return ret

public function unit.getWp() returns int
    int ret
    if this.isType(UNIT_TYPE_HERO)
        ret = GetHeroAgi(this, true)
    else
        ret = this.wrapper().getStatTotalValue(Stat.AGI)
    return ret

public function unit.getInt() returns int
    int ret
    if this.isType(UNIT_TYPE_HERO)
        ret = GetHeroInt(this, true)
    else
        ret = this.wrapper().getStatTotalValue(Stat.INT)
    return ret

public function unit.addBuff(unit caster, real duration, BuffType buffType, int level) returns Buff
    Buff ret = null
    if (duration <= 0 and duration > -0.5) or duration > 600
        error("addBuff add buff with unusual duration: " + duration.toString())
    if this.isAlive()
        execute() () ->
            Buff.applyBuff(this, caster, duration, buffType, level)
        ret = BuffList.getBuffOfType(this, buffType)
    return ret

public function unit.addBuffReduced(unit caster, real duration, BuffType buffType, int level) returns Buff
    //buff reduction only uses 1/4 of the wp, so it reduces duration not as much as it reduces damage
    real realDuration =  duration.reduce( (this.getWp()/4).toInt() , 0.01 )
    if this.hasItemById(ITEM_ID_ARCANE_SHIELD)
        realDuration = realDuration * 0.85
    Buff ret = null
    if (realDuration <= 0 and realDuration > -0.5) or realDuration > 600
        error("addBuffReduced add buff with unusual duration: " + realDuration.toString() + " " + (buffType castTo int).toString())
    if this.isAlive()
        execute() () ->
            Buff.applyBuff(this, caster, realDuration, buffType, level)
        ret = BuffList.getBuffOfType(this, buffType)
    return ret


public function unit.dealDamageAlways(unit target, real amount, ReductionType reductionType)
    let damageType = reductionType == ReductionType.PHYSICAL ? DAMAGE_TYPE_NORMAL : DAMAGE_TYPE_UNIVERSAL
    real newAmount
    if reductionType == ReductionType.MAGIC
        let wp = target.getWp()
        newAmount = amount.reduceMagic(wp)
    else
        newAmount = amount

    UnitDamageTarget(this, target, newAmount, false, true, ATTACK_TYPE_NORMAL, damageType, WEAPON_TYPE_WHOKNOWS)

public function unit.dealDamage(unit target, real amount, ReductionType reductionType)
    if not target.isType(UNIT_TYPE_ANCIENT)
        this.dealDamageAlways(target, amount, reductionType)
        if not IsUnitEnemy(target, this.getOwner()) and this != target
            Log.warn(this.getName()+" damages ally: "+target.getName())

public function unit.damageMana(unit target, real amount, ReductionType reductionType)
    real newAmount
    if reductionType == ReductionType.MAGIC
        let wp = target.getWp()
        newAmount = amount.reduceMagic(wp)
    else if reductionType == ReductionType.PHYSICAL
        let ar = target.getArmor().round()
        newAmount = amount.reduceMagic(ar)
    else
        newAmount = amount
    target.addMana(-newAmount)

public function unit.healHP(unit target, real amount)
    real realAmount = amount
    if this.hasItemById(ITEM_ID_BRACER_OF_POWER)
        realAmount *= 1.15

    realAmount = min(realAmount, target.getMaxHP()-target.getHP())
    target.setHP(target.getHP() + realAmount)

    PlayerWrapper.statHealingReceived[target.getOwner().getId()] += realAmount
    PlayerWrapper.statHealingDone[this.getOwner().getId()] += realAmount

public function unit.healMana(unit target, real amount)
    real realAmount = amount
    if this.hasItemById(ITEM_ID_BRACER_OF_POWER)
        realAmount *= 1.15

    realAmount = min(realAmount, target.getMaxMana()-target.getMana())
    target.setMana(target.getMana() + realAmount)

    PlayerWrapper.statManaHealed[target.getOwner().getId()] += realAmount

public function unit.dispelPositiveBuffs(DispelLevel dispelLevel)
    let buffList = this.getBuffList()
    if buffList != null
        for Buff currentBuff in buffList.getLinkedList()
            let buffType =currentBuff.getBuffType()
            if buffType.isPositive() and currentBuff.getDispelLevel() castTo int <= dispelLevel castTo int
                currentBuff.dispel()

public function unit.dispelNegativeBuffs(DispelLevel dispelLevel)
    let buffList = this.getBuffList()
    if buffList != null
        for Buff currentBuff in buffList.getLinkedList()
            let buffType =currentBuff.getBuffType()
            if not buffType.isPositive() and currentBuff.getDispelLevel() castTo int <= dispelLevel castTo int
                currentBuff.dispel()


public function unit.dispelBuffs(DispelLevel dispelLevel)
    let buffList = this.getBuffList()
    if buffList != null
        for Buff currentBuff in buffList.getLinkedList()
            if currentBuff.getDispelLevel() castTo int <= dispelLevel castTo int
                currentBuff.dispel()


public function unit.hitBoxDistanceTo(vec2 pos) returns real
    return max(0, this.getPos().distanceTo(pos) - this.getHitBox())

public function unit.countItemsOfType(int itemTypeId) returns int
    item indexItem
    int count = 0

    for i = 0 to bj_MAX_INVENTORY-1
        indexItem = UnitItemInSlot(this, i)
        if (indexItem != null) and (indexItem.getTypeId() == itemTypeId)
            count++

    return count

init
    onUnitIndex(() -> UnitWrapper.create(getIndexingUnit()))
    onUnitDeindex(() -> getIndexingUnit().wrapper().destr() )

    setGetBuffListFunction( (unit u) -> (begin
        return u.getBuffList()
    end))

    setCreateBuffListFunction( (unit u) -> (begin
        if u.wrapper() != null
            u.wrapper().createBuffList()
        else
            error("The unit "+u.getName()+" had no wrapper.")
            UnitWrapper.create(u)
            u.wrapper().createBuffList()
    end))

    CreateTrigger()
    ..registerPlayerChatEvent(players[0], "-s", true)
    ..addAction() ->
        PlayerWrapper.getPlayerHero(0, 0).toUnit().wrapper().printStats()

    CreateTrigger()
    ..addAction(function onUnitDeath)
    ..registerAnyUnitEvent(EVENT_PLAYER_UNIT_DEATH)
