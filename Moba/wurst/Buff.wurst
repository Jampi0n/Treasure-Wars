package Buff

import TimerUtils
import BuffType

/*
Idea: each unit can have every buff only once

The buff object contains dynamic information and its type
The type contains static information

Dynamic:
caster, target, duration
Static:
aura based ability and corresponding buff

Reapplying the same buff type does not create a new buff object, but rather increases duration of the previous one
and updates caster and other dynamic duration.

Buff types can have closures that will be executed in certain situations:
onFirst -> buff is used on a unit that does not have the buff
onStack -> buff is used on a unit that does have the buff
onApply -> is used on a unit
onExpire -> duration runs out
onDispel -> buff removed before duration runs out: dispel, death, invulnerability, ...
To detect this: use native buff management of wc3
The buff abilities must not work on dead or invulnerable units for example.
onEnd -> buff gone in any way

Different levels of the same buff:
This should only happen when a hero levels up and has now a stronger spell.
Therefore one can safely overwrite the old buff.
Realization:
1. stats of buffs as dynamic information -> can easily be overwritten
2. multiple buff types for same buff with different levels -> how is the same buff with a different level removed?

Ability List for a buff. Each ability inside this list should only be used for this buff.

Duration is fixed when the buff is applied -> use one shot timer


*/


public class Buff

    private unit caster
    private unit target
    private BuffType bufftype
    private timer expireTimer
    private trigger onFirst
    private trigger onStack
    private trigger onApply
    private trigger onExpire
    private trigger onDispel
    private trigger onEnd
    private trigger onPeriodicTrigger
    private timer periodicTimer

    static Buff currentBuff 

    construct(unit target, unit caster, real duration, BuffType buffType)
        this.caster = caster
        this.target = target
        this.expireTimer = getTimer()
        this.expireTimer.setData(this castTo int)
        this.expireTimer.start(duration, function expireStatic)
        this.bufftype = bufftype

    function setFirst(code onFirst)
        if(this.onFirst!=null)
            this.onFirst = CreateTrigger()

        this.onFirst.addAction(onFirst)

    function setStack(code onStack)
        if(this.onStack!=null)
            this.onStack = CreateTrigger()

        this.onStack.addAction(onStack)

    function setOnApply(code onApply)
        if(this.onApply!=null)
            this.onApply = CreateTrigger()

        this.onApply.addAction(onApply)

    function setOnExpire(code onExpire)
        if(this.onExpire!=null)
            this.onExpire = CreateTrigger()

        this.onExpire.addAction(onExpire)

    function setOnDispel(code onDispel)
        if(this.onDispel!=null)
            this.onDispel = CreateTrigger()

        this.onDispel.addAction(onDispel)

    function setOnEnd(code onEnd)
        if(this.onEnd!=null)
            this.onEnd = CreateTrigger()

        this.onEnd.addAction(onEnd)

    function setOnPeriodic(code onPeriodic, real time)
        if(this.onPeriodicTrigger!=null)
            this.onPeriodicTrigger = CreateTrigger()

        this.onPeriodicTrigger.addAction(onPeriodic)
        this.periodicTimer = getTimer()
            ..setData(this castTo int)
            ..start(time, function onPeriodicStatic )

    function onPeriodic()
        currentBuff = this
        this.onPeriodicTrigger.execute()

    static function onPeriodicStatic()
        let t = GetExpiredTimer()
        Buff thisBuff = t.getData() castTo Buff
        thisBuff.onPeriodic()
    
    function expire()
        currentBuff = this
        this.onExpire.execute()
        this.onEnd.execute()
        destroy this

    function dispel()
        currentBuff = this
        this.onDispel.execute()
        this.onEnd.execute()
        destroy this

        

    static function expireStatic()
        let t = GetExpiredTimer()
        Buff thisBuff = t.getData() castTo Buff
        thisBuff.expire()
        t.release()

    ondestroy
        this.expireTimer.release()
        this.periodicTimer.release()
        this.onPeriodicTrigger.clearActions()
        this.onFirst..clearActions()..destr()
        this.onStack..clearActions()..destr()
        this.onApply..clearActions()..destr()
        this.onDispel..clearActions()..destr()
        this.onEnd..clearActions()..destr()
        this.onExpire..clearActions()..destr()


