/**
    UnitWrapper offers additional methods for units by using a wrapper class.
    The wrapper is created and destroyed automatically.

    Additional functionality can be added by using modules from the Modules sub directory.

    Usage:
    Create a sub class of UnitWrapper:
    ==================================================
    class MyUnitWrapper extends UnitWrapper

    ==================================================
    Add create and destroy functions:
    ==================================================
    class MyUnitWrapper
        use UnitWrapper

        construct(unit u)
            super(u)

        ondestroy
            destroyWrapper()

    ==================================================
    The ondestroy functions should call the destroy functions from all modules.

    Additional modules can be used from the Modules sub directory.
    The destroy order in ondestroy should be opposite to the use order.
    For example:
    ==================================================
    public class MyUnitWrapper
        use UnitWrapper
        use UnitInfo
        use UnitColor
        use UnitStats
        use UnitBuffs

        ondestroy
            destroyBuffs()
            destroyStats()
            destroyColor()
            destroyInfo()
            destroyWrapper()
    ==================================================
    This ensures that the outer modules have longer lifespans than inner modules.
    UnitWrapper should always be the outermost module, so that other modules can rely on it.
    In this example UnitBuffs is the innermost module, because Buff functions frequently rely on the data of other modules (e.g. changing color).
    When adding more modules read their instructions and think about their dependencies.

    Finally define the UnitWrapper creation function by overriding UnitWrapperSingleton and create it:
    ==================================================
    class MyUnitWrapperSingleton extends UnitWrapperSingleton
        override function createNew(unit u)
            new MyUnitWrapper(u)

    init
        new MyUnitWrapperSingleton()
    ==================================================
**/
package UnitWrapper

import NoWurst
import OnUnitEnterLeave
import ErrorHandling
import HashMap
import ObjectIds
import Unit
import Basics

public interface PreConstructEvent
    function run(unit u)

public interface PostConstructEvent
    function run(unit u)

public interface PreDestroyEvent
    function run(unit u)

public interface PostDestroyEvent
    function run(unit u)

public abstract class UnitWrapperSingleton
    protected static UnitWrapperSingleton singleton
    abstract function createNew(unit u)
    construct()
        singleton = this

public abstract class UnitWrapper
    private unit assocUnit
    private static constant toWrapper = new HashMap<unit, UnitWrapper>()

    function toUnit() returns unit
        return this.assocUnit

    private construct(unit u)
        this.assocUnit = u
        toWrapper.put(u, this)

    static function getWrapper(unit u) returns thistype
        if u == null or u.getTypeId() == 0
            error("Requesting wrapper for null unit.")
            return null
        let w = toWrapper.get(u)
        if w == null
            error("The unit " + u.getName() + "(" + u.getTypeId().toRawCode() + ") has no wrapper.")
        return w

    function destroyWrapper()
        toWrapper.remove(this.assocUnit)

    static int numPreConstructEvents = 0
    static PreConstructEvent array preConstructEvents
    static int numPostConstructEvents = 0
    static PostConstructEvent array postConstructEvents
    static int numPreDestroyEvents = 0
    static PreDestroyEvent array preDestroyEvents
    static int numPostDestroyEvents = 0
    static PostDestroyEvent array postDestroyEvents

    static function addPreConstructEvent1(PreConstructEvent c)
        preConstructEvents[numPreConstructEvents] = c
        numPreConstructEvents++

    static function runPreConstructEvents(unit u)
        for i = 0 to numPreConstructEvents - 1
            preConstructEvents[i].run(u)

    static function addPostConstructEvent(PostConstructEvent c)
        postConstructEvents[numPostConstructEvents] = c
        numPostConstructEvents++

    static function runPostConstructEvents(unit u)
        for i = 0 to numPostConstructEvents - 1
            postConstructEvents[i].run(u)

    static function addPreDestroyEvent(PreDestroyEvent c)
        preDestroyEvents[numPreDestroyEvents] = c
        numPreDestroyEvents++

    static function runPreDestroyEvents(unit u)
        for i = 0 to numPreDestroyEvents - 1
            preDestroyEvents[i].run(u)

    static function addPostDestroyEvent(PostDestroyEvent c)
        postDestroyEvents[numPostDestroyEvents] = c
        numPostDestroyEvents++

    static function runPostDestroyEvents(unit u)
        for i = 0 to numPostDestroyEvents - 1
            postDestroyEvents[i].run(u)

    protected static function initWrapper()
        onEnter() ->
            let u = getEnterLeaveUnit()
            if u != null and u.getTypeId() != 0 and u.getAbilityLevel(LOCUST_ID) == 0
                runPreConstructEvents(u)
                UnitWrapperSingleton.singleton.createNew(u)
                runPostConstructEvents(u)
        onLeave() ->
            let u = getEnterLeaveUnit()
            if u.getAbilityLevel(LOCUST_ID) == 0
                let wrapper = getWrapper(u)
                runPreDestroyEvents(u)
                destroy wrapper
                runPostDestroyEvents(u)

init
    UnitWrapper.initWrapper()
