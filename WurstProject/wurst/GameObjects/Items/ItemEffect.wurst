package ItemEffect

import ItemObjEditing
import HashMap
import ErrorHandling
import Stats
import IUnit
import UnitLib
import ItemIdDefinitions
import ItemConfiguration
import PassiveItemCooldown
import UnitWrapper
import ClosureTimers
import JUnit
import JItem
import ErrorMessage

constant ALLOW_ITEM_DROP = false
constant ALLOW_ITEM_GIVE = false

public interface ItemDropOrPickUp
    function dropOrPickUp(int factor)

public function getItemItem() returns item
    return ItemEffect.triggerItem

public function getItemItemType() returns int
    return ItemEffect.triggerItem.getTypeId()

public function getItemUnit() returns unit
    return ItemEffect.triggerUnit

public function getItemUnitWrapper() returns IUnit
    return ItemEffect.triggerWrapper

public function getItemSign() returns int
    return ItemEffect.inventoryChangeDirection

public class ItemEffect

    private int itemId

    protected static constant tomeToStat = new HashMap<int,Stat>()
    protected static constant tomeToValue = new HashMap<int,int>()

    protected static bool doItemEvents = true

    protected static item triggerItem
    protected static unit triggerUnit
    protected static IUnit triggerWrapper
    protected static int inventoryChangeDirection

    private static constant itemIdToEffect = new HashMap<int, ItemEffect>
    private static trigger onItemPickUp = CreateTrigger()
    private static trigger onItemDrop = CreateTrigger()
    protected ItemDropOrPickUp onDropOrPickUp = null
    protected static constant itemOwnerMap = new HashMap<item, unit>
    protected static constant itemSlotMap = new HashMap<item, int>

    private int useCount = 0

    construct(int itemId)
        this.itemId = itemId
        itemIdToEffect.put(itemId, this)

    static function retrieveItemEffect(int itemId) returns ItemEffect
        if itemIdToEffect.has(itemId)
            return itemIdToEffect.get(itemId)
        else
            return new ItemEffect(itemId)


    static function classInit()
        onItemPickUp = CreateTrigger()
            ..addAction(function onItemPickUp)
            ..registerAnyUnitEvent(EVENT_PLAYER_UNIT_PICKUP_ITEM)
        onItemDrop = CreateTrigger()
            ..addAction(function onItemDrop)
            ..registerAnyUnitEvent(EVENT_PLAYER_UNIT_DROP_ITEM)


    static function onItemPickUp()
        let localItem = GetManipulatedItem()
        let itemTypeId = localItem.getTypeId()
        if itemTypeId == PLACE_HOLDER_ITEM
            return
        let localUnit = GetTriggerUnit()
        triggerItem = localItem
        triggerUnit = localUnit
        bool thief = false
        if itemOwnerMap.has(localItem)
            let owningUnit = itemOwnerMap.get(localItem)
            if localUnit.getOwner() != owningUnit.getOwner()
                if not ALLOW_ITEM_GIVE
                    owningUnit.getOwner().errorMessage("Items cannot be given to other players.")
                    thief = true
                    nullTimer() -> 
                        doItemEvents = false
                        localUnit.removeItem(localItem)
                        doItemEvents = true
                        let slot = itemSlotMap.get(localItem)
                        owningUnit.addItemHandleToSlot(localItem, slot)

        if not thief
            itemOwnerMap.put(localItem, localUnit)
            nullTimer() -> 
                let slot = localUnit.getItemSlot(localItem)
                itemSlotMap.put(localItem, slot)
            if localUnit.wrapper().getAllowItemPickup()
                PassiveItemCooldown.onItemPickUp(localUnit, localItem, itemTypeId)
                if doItemEvents
                    if itemIdToEffect.has(itemTypeId)
                        triggerWrapper = localUnit.wrapper()
                        inventoryChangeDirection = 1
                        let itemType = itemIdToEffect.get(itemTypeId)
                        itemType.useCount++
                        if itemType.onDropOrPickUp != null
                            itemType.onDropOrPickUp.dropOrPickUp(1)
            else
                doItemEvents = false
                localUnit.removeItem(localItem)
                doItemEvents = true

    static function onItemDrop()
        let localItem = GetManipulatedItem()
        let itemTypeId = localItem.getTypeId()
        if itemTypeId == PLACE_HOLDER_ITEM
            return
        let localUnit = GetTriggerUnit()
        triggerItem = localItem
        triggerUnit = localUnit
        let slot = localUnit.getItemSlot(localItem)
        if itemOwnerMap.has(localItem)
            if itemOwnerMap.get(localItem) == localUnit
                itemSlotMap.put(localItem, slot)
        if doItemEvents
            if itemIdToEffect.has(localItem.getTypeId())
                triggerWrapper = localUnit.wrapper()
                inventoryChangeDirection = -1
                let itemType = itemIdToEffect.get(localItem.getTypeId())
                itemType.useCount--
                if itemType.onDropOrPickUp != null
                    itemType.onDropOrPickUp.dropOrPickUp(-1)
        nullTimer() -> 
            if localItem != null
                if localItem.isAlive()
                    if not localItem.isOwned()
                        if not ALLOW_ITEM_DROP
                            localUnit.addItemHandleToSlot(localItem, slot)
                            localUnit.getOwner().errorMessage("Items cannot be dropped on the ground.")
                else
                    itemOwnerMap.remove(localItem)
                    itemSlotMap.remove(localItem)                 
            

public function onEither(ItemDropOrPickUp onDropOrPickUp)
    if compiletime
        return
    if getCurrentItemEffect().onDropOrPickUp != null
        error("The item already has an effect!")
    getCurrentItemEffect().onDropOrPickUp = onDropOrPickUp

public function getCurrentItemEffect() returns ItemEffect
    return ItemEffect.retrieveItemEffect(currentItemInShop.getItemId())

public function tomeModStat(Stat whichStat, int modValue)
    if not compiletime
        let itemTypeId = currentItemInShop.getItemId()
        ItemEffect.tomeToStat.put(itemTypeId, whichStat)
        ItemEffect.tomeToValue.put(itemTypeId, modValue)
        makePowerUp()
    else
        currentItemDefinition.setClassification("PowerUp")

public function onTomePickUp(unit hero, int itemTypeId)
    if ItemEffect.tomeToStat.has(itemTypeId)
        hero.wrapper().modStatDispatch(ItemEffect.tomeToStat.get(itemTypeId), ItemEffect.tomeToValue.get(itemTypeId))

//returns if the picked up item is the first of its type and if the dropped item is the last of its type
public function isUnique() returns boolean
    return getItemUnit().countItemsOfType(getItemItemType()) == 1

//returns if the the hero has not this item
public function hasNot(int itemTypeId) returns boolean
    return getItemUnit().countItemsOfType(itemTypeId) == 0

public function isUniqueExt(vararg int itemTypeIds) returns boolean
    let u = getItemUnit()
    int sum = 0
    for int id in itemTypeIds
        sum += u.countItemsOfType(id)
    return sum == 1

public function isFirstBoots() returns bool
    return isUniqueExt(ITEM_ID_BOOTS_BASE, ITEM_ID_BOOTS_GUARDIAN, ITEM_ID_BOOTS_HUNTER, ITEM_ID_BOOTS_RUNNER, ITEM_ID_BOOTS_WIZARD)

init
    ItemEffect.classInit()
    PassiveItemCooldown.setup() (unit u, LockInternalFunction lock) ->
        ItemEffect.doItemEvents = false
        let drop = u.wrapper().getAllowItemDrop()
        let pickup = u.wrapper().getAllowItemPickup()
        u.wrapper().setAllowItemDrop(true)
        u.wrapper().setAllowItemPickup(true)
        lock.lock()
        ItemEffect.doItemEvents = true
        u.wrapper().setAllowItemDrop(drop)
        u.wrapper().setAllowItemPickup(pickup)


    /*
    Drop items before the unit wrapper is destroyed.
    The item drop event for removed units happens after the unit removal event, so if there are still items left when the unit wrapper is destroyed, the onDrop functions can no longer access the unit wrapper. To fix this, all items are dropped before the unit wrapper is destroyed.
    */
    UnitWrapper.addPreDestroyEvent() (unit u) ->
        for i = 0 to u.inventorySize() - 1
            let itm = u.itemInSlot(i)
            if itm != null
                itm.remove()
