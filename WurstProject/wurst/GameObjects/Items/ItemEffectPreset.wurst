package ItemEffectPreset

import ItemEffect
import FastDamageEvent
import Reference
import ItemConfigurationCompiletime
import HashMap

/**
Adds a trigger which is active while the item is carried by the hero.
The trigger is returned only if the item is unique and the item was picked up.
Check if the trigger is null:

onEither() (int factor) ->
    let trg = itemTrigger()
    if trg != null
        trg.register...
        trg.addAction...
        ...
**/
public function itemTrigger() returns trigger
    return itemTrigger(1)

public function itemTrigger(int factor) returns trigger
    if isUnique()
        if getItemSign() == 1
            let trg = new Reference<trigger>(CreateTrigger())
            DamageEventUnit.fromUnit(getItemUnit()).saveIntSlow(factor * getItemItemType(), trg castTo int)
            return trg.val
        else
            (DamageEventUnit.fromUnit(getItemUnit()).loadIntSlow(factor * getItemItemType()) castTo Reference<trigger>).into().destr()
            return null
    return null

public function anyDamageFunction(DamageFunction f)
    anyDamageFunction(1, f)
public function anyDamageFunction(int factor, DamageFunction f)
    if isUnique()
        let u = DamageEventUnit.fromUnit(getItemUnit())
        if getItemSign() == 1
            u.saveIntSlow(factor * getItemItemType(), u.anyDamage.add(f))
        else
            u.anyDamage.remove(u.loadIntSlow(factor * getItemItemType()))

public function anyHitFunction(DamageFunction f)
    anyHitFunction(1, f)
public function anyHitFunction(int factor, DamageFunction f)
    if isUnique()
        let u = DamageEventUnit.fromUnit(getItemUnit())
        if getItemSign() == 1
            u.saveIntSlow(factor * getItemItemType(), u.anyHit.add(f))
        else
            u.anyHit.remove(u.loadIntSlow(factor * getItemItemType()))

public function attackDamageFunction(DamageFunction f)
    attackDamageFunction(1, f)
public function attackDamageFunction(int factor, DamageFunction f)
    if isUnique()
        let u = DamageEventUnit.fromUnit(getItemUnit())
        if getItemSign() == 1
            u.saveIntSlow(factor * getItemItemType(), u.attackDamageNoBuilding.add(f))
        else
            u.attackDamageNoBuilding.remove(u.loadIntSlow(factor * getItemItemType()))

public function attackHitFunction(DamageFunction f)
    attackHitFunction(1, f)
public function attackHitFunction(int factor, DamageFunction f)
    if isUnique()
        let u = DamageEventUnit.fromUnit(getItemUnit())
        if getItemSign() == 1
            u.saveIntSlow(factor * getItemItemType(), u.attackHitNoBuilding.add(f))
        else
            u.attackHitNoBuilding.remove(u.loadIntSlow(factor * getItemItemType()))

public function damageEventInt(int key)
    let u = DamageEventUnit.fromUnit(getItemUnit())
    u.saveIntFast(key, u.loadIntFast(key) + getItemSign())

public function modArmor(int modifier)
    getItemUnitWrapper().modArmor(modifier * getItemSign())
public function modAttackSpeed(int modifier)
    getItemUnitWrapper().modAttackSpeed(modifier * getItemSign())
public function modStrength(int modifier)
    getItemUnitWrapper().modStrength(modifier * getItemSign())
public function modAgility(int modifier)
    getItemUnitWrapper().modAgility(modifier * getItemSign())
public function modIntelligence(int modifier)
    getItemUnitWrapper().modIntelligence(modifier * getItemSign())
public function modMoveSpeed(int modifier)
    getItemUnitWrapper().modMoveSpeed(modifier * getItemSign())
public function modHealth(int modifier)
    getItemUnitWrapper().modHealth(modifier * getItemSign())
public function modMana(int modifier)
    getItemUnitWrapper().modMana(modifier * getItemSign())
public function modHealthRegen(int modifier)
    getItemUnitWrapper().modHealthRegen(modifier * getItemSign())
public function modManaRegen(int modifier)
    getItemUnitWrapper().modManaRegen(modifier * getItemSign())
public function modCooldown(int modifier)
    getItemUnitWrapper().modCooldown(modifier * getItemSign())

public function modArmorRelative(int modifier)
    getItemUnitWrapper().modArmorRelative(modifier * getItemSign())
public function modStrengthRelative(int modifier)
    getItemUnitWrapper().modStrengthRelative(modifier * getItemSign())
public function modAgilityRelative(int modifier)
    getItemUnitWrapper().modAgilityRelative(modifier * getItemSign())
public function modIntelligenceRelative(int modifier)
    getItemUnitWrapper().modIntelligenceRelative(modifier * getItemSign())
public function modMoveSpeedRelative(int modifier)
    getItemUnitWrapper().modMoveSpeedRelative(modifier * getItemSign())
public function modHealthRelative(int modifier)
    getItemUnitWrapper().modHealthRelative(modifier * getItemSign())
public function modManaRelative(int modifier)
    getItemUnitWrapper().modManaRelative(modifier * getItemSign())
public function modHealthRegenRelative(int modifier)
    getItemUnitWrapper().modHealthRegenRelative(modifier * getItemSign())
public function modManaRegenRelative(int modifier)
    getItemUnitWrapper().modManaRegenRelative(modifier * getItemSign())

    
public function modLifeSteal(int modifier)
    getItemUnitWrapper().modLifesteal(modifier * getItemSign())
public function modArmorReductionRelative(int modifier)
    getItemUnitWrapper().modArmorReductionRelative(modifier * getItemSign())


public enum ItemStat
    STR
    AGI
    INT
    AR
    AS
    MS
    HP
    HR
    MP
    MR
    CD
    AP
    LS

public constant NUM_ITEM_STATS = 13

enum ItemStatPercentage
    EITHER
    ALWAYS
    NEVER


public class ItemStatLine
    protected static constant map = new HashMap<ItemStat, ItemStatLine>()
    protected string name
    protected ItemStatPercentage percentage
    protected real factor

    private function setup(ItemStat itemStat, string name, ItemStatPercentage percentage, real factor)
        this.percentage = percentage
        this.name = name
        this.factor = factor
        map.put(itemStat, this)

    construct(ItemStat itemStat, string name, real factor, bool percentage)
        if percentage
            setup(itemStat, name, ItemStatPercentage.ALWAYS, factor)
        else
            setup(itemStat, name, ItemStatPercentage.NEVER, factor)

    construct(ItemStat itemStat, string name)
        setup(itemStat, name, ItemStatPercentage.EITHER, 1.0)
    construct(ItemStat itemStat, string name, real factor)
        setup(itemStat, name, ItemStatPercentage.EITHER, factor)
        
public function addStatLine(ItemStat whichStat, real modifier, bool percentage)
    let itemStatLine = ItemStatLine.map.get(whichStat)
    var newPercentage = percentage
    if itemStatLine.percentage == ItemStatPercentage.ALWAYS
        newPercentage = true
    if itemStatLine.percentage == ItemStatPercentage.NEVER
        newPercentage = false
    addStatLine(itemStatLine.name, modifier * itemStatLine.factor, newPercentage)
public function addStatLine(ItemStat whichStat, int modifier, bool percentage)
    addStatLine(whichStat, modifier.toReal(), percentage)
public function addStatLine(ItemStat whichStat, real modifier)
    addStatLine(whichStat, modifier, false)
public function addStatLine(ItemStat whichStat, int modifier)
    addStatLine(whichStat, modifier, false)

@compiletime
function initStatLine()
    new ItemStatLine(ItemStat.STR, "Strength")
    new ItemStatLine(ItemStat.AGI, "Magic Resistance")
    new ItemStatLine(ItemStat.INT, "Intelligence")
    new ItemStatLine(ItemStat.AS, "Attack Speed", 1.0, true)
    new ItemStatLine(ItemStat.AR, "Armor")
    new ItemStatLine(ItemStat.MS, "Movement Speed")
    new ItemStatLine(ItemStat.HP, "Health Points")
    new ItemStatLine(ItemStat.HR, "Health Regeneration per second", 0.01)
    new ItemStatLine(ItemStat.MP, "Mana Points")
    new ItemStatLine(ItemStat.MR, "Mana Regeneration per second", 0.01)
    new ItemStatLine(ItemStat.CD, "Cooldown Recovery", 1.0, true)
    new ItemStatLine(ItemStat.AP, "Armor Penetration", 1.0, true)
    new ItemStatLine(ItemStat.LS, "Lifesteal", 1.0, true)

init
    initStatLine()
