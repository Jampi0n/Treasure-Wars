package IUnit

import ErrorHandling
import Constants
import HeroTypeImpl
import TeamUtil
import IHero
import UnitWrapper
import UnitInfo
import UnitBuffs
import UnitColor
import public UnitStats
import BonusMod
import Buff
import FastDamageEvent
import initlater UnitLib
import Assets
import ClosureTimers

class IUnitSingleton extends UnitWrapperSingleton
    override function createNew(unit u)
        new IUnit(u)

public class IUnit extends UnitWrapper
    use UnitInfo
    use UnitColor
    use UnitStats
    use UnitBuffs
    IHero hero
    IHeroType heroType
    IHero owningHero
    int revealCount = 0
    int team
    bool isHero
    real scaleAttackAnimation = 1.0
    real baseScale
    real scaleMultiplier = 1.0
    bool allowItemPickUp = true
    bool allowItemDrop = true
    int lifeSteal = 0
    int cooldownRecovery = 0
    int attackEventPointer = 0
    int armorReduction = 0
    int armorReductionRelative = 0
    int calculateArmorReduction = 0

    ondestroy
        destroyBuffs()
        destroyStats()
        destroyColor()
        destroyInfo()
        destroyWrapper()
        if attackEventPointer != 0
            DamageEventUnit.fromUnit(this.toUnit()).attackDamageNoBuilding.remove(attackEventPointer)

    construct(unit u)
        super(u)
        this.setStatBaseInternal(Stat.STR, this.getDamageBase())
        this.setStatBaseInternal(Stat.AD, 0)
        this.applyBaseStats()
        this.team = Players.team(this.getOwnerId())
        this.baseScale = u.getField(UNIT_RF_SCALING_VALUE)

        this.isHero = u.isType(UNIT_TYPE_HERO)
        if this.isHero
            this.scaleAttackAnimation = ATTACK_ANIMATION_FACTOR
            this.heroType = HeroType.get(this.getTypeId())
            if this.heroType == null
                error("HeroType could not be resolved: " + u.getName())

            attackEventPointer = DamageEventUnit.fromUnit(u).attackDamageNoBuilding.add() (unit source, unit target, DamageEventUnit sourceWrapper, DamageEventUnit targetWrapper, real damage, boolean attack, boolean active, boolean alternate) ->
                if lifeSteal > 0
                    source.healHP(source, damage * lifeSteal / 100.0)
                    source.addEffect(Abilities.vampiricAuraTarget, "origin").destr()
                if calculateArmorReduction > 0
                    target.addEffect(Abilities.bloodElfSpellThiefMISSILE, "chest").destr()
                    let targetWrapper = target.wrapper()
                    let targetArmor = targetWrapper.getArmor()
                    let reduction = min(targetArmor, calculateArmorReduction) * 0 + 1000
                    targetWrapper.modArmor(-reduction)
                    nullTimer() -> 
                        targetWrapper.modArmor(reduction)

                

    function setAllowItemPickup(bool flag)
        checkValid()
        allowItemPickUp = flag

    function getAllowItemPickup() returns bool
        checkValid()
        return allowItemPickUp

    function setAllowItemDrop(bool flag)
        checkValid()
        allowItemDrop = flag
        for i = 0 to 5
            let itm = this.toUnit().itemInSlot(i)
            if itm != null
                itm.setDroppable(flag)
                itm.setPawnable(flag)

    function getAllowItemDrop() returns bool
        checkValid()
        return allowItemDrop

    function setHero(IHero hero)
        checkValid()
        this.hero = hero

    function getHeroType() returns IHeroType
        checkValid()
        return this.heroType

    function toHero() returns IHero
        checkValid()
        return this.hero

    function isHero() returns bool
        checkValid()
        return this.isHero

    function getOwningHero() returns IHero
        checkValid()
        return this.owningHero

    function setOwningHero(IHero owningHero)
        checkValid()
        this.owningHero = owningHero

    function morph()
        checkValid()
        this.scale(1)
        this.applyBaseStats()

    function scale(real multiplier)
        checkValid()
        this.scaleMultiplier *= multiplier
        this.toUnit().setScale(this.baseScale * this.scaleMultiplier)

    function incReveal()
        checkValid()
        revealCount++
        if revealCount == 1
            if this.team == TEAM_1
                UnitShareVision(this.toUnit(), players[Teams.army2()], true)
            else if this.team == TEAM_2
                UnitShareVision(this.toUnit(), players[Teams.army1()], true)

    function decReveal()
        checkValid()
        revealCount--
        if revealCount == 0
            if this.team == TEAM_1
                UnitShareVision(this.toUnit(), players[Teams.army2()], false)
            else if this.team == TEAM_2
                UnitShareVision(this.toUnit(), players[Teams.army1()], false)

    function modReveal(int value)
        checkValid()
        revealCount += value
        if revealCount > 0
            if this.team == TEAM_1
                UnitShareVision(this.toUnit(), players[Teams.army2()], true)
            else if this.team == TEAM_2
                UnitShareVision(this.toUnit(), players[Teams.army1()], true)
        else
            if this.team == TEAM_1
                UnitShareVision(this.toUnit(), players[Teams.army2()], false)
            else if this.team == TEAM_2
                UnitShareVision(this.toUnit(), players[Teams.army1()], false)

    override function applyDamage()
    override function applyArmor()
        this.toUnit().setBonusArmor(this.getArmorBonus())
    override function applyAttackSpeed()
        this.toUnit().setBonusAttackSpeed((this.getAttackSpeedBonus() * this.scaleAttackAnimation).round())
    override function applyStrength()
        if this.isHero
            this.toUnit().setBonusStrength(this.getStrengthBonus())
            if this.hero != null
                this.hero.updateTooltipsStr()
        else
            this.toUnit().setBonusDamage(this.getStrengthBonus())
    override function applyAgility()
        this.toUnit().setBonusAgility(this.getAgilityBonus())
    override function applyIntelligence()
        this.toUnit().setBonusIntelligence(this.getIntelligenceBonus())
        if this.isHero
            if this.hero != null
                this.hero.updateTooltipsInt()
    override function applyMoveSpeed()
        this.toUnit().setMoveSpeed(this.getMoveSpeed().toReal())
    override function applyHealth()
        this.toUnit().setMaxHP(this.getHealth(), true)
    override function applyMana()
        this.toUnit().setMaxMana(this.getMana(), true)
    override function applyHealthRegen()
    override function applyManaRegen()


    // special stats

    function modLifesteal(int modifier)
        checkValid()
        this.lifeSteal += modifier

    function modCooldown(int cd)
        checkValid()
        this.cooldownRecovery += cd
        this.applyCooldown()

    function getCooldown() returns int
        checkValid()
        return this.cooldownRecovery

    function applyCooldown()
        checkValid()
        if this.isHero
            if this.hero != null // when the hero us created, the unit wrapper exists before the hero, so hero may still be null
                this.hero.updateCooldowns()

public function unit.wrapper() returns IUnit
    if this.getTypeId() == 'x01x'
        Log.error("acid spray wrapper. " + getStackTraceString())
    return IUnit.getWrapper(this) castTo IUnit

init
    new IUnitSingleton()
