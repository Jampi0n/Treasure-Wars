package IUnit

import ErrorHandling
import Constants
import HeroTypeImpl
import TeamUtil
import IHero
import UnitWrapper
import UnitInfo
import UnitBuffs
import UnitColor
import UnitStats
import Stats
import BonusMod
import Buff
import FastDamageEvent
import initlater UnitLib
import Assets
import ClosureTimers

class IUnitSingleton extends UnitWrapperSingleton
    override function createNew(unit u)
        new IUnit(u)

public class IUnit extends UnitWrapper
    use UnitInfo
    use UnitColor
    use UnitStats
    use UnitBuffs
    IHero hero
    IHeroType heroType
    IHero owningHero
    int revealCount = 0
    int team
    bool isHero
    real scaleAttackAnimation = 1.0
    real baseScale
    real scaleMultiplier = 1.0
    bool allowItemPickUp = true
    bool allowItemDrop = true
    int lifeSteal = 0
    int attackEventPointer = 0
    int armorReduction = 0
    int armorReductionRelative = 0
    int calculateArmorReduction = 0

    ondestroy
        destroyBuffs()
        destroyStats()
        destroyColor()
        destroyInfo()
        destroyWrapper()
        if attackEventPointer != 0
            DamageEventUnit.fromUnit(this.toUnit()).attackDamageNoBuilding.remove(attackEventPointer)

    construct(unit u)
        super(u)
        this.setStatBaseInternal(Stat.STR, this.getDamageBase())
        this.setStatBaseInternal(Stat.AD, 0)
        this.applyBaseStats()
        this.team = Players.team(this.getOwnerId())
        this.baseScale = u.getField(UNIT_RF_SCALING_VALUE)

        this.isHero = u.isType(UNIT_TYPE_HERO)
        if this.isHero
            this.scaleAttackAnimation = ATTACK_ANIMATION_FACTOR
            this.heroType = HeroType.get(this.getTypeId())
            if this.heroType == null
                error("HeroType could not be resolved: " + u.getName())

            attackEventPointer = DamageEventUnit.fromUnit(u).attackDamageNoBuilding.add() (unit source, unit target, DamageEventUnit sourceWrapper, DamageEventUnit targetWrapper, real damage, boolean attack, boolean active, boolean alternate) ->
                if lifeSteal > 0
                    source.healHP(source, damage * lifeSteal / 100.0)
                    source.addEffect(Abilities.vampiricAuraTarget, "origin").destr()
                if calculateArmorReduction > 0
                    target.addEffect(Abilities.bloodElfSpellThiefMISSILE, "chest").destr()
                    let targetWrapper = target.wrapper()
                    let targetArmor = targetWrapper.getArmor()
                    let reduction = min(targetArmor, calculateArmorReduction) * 0 + 1000
                    targetWrapper.modArmor(-reduction)
                    nullTimer() -> 
                        targetWrapper.modArmor(reduction)

                

    function setAllowItemPickup(bool flag)
        allowItemPickUp = flag

    function getAllowItemPickup() returns bool
        return allowItemPickUp

    function setAllowItemDrop(bool flag)
        allowItemDrop = flag
        for i = 0 to 5
            let itm = this.toUnit().itemInSlot(i)
            if itm != null
                itm.setDroppable(flag)
                itm.setPawnable(flag)

    function getAllowItemDrop() returns bool
        return allowItemDrop

    function setHero(IHero hero)
        this.hero = hero

    function getHeroType() returns IHeroType
        return this.heroType

    function toHero() returns IHero
        return this.hero

    function isHero() returns bool
        return this.isHero

    function getOwningHero() returns IHero
        return this.owningHero

    function setOwningHero(IHero owningHero)
        this.owningHero = owningHero

    function morph()
        this.scale(1)
        this.applyBaseStats()

    function scale(real multiplier)
        this.scaleMultiplier *= multiplier
        this.toUnit().setScale(this.baseScale * this.scaleMultiplier)

    function incReveal()
        revealCount++
        if revealCount == 1
            if this.team == TEAM_1
                UnitShareVision(this.toUnit(), players[Teams.army2()], true)
            else if this.team == TEAM_2
                UnitShareVision(this.toUnit(), players[Teams.army1()], true)

    function decReveal()
        revealCount--
        if revealCount == 0
            if this.team == TEAM_1
                UnitShareVision(this.toUnit(), players[Teams.army2()], false)
            else if this.team == TEAM_2
                UnitShareVision(this.toUnit(), players[Teams.army1()], false)

    function modReveal(int value)
        revealCount += value
        if revealCount > 0
            if this.team == TEAM_1
                UnitShareVision(this.toUnit(), players[Teams.army2()], true)
            else if this.team == TEAM_2
                UnitShareVision(this.toUnit(), players[Teams.army1()], true)
        else
            if this.team == TEAM_1
                UnitShareVision(this.toUnit(), players[Teams.army2()], false)
            else if this.team == TEAM_2
                UnitShareVision(this.toUnit(), players[Teams.army1()], false)

    function modLifesteal(int modifier)
        this.lifeSteal += modifier

    override function applyDamage()
    override function applyArmor()
        this.toUnit().setBonusArmor(this.getArmorBonus())
    override function applyAttackSpeed()
        this.toUnit().setBonusAttackSpeed((this.getAttackSpeedBonus() * this.scaleAttackAnimation).round())
    override function applyStrength()
        if this.isHero
            this.toUnit().setBonusStrength(this.getStrengthBonus())
            if this.hero != null
                this.hero.updateTooltipsStr()
        else
            this.toUnit().setBonusDamage(this.getStrengthBonus())
    override function applyAgility()
        this.toUnit().setBonusAgility(this.getAgilityBonus())
    override function applyIntelligence()
        this.toUnit().setBonusIntelligence(this.getIntelligenceBonus())
        if this.isHero
            if this.hero != null
                this.hero.updateTooltipsInt()
    override function applyMoveSpeed()
        this.toUnit().setMoveSpeed(this.getMoveSpeed().toReal())
    override function applyHealth()
        this.toUnit().setMaxHP(this.getHealth(), true)
    override function applyMana()
        this.toUnit().setMaxMana(this.getMana(), true)
    override function applyHealthRegen()
    override function applyManaRegen()
    override function applyCooldown()
        if this.isHero
            if this.hero != null // when the hero us created, the unit wrapper exists before the hero, so hero may still be null
                this.hero.updateCooldowns()

public function unit.wrapper() returns IUnit
    return IUnit.getWrapper(this) castTo IUnit

init
    new IUnitSingleton()
