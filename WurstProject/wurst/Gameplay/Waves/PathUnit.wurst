package PathUnit

import HashMap
import ClosureTimers
import UnitLib
import IUnit
import Buff
import OnUnitEnterLeave
import ErrorHandling
import Icons
import TeamUtil
import JVectors

constant DEBUG_LINES = false
constant DEBUG_TEXT = false
constant UPDATE_INTERVAL = 2.0
constant NUM_GROUPS = 8

enum PathState
    HOME_TOWN
    RETURNING
    PATH
    ENEMY_TOWN

constant DISTANCE_THRESHOLD = 640000 // squared

constant TOP_X_THRESHOLD = gg_rct_CornerTopBrown.getCenterX()
constant TOP_Y_THRESHOLD = gg_rct_CornerTopGreen.getCenterY()
constant BOT_X_THRESHOLD = gg_rct_CornerBotGreen.getCenterX()
constant BOT_Y_THRESHOLD = gg_rct_CornerBotBrown.getCenterY()
constant TOP_Y_GREEN_FIRST = gg_rct_GreenTopFirst.getCenterY()
constant TOP_X_BROWN_FIRST = gg_rct_BrownTopFirst.getCenterX()
constant BOT_X_GREEN_FIRST = gg_rct_GreenBotFirst.getCenterX()
constant BOT_Y_BROWN_FIRST = gg_rct_BrownBotFirst.getCenterY()

public enum AssignedPath
    GREEN_TOP
    GREEN_MID
    GREEN_BOT
    BROWN_TOP
    BROWN_MID
    BROWN_BOT

enum PathStateNew
    ATTACK_MOVE
    RETURN_MOVE
    PASSIVE_MOVE
    SIEGE_MOVE

function getPathStage(AssignedPath path, vec2 pos) returns int
    if path == GREEN_TOP or path == BROWN_TOP
        if pos.y < TOP_Y_THRESHOLD
            if pos.y < TOP_Y_GREEN_FIRST
                return 1
            else
                return 2

        else if pos.x > TOP_X_THRESHOLD
            if pos.x > TOP_X_BROWN_FIRST
                return 5
            else
                return 4
        else
            return 3
    if path == GREEN_BOT or path == BROWN_BOT
        if pos.x < BOT_X_THRESHOLD
            if pos.x < BOT_X_GREEN_FIRST
                return 11
            else
                return 12
        else if pos.y > BOT_Y_THRESHOLD
            if pos.y > BOT_Y_BROWN_FIRST
                return 15
            else
                return 14
        else
            return 13
    if path == GREEN_MID or path == BROWN_MID
        return 8

    error("no matching path")

    return 0

group array attackMoveGroup
group array returnMoveGroup
group array siegeMoveGroup

vec2 array targetPoint
vec2 array finalPoint

vec2 array homeCastle
rect array baseRect

function initTargetPoints()
    /*
        targetPoints:
        green uses odd increasing numbers
        brown uses even decreasing numbers

        two target points are added to the start and end of every lane for functions that require a next and previous target point
    */

    // top
    targetPoint[0] = gg_rct_GreenCastle.getCenter() + vec2(-500, -500)
    targetPoint[1] = gg_rct_GreenCastle.getCenter() + vec2(-500, -500)

    targetPoint[2] = gg_rct_GreenCastle.getCenter() + vec2(-500, -500)
    targetPoint[3] = gg_rct_GreenTopFirst.getCenter() + vec2(200, 500)
    targetPoint[4] = gg_rct_GreenTopFirst.getCenter() + vec2(0, -500)
    targetPoint[5] = gg_rct_CornerTop.getCenter() + vec2(100, -100)
    targetPoint[6] = gg_rct_CornerTopGreen.getCenter() + vec2(-400, -400)
    targetPoint[7] = gg_rct_CornerTopBrown.getCenter() + vec2(400, 400)
    targetPoint[8] = gg_rct_CornerTop.getCenter() + vec2(100, -100)
    targetPoint[9] = gg_rct_BrownTopFirst.getCenter() + vec2(500, 0)
    targetPoint[10] = gg_rct_BrownTopFirst.getCenter() + vec2(-500, -200)
    targetPoint[11] = gg_rct_BrownCastle.getCenter() + vec2(500, 500)

    targetPoint[12] = gg_rct_BrownCastle.getCenter() + vec2(500, 500)
    targetPoint[13] = gg_rct_BrownCastle.getCenter() + vec2(500, 500)

    // mid
    targetPoint[14] = gg_rct_GreenCastle.getCenter() + vec2(-500, -500)
    targetPoint[15] = gg_rct_GreenCastle.getCenter() + vec2(-500, -500)

    targetPoint[16] = gg_rct_GreenCastle.getCenter() + vec2(-500, -500)
    targetPoint[17] = gg_rct_BrownCastle.getCenter() + vec2(500, 500)

    targetPoint[18] = gg_rct_BrownCastle.getCenter() + vec2(500, 500)
    targetPoint[19] = gg_rct_BrownCastle.getCenter() + vec2(500, 500)

    // bot
    targetPoint[20] = gg_rct_GreenCastle.getCenter() + vec2(-500, -500)
    targetPoint[21] = gg_rct_GreenCastle.getCenter() + vec2(-500, -500)

    targetPoint[22] = gg_rct_GreenCastle.getCenter() + vec2(-500, -500)
    targetPoint[23] = gg_rct_GreenBotFirst.getCenter() + vec2(500, 200)
    targetPoint[24] = gg_rct_GreenBotFirst.getCenter() + vec2(-500, 0)
    targetPoint[25] = gg_rct_CornerBot.getCenter() + vec2(-100, 100)
    targetPoint[26] = gg_rct_CornerBotGreen.getCenter() + vec2(-400, -400)
    targetPoint[27] = gg_rct_CornerBotBrown.getCenter() + vec2(400, 400)
    targetPoint[28] = gg_rct_CornerBot.getCenter() + vec2(-100, 100)
    targetPoint[29] = gg_rct_BrownBotFirst.getCenter() + vec2(0, 500)
    targetPoint[30] = gg_rct_BrownBotFirst.getCenter() + vec2(-200,-500)
    targetPoint[31] = gg_rct_BrownCastle.getCenter() + vec2(500, 500)

    targetPoint[32] = gg_rct_BrownCastle.getCenter() + vec2(500, 500)
    targetPoint[33] = gg_rct_BrownCastle.getCenter() + vec2(500, 500)

    finalPoint[0] = gg_rct_BrownCastle.getCenter() + vec2(500, 500)
    finalPoint[1] = gg_rct_GreenCastle.getCenter() + vec2(-500, -500)

    homeCastle[0] = gg_rct_GreenCastle.getCenter()
    homeCastle[1] = gg_rct_BrownCastle.getCenter()

    baseRect[0] = gg_rct_GreenBase
    baseRect[1] = gg_rct_BrownBase


public constant DEFEND_HOME_BASE = compiletime(setupBuff("Home Base", "This unit has greatly increased combat stats.", Icons.bTNCallToArms, true, 1, "", "", DispelLevel.NONE))
public constant DEFEND_HOME_SIDE = compiletime(setupBuff("Home Side", "This unit has slightly increased combat stats.", Icons.bTNCallToArms, true, 1, "", "", DispelLevel.NONE))

function initBuffs()
    DEFEND_HOME_BASE.addLevelFunction() (Buff thisBuff, int factor) ->
        let target = thisBuff.getTarget().wrapper()
        target.modAttackSpeed(35 * factor)
        target.modStrengthRelative(250 * factor)
        target.modArmor(25 * factor)
    DEFEND_HOME_SIDE.addLevelFunction() (Buff thisBuff, int factor) ->
        let target = thisBuff.getTarget().wrapper()
        target.modAttackSpeed(15 * factor)
        target.modStrengthRelative(100 * factor)
        target.modArmor(10 * factor)


function updatePositionalEffects(PathUnitNew u, vec2 pos)
    // base:
    // lInf distance to castle < 3040 &&    (rectangular corner around base)
    // l1 distance to castle < 3529         (diagonal line for mid)
    // defend:
    // l1 distance to castle < 6833         (diagonal line close to center of the map)
    let xDist = (pos.x - homeCastle[u.team].x).abs()
    let yDist = (pos.y - homeCastle[u.team].y).abs()
    let lInf = max(xDist, yDist)
    let l1 = xDist + yDist
    let target = u.whichUnit
    if lInf < 3040 and l1 < 4400 //3529
        target.addBuff(target, -1, DEFEND_HOME_BASE, 1)
        let b = target.wrapper().getBuffOfType(DEFEND_HOME_SIDE)
        if b != null
            b.dispel()
        //u.whichUnit.setVertexColor(0, 255, 0, 255)
    else if l1 < 8800 //6833
        target.addBuff(target, -1, DEFEND_HOME_SIDE, 1)
        let b = target.wrapper().getBuffOfType(DEFEND_HOME_BASE)
        if b != null
            b.dispel()
        //u.whichUnit.setVertexColor(127, 255, 127, 255)
    else
        var b = target.wrapper().getBuffOfType(DEFEND_HOME_BASE)
        if b != null
            b.dispel()
        b = target.wrapper().getBuffOfType(DEFEND_HOME_SIDE)
        if b != null
            b.dispel()
        //u.whichUnit.setVertexColor(255, 255, 255, 255)


function attackMoveGroup()
    let u = GetEnumUnit()
    if not PathUnitNew.unitToPathUnit.has(u)
        return
    let pathUnit = PathUnitNew.unitToPathUnit.get(u)
    if pathUnit == null
        return
    let pos = u.getPos()
    let team = pathUnit.team
    updatePositionalEffects(pathUnit, pos)
    let stage = getPathStage(pathUnit.path, pos)
    let dist = pos.distanceToSegmentSq(targetPoint[stage*2-1+team], targetPoint[stage*2+1+team])
    let index = pathUnit.index

    if dist <= DISTANCE_THRESHOLD
        pathUnit.lastValidPos = pos
        if baseRect[Teams.invert(team)].contains(pos)
            pathUnit.state = PathStateNew.SIEGE_MOVE
            attackMoveGroup[index].remove(u)
            siegeMoveGroup[index].add(u)
        if not pathUnit.attacking
            if pathUnit.stage != stage
                pathUnit.stage = stage
                u.issuePointOrder("attack", targetPoint[stage*2+Teams.invert(team)])
        else
            pathUnit.attacking = false
    else
        pathUnit.stage = stage
        u.setOwner(players[Teams.ignoreHero(team)], false)
        u.issuePointOrder("attack", pos.nearestOnSegment(targetPoint[stage*2-1+team], targetPoint[stage*2+1+team]))
        pathUnit.returned = false
        pathUnit.state = PathStateNew.RETURN_MOVE
        attackMoveGroup[index].remove(u)
        returnMoveGroup[index].add(u)



function returnMoveGroup()
    let u = GetEnumUnit()
    if not PathUnitNew.unitToPathUnit.has(u)
        return
    let pathUnit = PathUnitNew.unitToPathUnit.get(u)
    if pathUnit == null
        return
    let pos = u.getPos()
    let team = pathUnit.team
    updatePositionalEffects(pathUnit, pos)
    let stage = getPathStage(pathUnit.path, pos)
    let dist = pos.distanceToSegmentSq(targetPoint[stage*2-1+team], targetPoint[stage*2+1+team])
    let index = pathUnit.index

    if dist <= DISTANCE_THRESHOLD * 0.5
        pathUnit.lastValidPos = pos
        if baseRect[Teams.invert(team)].contains(pos)
            pathUnit.state = PathStateNew.SIEGE_MOVE
            returnMoveGroup[index].remove(u)
            u.setOwner(players[Teams.army(team)], false)
            siegeMoveGroup[index].add(u)
        else
            if not pathUnit.returned
                pathUnit.stage = -1 // when the path unit returned, force a new order
                pathUnit.returned = true
                doAfter(5) -> 
                    if u.isAlive()
                        pathUnit.state = PathStateNew.ATTACK_MOVE
                        returnMoveGroup[index].remove(u)
                        u.setOwner(players[Teams.army(team)], false)
                        attackMoveGroup[index].add(u)
                        let newStage = getPathStage(pathUnit.path, pos)
                        u.issuePointOrder("attack", targetPoint[newStage*2+Teams.invert(team)])
                        pathUnit.stage = stage
        if pathUnit.stage != stage
            pathUnit.stage = stage
            u.issuePointOrder("attack", targetPoint[stage*2+Teams.invert(team)])
    else
        if pathUnit.stage != stage
            pathUnit.stage = stage
            u.issuePointOrder("attack", pos.nearestOnSegment(targetPoint[stage*2-1+team], targetPoint[stage*2+1+team]))

function siegeMoveGroup()
    let u = GetEnumUnit()
    if not PathUnitNew.unitToPathUnit.has(u)
        return
    let pathUnit = PathUnitNew.unitToPathUnit.get(u)
    if pathUnit == null
        return
    updatePositionalEffects(pathUnit, u.getPos())
    if not pathUnit.attacking
        u.issuePointOrder("attack", finalPoint[pathUnit.team])
    else
        pathUnit.attacking = false

function initMovement()
    for i = 0 to NUM_GROUPS - 1
        attackMoveGroup[i] = CreateGroup()
        returnMoveGroup[i] = CreateGroup()
        siegeMoveGroup[i] = CreateGroup()

        doAfter(UPDATE_INTERVAL*(i/NUM_GROUPS)) () ->
            doPeriodically(UPDATE_INTERVAL) (CallbackPeriodic cb) ->
                ForGroup(attackMoveGroup[i], function attackMoveGroup)
                ForGroup(returnMoveGroup[i], function returnMoveGroup)
                ForGroup(siegeMoveGroup[i], function siegeMoveGroup)

    onLeave() ->
        let u = getEnterLeaveUnit()
        if PathUnitNew.unitToPathUnit.has(u)
            let pathUnit = PathUnitNew.unitToPathUnit.get(u)
            if pathUnit != null
                let index = pathUnit.index
                attackMoveGroup[index].remove(u)
                returnMoveGroup[index].remove(u)
                siegeMoveGroup[index].remove(u)
                destroy pathUnit



public class PathUnitNew

    protected int index
    protected unit whichUnit
    protected AssignedPath path
    protected PathStateNew state
    protected vec2 lastValidPos
    protected static constant unitToPathUnit = new HashMap<unit,PathUnitNew>
    protected int team
    protected bool attacking = false
    protected texttag info
    protected static PathUnitNew array allPathUnits
    protected static int numPathUnits = 0
    protected int staticArrayIndex
    protected lightning currentLineSegment
    protected int stage = -1
    protected bool returned = false

    construct(unit whichUnit, AssignedPath path)
        this.index = (this castTo int) mod NUM_GROUPS
        this.whichUnit = whichUnit
        this.path = path
        this.state = PathStateNew.ATTACK_MOVE
        if DEBUG_TEXT
            this.info = createTTEx(this.whichUnit.getPos3with(10), "!", 1)
        if DEBUG_LINES
            this.currentLineSegment = addLightning(LIGHTNING_MAGIC_LEASH, false, vec2(0, 0), vec2(0,0))
        
        let stage = getPathStage(path, whichUnit.getPos())
        attackMoveGroup[this.index].add(whichUnit)
        unitToPathUnit.put(whichUnit, this)
        this.team = path == AssignedPath.GREEN_TOP or path == AssignedPath.GREEN_MID or path == AssignedPath.GREEN_BOT ? 0 : 1
        whichUnit.issuePointOrder("attack", targetPoint[stage*2 + Teams.invert(team)])
        this.lastValidPos = targetPoint[stage*2 + team]

        updatePositionalEffects(this, whichUnit.getPos())

        staticArrayIndex = numPathUnits
        allPathUnits[staticArrayIndex] = this
        numPathUnits += 1

    @inline
    static function onAttackStart(unit attacker, unit _target)
        if PathUnitNew.unitToPathUnit.has(attacker)
            let pathUnit = PathUnitNew.unitToPathUnit.get(attacker)
            if pathUnit != null
                pathUnit.attacking = true

    ondestroy
        unitToPathUnit.remove(this.whichUnit)
        allPathUnits[staticArrayIndex] = allPathUnits[numPathUnits-1]
        numPathUnits -= 1
        if DEBUG_TEXT
            this.info.destr()
        if DEBUG_LINES
            this.currentLineSegment.destr()

init
    initTargetPoints()
    initMovement()
    initBuffs()
    if DEBUG_TEXT or DEBUG_LINES
        doPeriodically(0.02) (CallbackPeriodic cb) ->
            for i = 0 to PathUnitNew.numPathUnits-1
                let p = PathUnitNew.allPathUnits[i]
                let stage = getPathStage(p.path, p.whichUnit.getPos())
                p.info.setPos(p.whichUnit.getPos3with(10))
                if DEBUG_TEXT
                    let pos = p.whichUnit.getPos()
                    let dist = (p.team == 0?pos.distanceToSegmentSq(targetPoint[stage*2-1], targetPoint[stage*2+1]):pos.distanceToSegmentSq(targetPoint[stage*2+2], targetPoint[stage*2])).round()
                    p.info.setText(stage.toString() + " " + (p.state castTo int).toString() + " " + dist.toString(), 10)
                if DEBUG_LINES
                    let start = p.team==0?targetPoint[stage*2-1]:targetPoint[stage*2+2]
                    let _end = p.team==0?targetPoint[stage*2+1]:targetPoint[stage*2]
                    p.currentLineSegment.move(false, start, _end)
    

